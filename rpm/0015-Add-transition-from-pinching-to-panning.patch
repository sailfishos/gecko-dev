From ca6654640087304e9d6bfe776807457a573d907a Mon Sep 17 00:00:00 2001
From: Dmitry Rozhkov <dmitry.rozhkov@jolla.com>
Date: Tue, 10 Nov 2015 14:36:10 +0200
Subject: [PATCH 15/15] Add transition from pinching to panning

---
 gfx/layers/apz/src/AsyncPanZoomController.cpp | 13 +++++++++++++
 gfx/layers/apz/src/GestureEventListener.cpp   | 15 ++++++++++++++-
 2 files changed, 27 insertions(+), 1 deletion(-)

diff --git a/gfx/layers/apz/src/AsyncPanZoomController.cpp b/gfx/layers/apz/src/AsyncPanZoomController.cpp
index ceb7f6c..9ff04b4 100644
--- a/gfx/layers/apz/src/AsyncPanZoomController.cpp
+++ b/gfx/layers/apz/src/AsyncPanZoomController.cpp
@@ -1432,6 +1432,19 @@ nsEventStatus AsyncPanZoomController::OnScaleEnd(const PinchGestureInput& aEvent
     UpdateSharedCompositorFrameMetrics();
   }
 
+  // Non-negative focus point would indicate that one finger is still down
+  if (aEvent.mFocusPoint.x != -1 && aEvent.mFocusPoint.y != -1) {
+    mPanDirRestricted = false;
+    mX.StartTouch(aEvent.mFocusPoint.x, aEvent.mTime);
+    mY.StartTouch(aEvent.mFocusPoint.y, aEvent.mTime);
+    if (nsRefPtr<GeckoContentController> controller = GetGeckoContentController()) {
+      controller->NotifyAPZStateChange(
+        GetGuid(), APZStateChange::StartTouch,
+        CurrentTouchBlock()->GetOverscrollHandoffChain()->CanBePanned(this));
+    }
+    SetState(TOUCHING);
+  }
+
   return nsEventStatus_eConsumeNoDefault;
 }
 
diff --git a/gfx/layers/apz/src/GestureEventListener.cpp b/gfx/layers/apz/src/GestureEventListener.cpp
index 76a8b5d..d63da0e 100644
--- a/gfx/layers/apz/src/GestureEventListener.cpp
+++ b/gfx/layers/apz/src/GestureEventListener.cpp
@@ -100,6 +100,13 @@ nsEventStatus GestureEventListener::HandleInputEvent(const MultiTouchInput& aEve
     }
     break;
   case MultiTouchInput::MULTITOUCH_MOVE:
+    for (size_t i = 0; i < aEvent.mTouches.Length(); i++) {
+      for (size_t j = 0; j < mTouches.Length(); j++) {
+        if (aEvent.mTouches[i].mIdentifier == mTouches[j].mIdentifier) {
+          mTouches[j].mScreenPoint = aEvent.mTouches[i].mScreenPoint;
+        }
+      }
+    }
     rv = HandleInputTouchMove();
     break;
   case MultiTouchInput::MULTITOUCH_END:
@@ -367,10 +374,16 @@ nsEventStatus GestureEventListener::HandleInputTouchEnd()
   case GESTURE_PINCH:
     if (mTouches.Length() < 2) {
       SetState(GESTURE_NONE);
+      ScreenPoint point(-1, -1);
+      if (mTouches.Length() == 1) {
+        // As user still keeps one finger down the event's focus point should
+        // contain meaningful data.
+        point = mTouches[0].mScreenPoint;
+      }
       PinchGestureInput pinchEvent(PinchGestureInput::PINCHGESTURE_END,
                                    mLastTouchInput.mTime,
                                    mLastTouchInput.mTimeStamp,
-                                   ScreenPoint(),
+                                   point,
                                    1.0f,
                                    1.0f,
                                    mLastTouchInput.modifiers);
-- 
2.1.4

