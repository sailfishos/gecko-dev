From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Ryan VanderMeulen <ryanvm@gmail.com>
Date: Tue, 3 May 2022 01:29:13 +0000
Subject: [PATCH] Bug 1766848 - Update libevent to version 2.1.12. r=jld

Differential Revision: https://phabricator.services.mozilla.com/D144950
---
 .../src/base/message_pump_libevent.cc         |    1 +
 .../src/third_party/libevent/.clang-format    |   63 -
 .../src/third_party/libevent/.gitignore       |  149 --
 .../src/third_party/libevent/.travis.yml      |  100 -
 .../src/third_party/libevent/.uncrustify      |   55 -
 .../src/third_party/libevent/CMakeLists.txt   | 1245 +++++-----
 .../src/third_party/libevent/ChangeLog        |  313 +++
 .../src/third_party/libevent/ChangeLog-1.4    |    2 +-
 .../src/third_party/libevent/ChangeLog-2.0    |    2 +-
 .../src/third_party/libevent/Doxyfile         |   46 +-
 .../src/third_party/libevent/Makefile.am      |   68 +-
 .../src/third_party/libevent/README.md        |  154 +-
 .../src/third_party/libevent/README.mozilla   |   23 +-
 .../libevent/WIN32-Code/getopt_long.c         |    7 +-
 .../WIN32-Code/nmake/event2/event-config.h    |   26 +-
 .../libevent/android/event2/event-config.h    |  128 +-
 .../src/third_party/libevent/appveyor.yml     |   60 -
 .../src/third_party/libevent/arc4random.c     |   40 +-
 .../libevent/bsd/event2/event-config.h        |  134 +-
 .../src/third_party/libevent/buffer.c         |   50 +-
 .../src/third_party/libevent/buffer_iocp.c    |    1 +
 .../libevent/bufferevent-internal.h           |   36 +
 .../src/third_party/libevent/bufferevent.c    |  115 +-
 .../third_party/libevent/bufferevent_async.c  |   66 +-
 .../third_party/libevent/bufferevent_filter.c |   10 +-
 .../libevent/bufferevent_openssl.c            |   75 +-
 .../third_party/libevent/bufferevent_pair.c   |    4 +-
 .../libevent/bufferevent_ratelim.c            |    9 +-
 .../third_party/libevent/bufferevent_sock.c   |   74 +-
 .../src/third_party/libevent/checkpatch.sh    |    6 +-
 .../libevent/cmake/AddEventLibrary.cmake      |  193 ++
 .../libevent/cmake/CheckConstExists.cmake     |   25 +
 .../libevent/cmake/CheckFunctionExistsEx.c    |   30 -
 .../cmake/CheckFunctionExistsEx.cmake         |   69 -
 .../cmake/CheckWaitpidSupportWNOWAIT.cmake    |   18 -
 .../libevent/cmake/CheckWorkingKqueue.cmake   |    6 +-
 .../third_party/libevent/cmake/FindGit.cmake  |   45 -
 .../libevent/cmake/LibeventConfig.cmake.in    |  182 +-
 .../cmake/LibeventConfigBuildTree.cmake.in    |   17 -
 .../third_party/libevent/cmake/Macros.cmake   |   36 +
 .../libevent/cmake/Uninstall.cmake.in         |   23 +
 .../libevent/cmake/UseDoxygen.cmake           |  111 +
 .../libevent/cmake/VersionViaGit.cmake        |   41 +-
 .../src/third_party/libevent/configure.ac     |  328 +--
 .../src/third_party/libevent/defer-internal.h |    3 +
 .../src/third_party/libevent/doxygen.am       |   55 +
 ipc/chromium/src/third_party/libevent/epoll.c |   15 +-
 .../libevent/epolltable-internal.h            |    2 +-
 .../third_party/libevent/evbuffer-internal.h  |    2 +-
 .../third_party/libevent/evconfig-private.h   |    7 +
 .../libevent/evconfig-private.h.cmake         |    5 +
 .../libevent/evconfig-private.h.in            |    7 +
 ipc/chromium/src/third_party/libevent/evdns.c |  144 +-
 .../third_party/libevent/event-config.h.cmake |  337 ++-
 .../src/third_party/libevent/event-internal.h |   13 +-
 ipc/chromium/src/third_party/libevent/event.c |  392 ++--
 .../src/third_party/libevent/event_iocp.c     |    2 +-
 .../src/third_party/libevent/event_rpcgen.py  | 2057 +++++++++--------
 .../src/third_party/libevent/event_tagging.c  |    4 +
 ipc/chromium/src/third_party/libevent/evmap.c |   43 +-
 ipc/chromium/src/third_party/libevent/evrpc.c |    6 +-
 .../third_party/libevent/evthread-internal.h  |   16 +-
 .../src/third_party/libevent/evthread.c       |    2 +-
 .../src/third_party/libevent/evutil.c         |  144 +-
 .../src/third_party/libevent/evutil_rand.c    |    6 +-
 .../src/third_party/libevent/evutil_time.c    |   65 +-
 .../libevent/extra/abi-check/README.md        |   35 +
 .../libevent/extra/abi-check/abi_check.sh     |   53 +
 .../libevent/extra/abi-check/libevent.json    |   12 +
 .../src/third_party/libevent/extra/lsan.supp  |    3 +
 .../src/third_party/libevent/extra/tsan.supp  |    2 +
 .../src/third_party/libevent/http-internal.h  |    9 +-
 ipc/chromium/src/third_party/libevent/http.c  |  254 +-
 .../libevent/include/event2/buffer.h          |    3 +-
 .../libevent/include/event2/buffer_compat.h   |    3 +-
 .../libevent/include/event2/bufferevent.h     |   11 +-
 .../include/event2/bufferevent_compat.h       |    4 +
 .../third_party/libevent/include/event2/dns.h |   46 +-
 .../libevent/include/event2/dns_compat.h      |   24 +-
 .../libevent/include/event2/event.h           |   77 +-
 .../libevent/include/event2/http.h            |   13 +-
 .../libevent/include/event2/http_compat.h     |    6 +-
 .../libevent/include/event2/listener.h        |   12 +
 .../third_party/libevent/include/event2/rpc.h |   48 +-
 .../libevent/include/event2/rpc_struct.h      |   14 +
 .../libevent/include/event2/util.h            |   34 +-
 .../libevent/include/event2/visibility.h      |   31 +-
 .../third_party/libevent/include/include.am   |    7 +-
 .../src/third_party/libevent/iocp-internal.h  |   14 +
 .../src/third_party/libevent/kqueue.c         |   17 +-
 .../libevent/linux/event2/event-config.h      |  124 +-
 .../src/third_party/libevent/listener.c       |   29 +-
 .../src/third_party/libevent/log-internal.h   |   25 +-
 ipc/chromium/src/third_party/libevent/log.c   |   11 +-
 .../libevent/m4/ax_check_funcs_ex.m4          |   22 +
 .../libevent/m4/ax_prog_doxygen.m4            |  600 +++++
 .../libevent/m4/libevent_openssl.m4           |    9 +
 .../libevent/mac/event2/event-config.h        |  120 +-
 .../libevent/make-event-config.sed            |   10 +-
 .../third_party/libevent/minheap-internal.h   |    6 +-
 .../src/third_party/libevent/mm-internal.h    |    5 +
 .../src/third_party/libevent/openssl-compat.h |   16 +-
 .../libevent/patches/android-api-level.patch  |   35 -
 .../dont-use-issetugid-on-android.patch       |   22 -
 .../libevent/patches/linux-no-sysctl.patch    |   41 -
 .../openbsd-no-arc4random_addrandom.patch     |   62 -
 ipc/chromium/src/third_party/libevent/poll.c  |   25 +-
 .../third_party/libevent/sample/dns-example.c |   17 +-
 .../libevent/sample/event-read-fifo.c         |    4 +-
 .../third_party/libevent/sample/hello-world.c |    3 +-
 .../libevent/sample/http-connect.c            |   86 +-
 .../third_party/libevent/sample/http-server.c |  292 ++-
 .../libevent/sample/https-client.c            |   88 +-
 .../third_party/libevent/sample/include.am    |   11 +-
 .../third_party/libevent/sample/le-proxy.c    |   16 +-
 .../sample/openssl_hostname_validation.c      |    3 +-
 .../third_party/libevent/sample/signal-test.c |   25 +-
 .../third_party/libevent/sample/time-test.c   |    7 +-
 .../src/third_party/libevent/select.c         |    2 +-
 .../src/third_party/libevent/signal.c         |    2 +
 .../libevent/solaris/event2/event-config.h    |  130 +-
 .../third_party/libevent/strlcpy-internal.h   |    2 +
 .../libevent/test-export/CMakeLists.txt       |   15 +
 .../libevent/test-export/test-export.c        |  122 +
 .../libevent/test-export/test-export.py       |  199 ++
 .../src/third_party/libevent/test/bench.c     |   60 +-
 .../third_party/libevent/test/bench_cascade.c |    8 +-
 .../third_party/libevent/test/bench_http.c    |    3 +
 .../libevent/test/bench_httpclient.c          |    4 +-
 .../libevent/test/check-dumpevents.py         |   10 +-
 .../src/third_party/libevent/test/include.am  |   43 +-
 .../src/third_party/libevent/test/regress.c   |  332 ++-
 .../src/third_party/libevent/test/regress.h   |    7 +-
 .../libevent/test/regress_buffer.c            |  369 ++-
 .../libevent/test/regress_bufferevent.c       |  156 +-
 .../third_party/libevent/test/regress_dns.c   |  522 ++++-
 .../third_party/libevent/test/regress_et.c    |  146 +-
 .../libevent/test/regress_finalize.c          |   48 +
 .../third_party/libevent/test/regress_http.c  |  479 ++--
 .../libevent/test/regress_listener.c          |  100 +-
 .../third_party/libevent/test/regress_main.c  |   68 +-
 .../third_party/libevent/test/regress_rpc.c   |   49 +-
 .../third_party/libevent/test/regress_ssl.c   |  404 +++-
 .../libevent/test/regress_testutils.c         |    2 +-
 .../libevent/test/regress_thread.c            |    8 +-
 .../libevent/test/regress_thread.h            |   34 +-
 .../third_party/libevent/test/regress_util.c  |  196 +-
 .../libevent/test/rpcgen_wrapper.sh           |   11 +-
 .../libevent/test/test-changelist.c           |    4 +-
 .../third_party/libevent/test/test-closed.c   |    1 +
 .../src/third_party/libevent/test/test-eof.c  |    4 +-
 .../third_party/libevent/test/test-fdleak.c   |   15 +-
 .../src/third_party/libevent/test/test-init.c |    2 +-
 .../third_party/libevent/test/test-ratelim.c  |   87 +-
 .../src/third_party/libevent/test/test-time.c |   25 +-
 .../src/third_party/libevent/test/test-weof.c |    4 +-
 .../src/third_party/libevent/test/test.sh     |    4 +-
 .../src/third_party/libevent/test/tinytest.c  |  169 +-
 .../src/third_party/libevent/test/tinytest.h  |    5 +-
 .../third_party/libevent/test/tinytest_demo.c |   30 +
 .../libevent/test/tinytest_macros.h           |   12 +-
 .../src/third_party/libevent/time-internal.h  |    3 +
 .../src/third_party/libevent/util-internal.h  |   72 +-
 .../src/third_party/libevent/win32select.c    |    3 +-
 ipc/chromium/src/third_party/moz.build        |    7 +-
 165 files changed, 9457 insertions(+), 4480 deletions(-)
 delete mode 100644 ipc/chromium/src/third_party/libevent/.clang-format
 delete mode 100644 ipc/chromium/src/third_party/libevent/.gitignore
 delete mode 100644 ipc/chromium/src/third_party/libevent/.travis.yml
 delete mode 100644 ipc/chromium/src/third_party/libevent/.uncrustify
 delete mode 100644 ipc/chromium/src/third_party/libevent/appveyor.yml
 create mode 100644 ipc/chromium/src/third_party/libevent/cmake/AddEventLibrary.cmake
 create mode 100644 ipc/chromium/src/third_party/libevent/cmake/CheckConstExists.cmake
 delete mode 100644 ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.c
 delete mode 100644 ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.cmake
 delete mode 100644 ipc/chromium/src/third_party/libevent/cmake/CheckWaitpidSupportWNOWAIT.cmake
 delete mode 100644 ipc/chromium/src/third_party/libevent/cmake/FindGit.cmake
 delete mode 100644 ipc/chromium/src/third_party/libevent/cmake/LibeventConfigBuildTree.cmake.in
 create mode 100644 ipc/chromium/src/third_party/libevent/cmake/Macros.cmake
 create mode 100644 ipc/chromium/src/third_party/libevent/cmake/Uninstall.cmake.in
 create mode 100644 ipc/chromium/src/third_party/libevent/cmake/UseDoxygen.cmake
 create mode 100644 ipc/chromium/src/third_party/libevent/doxygen.am
 create mode 100644 ipc/chromium/src/third_party/libevent/extra/abi-check/README.md
 create mode 100755 ipc/chromium/src/third_party/libevent/extra/abi-check/abi_check.sh
 create mode 100644 ipc/chromium/src/third_party/libevent/extra/abi-check/libevent.json
 create mode 100644 ipc/chromium/src/third_party/libevent/extra/lsan.supp
 create mode 100644 ipc/chromium/src/third_party/libevent/extra/tsan.supp
 create mode 100644 ipc/chromium/src/third_party/libevent/m4/ax_check_funcs_ex.m4
 create mode 100644 ipc/chromium/src/third_party/libevent/m4/ax_prog_doxygen.m4
 delete mode 100644 ipc/chromium/src/third_party/libevent/patches/android-api-level.patch
 delete mode 100644 ipc/chromium/src/third_party/libevent/patches/dont-use-issetugid-on-android.patch
 delete mode 100644 ipc/chromium/src/third_party/libevent/patches/linux-no-sysctl.patch
 delete mode 100644 ipc/chromium/src/third_party/libevent/patches/openbsd-no-arc4random_addrandom.patch
 create mode 100644 ipc/chromium/src/third_party/libevent/test-export/CMakeLists.txt
 create mode 100644 ipc/chromium/src/third_party/libevent/test-export/test-export.c
 create mode 100644 ipc/chromium/src/third_party/libevent/test-export/test-export.py

diff --git a/ipc/chromium/src/base/message_pump_libevent.cc b/ipc/chromium/src/base/message_pump_libevent.cc
index 446be35a22f0..8ac75751fcde 100644
--- a/ipc/chromium/src/base/message_pump_libevent.cc
+++ b/ipc/chromium/src/base/message_pump_libevent.cc
@@ -41,6 +41,7 @@ CHECK_EVENT_SIZEOF(OFF_T, ev_off_t);
 CHECK_EVENT_SIZEOF(PTHREAD_T, pthread_t);
 CHECK_EVENT_SIZEOF(SHORT, short);
 CHECK_EVENT_SIZEOF(SIZE_T, size_t);
+CHECK_EVENT_SIZEOF(TIME_T, time_t);
 CHECK_EVENT_SIZEOF(VOID_P, void*);
 
 // Lifecycle of struct event
diff --git a/ipc/chromium/src/third_party/libevent/.clang-format b/ipc/chromium/src/third_party/libevent/.clang-format
deleted file mode 100644
index a9722db28624..000000000000
--- a/ipc/chromium/src/third_party/libevent/.clang-format
+++ /dev/null
@@ -1,63 +0,0 @@
----
-Language:          Cpp
-BasedOnStyle:      LLVM
-
-AccessModifierOffset: -4
-
-AlignAfterOpenBracket: DontAlign
-AlignEscapedNewlinesLeft: true
-# AlignOperands: true
-AlignTrailingComments: true
-
-AllowAllParametersOfDeclarationOnNextLine: true
-AllowShortBlocksOnASingleLine: false
-AllowShortCaseLabelsOnASingleLine: false
-AllowShortFunctionsOnASingleLine: All
-AllowShortIfStatementsOnASingleLine: false
-AllowShortLoopsOnASingleLine: false
-
-AlwaysBreakAfterDefinitionReturnType: All
-AlwaysBreakBeforeMultilineStrings: false
-AlwaysBreakTemplateDeclarations: false
-
-# BinPackArguments: false
-# BinPackParameters: true
-
-BreakBeforeBinaryOperators: false
-BreakBeforeBraces: Custom
-BraceWrapping: { AfterFunction: true }
-BreakBeforeTernaryOperators: true
-BreakConstructorInitializersBeforeComma: true
-
-ColumnLimit:     80
-
-ContinuationIndentWidth: 4
-
-DerivePointerAlignment: false #XXX
-DisableFormat:   false
-ExperimentalAutoDetectBinPacking: false #XXX
-ForEachMacros:   [ LIST_FOREACH, SIMPLEQ_FOREACH, CIRCLEQ_FOREACH, TAILQ_FOREACH, TAILQ_FOREACH_REVERSE, HT_FOREACH ]
-
-IndentCaseLabels: false
-IndentFunctionDeclarationAfterType: false
-IndentWidth:     4
-IndentWrappedFunctionNames: false
-
-KeepEmptyLinesAtTheStartOfBlocks: true
-MaxEmptyLinesToKeep: 2
-
-PointerAlignment: Right #XXX
-
-# SpaceAfterCStyleCast: false
-SpaceBeforeAssignmentOperators: true
-SpaceBeforeParens: ControlStatements
-SpaceInEmptyParentheses: false
-SpacesBeforeTrailingComments: 1
-SpacesInAngles:  false
-SpacesInCStyleCastParentheses: false
-SpacesInParentheses: false
-Standard:        Cpp03
-TabWidth:        4
-UseTab:          Always
-SortIncludes:    false
-...
diff --git a/ipc/chromium/src/third_party/libevent/.gitignore b/ipc/chromium/src/third_party/libevent/.gitignore
deleted file mode 100644
index 996100453441..000000000000
--- a/ipc/chromium/src/third_party/libevent/.gitignore
+++ /dev/null
@@ -1,149 +0,0 @@
-### These files should get ignored no matter where they appear.
-
-# Editors leave these lying around
-\#*\#
-.#*
-*~
-*.swp
-
-# C stuff
-*.o
-
-# Windows stuff
-*.obj
-*.exe
-*.lib
-
-# Patch leaves these lying arround
-*.orig
-*.rej
-
-# gcov stuff
-*.gcno
-*.gcov
-*.gcda
-
-# gdb stuff
-.gdb_history
-
-# Autotools stuff
-.deps
-.dirstamp
-Makefile
-Makefile.in
-
-# Libtool stuff
-.libs
-*.lo
-*.la
-
-# ctags stuff
-TAGS
-tags
-
-# cscope stuff
-cscope*
-
-# Stuff made by our makefiles
-*.pc
-*.log
-*.trs
-
-## The initial / makes these files only get ignored in particular directories.
-/autom4te.cache
-
-# configure in progress
-/.cyg*
-/confdefs.*
-/conftest.*
-
-# Libtool adds these, at least sometimes
-/m4/libtool.m4
-/m4/ltoptions.m4
-/m4/ltsugar.m4
-/m4/ltversion.m4
-/m4/lt~obsolete.m4
-
-/aclocal.m4
-/compile
-/doxygen
-/config.cache
-/config.guess
-/config.log
-/config.status
-/config.sub
-/configure
-/configure.lineno
-/depcomp
-/config.h
-/config.h.in
-/install-sh
-/libtool
-/ltmain.sh
-/missing
-/stamp-h1
-/stamp-h2
-
-/include/event2/event-config.h
-/evconfig-private.h
-
-/sample/dns-example
-/sample/event-read-fifo
-/sample/hello-world
-/sample/http-server
-/sample/http-connect
-/sample/le-proxy
-/sample/https-client
-/sample/signal-test
-/sample/time-test
-/sample/event-test
-
-/test-driver
-/test/bench
-/test/bench_cascade
-/test/bench_http
-/test/bench_httpclient
-/test/regress
-/test/regress.gen.c
-/test/regress.gen.h
-/test/rpcgen-attempted
-/test/test-dumpevents
-/test/test-eof
-/test/test-closed
-/test/test-init
-/test/test-ratelim
-/test/test-script.sh
-/test/test-time
-/test/test-weof
-/test/test-changelist
-/test/test-fdleak
-
-
-# Files generated by cmake
-/CMakeCache.txt
-/CMakeFiles/
-/CTestTestfile.cmake
-/DartConfiguration.tcl
-/LibeventConfig.cmake
-/LibeventConfigVersion.cmake
-/LibeventTargets.cmake
-/bin/
-/cmake_install.cmake
-/include/evconfig-private.h
-/lib/
-/tmp/
-/verify_tests.sh
-/verify_tests.bat
-/event.dir
-/event_core.dir
-/event_extra.dir
-*.vcxproj
-*.sln
-*.filters
-
-# make dist
-/COPYING
-/INSTALL
-/*.tar.gz
-
-/.vagrant
diff --git a/ipc/chromium/src/third_party/libevent/.travis.yml b/ipc/chromium/src/third_party/libevent/.travis.yml
deleted file mode 100644
index cc370e9f005b..000000000000
--- a/ipc/chromium/src/third_party/libevent/.travis.yml
+++ /dev/null
@@ -1,100 +0,0 @@
-os:
-  - linux
-  - osx
-sudo: false
-dist: trusty
-
-env:
-  matrix:
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS="-DEVENT__COVERAGE=ON -DCMAKE_BUILD_TYPE=debug" COVERALLS=yes
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS=""
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS="-DEVENT__DISABLE_OPENSSL=ON"
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS="-DEVENT__DISABLE_THREAD_SUPPORT=ON"
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS="-DEVENT__DISABLE_DEBUG_MODE=ON"
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS="-DEVENT__DISABLE_MM_REPLACEMENT=ON"
-    - EVENT_BUILD_METHOD=cmake EVENT_CMAKE_OPTIONS="-DEVENT__ENABLE_VERBOSE_DEBUG=ON"
-    - EVENT_BUILD_METHOD=autotools EVENT_CONFIGURE_OPTIONS=""
-    - EVENT_BUILD_METHOD=autotools EVENT_CONFIGURE_OPTIONS="--disable-openssl"
-    - EVENT_BUILD_METHOD=autotools EVENT_CONFIGURE_OPTIONS="--disable-thread-support"
-    - EVENT_BUILD_METHOD=autotools EVENT_CONFIGURE_OPTIONS="--disable-debug-mode"
-    - EVENT_BUILD_METHOD=autotools EVENT_CONFIGURE_OPTIONS="--disable-malloc-replacement"
-
-language: c
-compiler:
-  - gcc
-  - clang
-
-before_install:
-  - if [ -n "$COVERALLS" ]; then
-      pip install --user cpp-coveralls;
-    fi
-  - export JOBS=20
-  - export TIMEOUT=50
-  - if [ "$TRAVIS_OS_NAME" == "osx" ]; then
-      brew update;
-      brew uninstall libtool && brew install libtool;
-      brew install openssl;
-      brew install lcov;
-      if [ "$CC" == "gcc" ]; then
-        export CC=$(ls -t /usr/local/bin/gcc-?.?);
-      fi
-
-      export OPENSSL_ROOT=$(echo /usr/local/Cellar/openssl/*);
-      export
-        CMAKE_INCLUDE_PATH=$OPENSSL_ROOT/include
-        CMAKE_LIBRARY_PATH=$OPENSSL_ROOT/lib;
-      export
-        CFLAGS=-I$CMAKE_INCLUDE_PATH
-        LDFLAGS=-L$CMAKE_LIBRARY_PATH;
-
-      export JOBS=4;
-    fi
-
-addons:
-  apt:
-    sources:
-    - xenial
-    - sourceline: 'deb http://archive.ubuntu.com/ubuntu xenial main'
-    packages:
-    - zlib1g-dev
-    - libssl-dev
-    - build-essential
-    - automake
-    - autoconf
-    - cmake
-    - lcov
-
-script:
-  - if [ "$EVENT_BUILD_METHOD" = "autotools" ]; then
-      ./autogen.sh &&
-      ./configure $EVENT_CONFIGURE_OPTIONS &&
-      make &&
-      travis_wait $TIMEOUT make -j $JOBS verify;
-    fi
-  - if [ "$EVENT_BUILD_METHOD" = "cmake" ]; then
-      export
-        CTEST_PARALLEL_LEVEL=$JOBS
-        CTEST_OUTPUT_ON_FAILURE=1;
-
-      mkdir build &&
-      cd build &&
-      cmake .. $EVENT_CMAKE_OPTIONS &&
-      travis_wait $TIMEOUT
-      cmake --build . --target verify;
-    fi
-
-after_script:
-  - if [ -n "$COVERALLS" ]; then
-      coveralls
-        --build-root .
-        --root ..
-        --exclude test
-        --exclude sample
-        --exclude cmake
-        --exclude build/CMakeFiles/CheckTypeSize
-        --exclude build/CMakeFiles/CompilerIdC
-        --gcov-options '\-lp';
-    fi
-
-notifications:
-  irc: "irc.oftc.net#libevent"
diff --git a/ipc/chromium/src/third_party/libevent/.uncrustify b/ipc/chromium/src/third_party/libevent/.uncrustify
deleted file mode 100644
index da2daa13501e..000000000000
--- a/ipc/chromium/src/third_party/libevent/.uncrustify
+++ /dev/null
@@ -1,55 +0,0 @@
-input_tab_size                           = 8
-output_tab_size                          = 8
-indent_with_tabs                         = 2
-indent_cmt_with_tabs                     = false
-indent_brace_parent                      = false
-indent_func_call_param                   = true
-indent_func_def_param                    = true
-sp_enum_before_assign                    = add
-sp_enum_after_assign                     = add
-sp_inside_paren                          = remove
-sp_paren_brace                           = add
-sp_before_ptr_star                       = add
-sp_before_unnamed_ptr_star               = add
-sp_between_ptr_star                      = remove
-sp_after_ptr_star                        = remove
-sp_after_ptr_star_func                   = add
-sp_before_ptr_star_func                  = add
-sp_before_sparen                         = add
-sp_inside_sparen                         = remove
-sp_inside_sparen_close                   = remove
-sp_after_sparen                          = add
-sp_sparen_brace                          = add
-sp_special_semi                          = remove
-sp_before_semi_for                       = remove
-sp_after_comma                           = add
-sp_after_cast                            = remove
-sp_inside_braces_struct                  = add
-sp_type_func                             = remove
-sp_func_def_paren                        = remove
-sp_inside_fparen                         = remove
-sp_fparen_brace                          = add
-sp_func_call_paren                       = remove
-sp_else_brace                            = add
-sp_after_oc_block_caret                  = remove
-align_keep_tabs                          = true
-align_with_tabs                          = true
-align_on_tabstop                         = true
-nl_fcall_brace                           = remove
-nl_enum_brace                            = remove
-nl_struct_brace                          = remove
-nl_union_brace                           = remove
-nl_if_brace                              = remove
-nl_brace_else                            = remove
-nl_elseif_brace                          = remove
-nl_else_brace                            = remove
-nl_else_if                               = remove
-nl_for_brace                             = remove
-sp_after_semi_for_empty                  = remove
-nl_while_brace                           = remove
-nl_do_brace                              = remove
-nl_brace_while                           = remove
-nl_switch_brace                          = remove
-nl_func_type_name                        = add
-nl_fdef_brace                            = add
-mod_paren_on_return                      = ignore
diff --git a/ipc/chromium/src/third_party/libevent/CMakeLists.txt b/ipc/chromium/src/third_party/libevent/CMakeLists.txt
index b4a34f3d26ae..676727f16563 100644
--- a/ipc/chromium/src/third_party/libevent/CMakeLists.txt
+++ b/ipc/chromium/src/third_party/libevent/CMakeLists.txt
@@ -18,10 +18,17 @@
 #       cmake -G "Visual Studio 10" ..
 #       start libevent.sln
 #
-if (WIN32)
-    cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
-else()
-    cmake_minimum_required(VERSION 2.8.0 FATAL_ERROR)
+
+cmake_minimum_required(VERSION 3.1 FATAL_ERROR)
+
+if (POLICY CMP0054)
+    cmake_policy(SET CMP0054 NEW)
+endif()
+if (POLICY CMP0074)
+    cmake_policy(SET CMP0074 NEW)
+endif()
+if (POLICY CMP0075)
+    cmake_policy(SET CMP0075 NEW)
 endif()
 
 if(NOT CMAKE_BUILD_TYPE)
@@ -34,24 +41,25 @@ string(TOLOWER "${CMAKE_BUILD_TYPE}" CMAKE_BUILD_TYPE_LOWER)
 # what? why would you get id of other useful build types? - Ellzey
 set(CMAKE_CONFIGURATION_TYPES "Debug;Release" CACHE STRING "Limited configurations" FORCE)
 
+set(EVENT__LIBRARY_TYPE DEFAULT CACHE STRING
+    "Set library type to SHARED/STATIC/BOTH (default SHARED for MSVC, otherwise BOTH)")
+
 project(libevent C)
 
-set(CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake/")
+list(APPEND CMAKE_MODULE_PATH "${PROJECT_SOURCE_DIR}/cmake/")
 string(REGEX MATCH "SunOS" SOLARIS "${CMAKE_SYSTEM_NAME}")
 
 
 include(CheckTypeSize)
-include(CheckFunctionExistsEx)
 include(CheckFileOffsetBits)
-include(CheckFunctionExists)
-include(CheckIncludeFile)
-include(CheckIncludeFiles)
+include(Macros)
 include(CheckVariableExists)
 include(CheckSymbolExists)
 include(CheckStructHasMember)
 include(CheckCSourceCompiles)
 include(CheckPrototypeDefinition)
 include(CheckFunctionKeywords)
+include(CheckConstExists)
 include(AddCompilerFlags)
 include(VersionViaGit)
 
@@ -73,37 +81,41 @@ set(EVENT_ABI_LIBVERSION
 set(EVENT_PACKAGE_VERSION
     "${EVENT_VERSION_MAJOR}.${EVENT_VERSION_MINOR}.${EVENT_VERSION_PATCH}")
 
-set(EVENT_NUMERIC_VERSION 0x02010800)
+set(EVENT_NUMERIC_VERSION 0x02010c00)
+# equals to VERSION_INFO in Makefile.am
+set(EVENT_ABI_LIBVERSION_CURRENT   7)
+set(EVENT_ABI_LIBVERSION_REVISION  1)
+set(EVENT_ABI_LIBVERSION_AGE       0)
+
+# equals to RELEASE in Makefile.am
+set(EVENT_PACKAGE_RELEASE 2.1)
 
 # only a subset of names can be used, defaults to "beta"
-set(EVENT_STAGE_NAME ${EVENT_VERSION_STAGE}
-	CACHE STRING "set the stage name (beta|alpha|release)")
+set(EVENT_STAGE_NAME ${EVENT_VERSION_STAGE})
 
 # a list that defines what can set for EVENT_STAGE_VERSION
 set(EVENT__ALLOWED_STAGE_NAMES
-    rc
-    beta
-    alpha
-    release)
-
-# attempt to find the EVENT__STAGE_VERSION in the allowed list
-# of accepted stage names, the return value is stord in
-# EVENT__STAGE_RET
-
-list(FIND EVENT__ALLOWED_STAGE_NAMES
-	${EVENT_STAGE_NAME}
-	EVENT__STAGE_RET)
-
-if (EVENT__STAGE_RET EQUAL "-1")
+	rc
+	beta
+	alpha
+	alpha-dev
+	release
+	stable
+)
+list(
+	FIND EVENT__ALLOWED_STAGE_NAMES
+	"${EVENT_STAGE_NAME}"
+	EVENT__STAGE_RET
+)
+if (EVENT__STAGE_RET EQUAL -1)
+	message(WARNING
+		"stage ${EVENT_STAGE_NAME} is not allowed, reset to beta")
 	set(EVENT_STAGE_NAME beta)
 endif()
 
 set(EVENT_VERSION
 	"${EVENT_VERSION_MAJOR}.${EVENT_VERSION_MINOR}.${EVENT_VERSION_PATCH}-${EVENT_STAGE_NAME}")
 
-option(EVENT__BUILD_SHARED_LIBRARIES
-    "Define if libevent should be built with shared libraries instead of archives" OFF)
-
 option(EVENT__DISABLE_DEBUG_MODE
     "Define if libevent should build without support for a debug mode" OFF)
 
@@ -117,10 +129,10 @@ option(EVENT__DISABLE_THREAD_SUPPORT
     "Define if libevent should not be compiled with thread support" OFF)
 
 option(EVENT__DISABLE_OPENSSL
-    "Define if libevent should build without support for OpenSSL encrpytion" OFF)
+    "Define if libevent should build without support for OpenSSL encryption" OFF)
 
 option(EVENT__DISABLE_BENCHMARK
-    "Defines if libevent should build without the benchmark exectuables" OFF)
+    "Defines if libevent should build without the benchmark executables" OFF)
 
 option(EVENT__DISABLE_TESTS
     "If tests should be compiled or not" OFF)
@@ -135,7 +147,7 @@ option(EVENT__DISABLE_CLOCK_GETTIME
     "Do not use clock_gettime even if it is available" OFF)
 
 option(EVENT__FORCE_KQUEUE_CHECK
-    "When crosscompiling forces running a test program that verifies that Kqueue works with pipes. Note that this requires you to manually run the test program on the the cross compilation target to verify that it works. See cmake documentation for try_run for more details" OFF)
+    "When crosscompiling forces running a test program that verifies that Kqueue works with pipes. Note that this requires you to manually run the test program on the cross compilation target to verify that it works. See cmake documentation for try_run for more details" OFF)
 
 # TODO: Add --disable-largefile     omit support for large files
 option(EVENT__COVERAGE
@@ -143,14 +155,28 @@ option(EVENT__COVERAGE
 
 # Put the libaries and binaries that get built into directories at the
 # top of the build tree rather than in hard-to-find leaf directories.
-set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
-set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
-set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+#
+# But only if this variables are not defined yet
+# (i.e. libevent is used via add_subdirectory())
+if (NOT DEFINED CMAKE_RUNTIME_OUTPUT_DIRECTORY)
+    set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/bin)
+endif()
+if (NOT DEFINED CMAKE_LIBRARY_OUTPUT_DIRECTORY)
+    set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+endif()
+if (NOT DEFINED CMAKE_ARCHIVE_OUTPUT_DIRECTORY)
+    set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}/lib)
+endif()
 
 if (EVENT__ENABLE_VERBOSE_DEBUG)
     add_definitions(-DUSE_DEBUG=1)
 endif()
 
+# make it colorful under ninja-build
+if ("${CMAKE_GENERATOR}" STREQUAL "Ninja")
+    add_compiler_flags(-fdiagnostics-color=always)
+endif()
+
 # Setup compiler flags for coverage.
 if (EVENT__COVERAGE)
     if (NOT "${CMAKE_BUILD_TYPE_LOWER}" STREQUAL "debug")
@@ -164,14 +190,111 @@ if (EVENT__COVERAGE)
     set(CMAKE_REQUIRED_LIBRARIES "")
 endif()
 
-# GCC specific options.
-if (CMAKE_COMPILER_IS_GNUCC)
+set(GNUC 0)
+set(CLANG 0)
+set(MSVC 0)
+if (("${CMAKE_C_COMPILER_ID}" STREQUAL "Clang") OR
+    ("${CMAKE_C_COMPILER_ID}" STREQUAL "AppleClang"))
+    set(CLANG 1)
+endif()
+if (("${CMAKE_C_COMPILER_ID}" STREQUAL "GNU") OR (${CLANG}))
+    set(GNUC 1)
+endif()
+if (("${CMAKE_C_COMPILER_ID}" STREQUAL "MSVC") OR (${CLANG}))
+    set(MSVC 1)
+endif()
+
+# Detect library type
+set(EVENT_LIBRARY_TYPE)
+if ("${EVENT__LIBRARY_TYPE}" STREQUAL "DEFAULT")
+    if (${MSVC})
+        set(EVENT_LIBRARY_TYPE SHARED)
+    else()
+        set(EVENT_LIBRARY_TYPE BOTH)
+    endif()
+else()
+    string(TOUPPER "${EVENT__LIBRARY_TYPE}" EVENT_LIBRARY_TYPE)
+endif()
+if ((${MSVC}) AND ("${EVENT_LIBRARY_TYPE}" STREQUAL "BOTH"))
+    message(WARNING
+      "Building SHARED and STATIC is not supported for MSVC "
+      "(due to conflicts in library name"
+      " between STATIC library and IMPORTED library for SHARED libraries)")
+endif()
+set(EVENT_LIBRARY_STATIC OFF)
+set(EVENT_LIBRARY_SHARED OFF)
+if ("${EVENT_LIBRARY_TYPE}" STREQUAL "BOTH")
+    set(EVENT_LIBRARY_STATIC ON)
+    set(EVENT_LIBRARY_SHARED ON)
+elseif ("${EVENT_LIBRARY_TYPE}" STREQUAL "STATIC")
+    set(EVENT_LIBRARY_STATIC ON)
+elseif ("${EVENT_LIBRARY_TYPE}" STREQUAL "SHARED")
+    set(EVENT_LIBRARY_SHARED ON)
+else()
+    message(FATAL_ERROR "${EVENT_LIBRARY_TYPE} is not supported")
+endif()
+
+if (${MSVC})
+    set(msvc_static_runtime OFF)
+    if ("${EVENT_LIBRARY_TYPE}" STREQUAL "STATIC")
+        set(msvc_static_runtime ON)
+    endif()
+
+    # For more info:
+    # - https://docs.microsoft.com/en-us/cpp/build/reference/md-mt-ld-use-run-time-library?view=vs-2017
+    # - https://gitlab.kitware.com/cmake/community/wikis/FAQ#how-can-i-build-my-msvc-application-with-a-static-runtime
+    option(EVENT__MSVC_STATIC_RUNTIME
+           "Link static runtime libraries"
+           ${msvc_static_runtime})
+
+    if (EVENT__MSVC_STATIC_RUNTIME)
+        foreach (flag_var
+                 CMAKE_C_FLAGS_DEBUG
+                 CMAKE_C_FLAGS_RELEASE
+                 CMAKE_C_FLAGS_MINSIZEREL
+                 CMAKE_C_FLAGS_RELWITHDEBINFO
+        )
+            if (${flag_var} MATCHES "/MD")
+                string(REGEX REPLACE "/MD" "/MT" ${flag_var} "${${flag_var}}")
+            endif()
+        endforeach()
+    endif()
+endif()
+
+# GNUC specific options.
+if (${GNUC})
     option(EVENT__DISABLE_GCC_WARNINGS "Disable verbose warnings with GCC" OFF)
     option(EVENT__ENABLE_GCC_HARDENING "Enable compiler security checks" OFF)
     option(EVENT__ENABLE_GCC_FUNCTION_SECTIONS "Enable gcc function sections" OFF)
     option(EVENT__ENABLE_GCC_WARNINGS "Make all GCC warnings into errors" OFF)
 
-    list(APPEND __FLAGS -Wall -Wswitch)
+    set(GCC_V ${CMAKE_C_COMPILER_VERSION})
+
+    list(APPEND __FLAGS
+         -Wall -Wextra -Wno-unused-parameter -Wstrict-aliasing -Wstrict-prototypes
+
+         -fno-strict-aliasing # gcc 2.9.5+
+         -Wmissing-prototypes
+
+         # gcc 4
+         -Winit-self
+         -Wmissing-field-initializers
+         -Wdeclaration-after-statement
+
+         # gcc 4.2
+         -Waddress
+         -Wnormalized=id
+         -Woverride-init
+
+         # gcc 4.5
+         -Wlogical-op
+
+         -Wwrite-strings
+    )
+
+    if (${CLANG})
+        list(APPEND __FLAGS -Wno-unused-function)
+    endif()
 
     if (EVENT__DISABLE_GCC_WARNINGS)
         list(APPEND __FLAGS -w)
@@ -197,10 +320,6 @@ if (CMAKE_COMPILER_IS_GNUCC)
         list(APPEND __FLAGS -Werror)
     endif()
 
-    # We need to test for at least gcc 2.95 here, because older versions don't
-    # have -fno-strict-aliasing
-    list(APPEND __FLAGS -fno-strict-aliasing)
-
     add_compiler_flags(${__FLAGS})
 endif()
 
@@ -212,146 +331,190 @@ if (APPLE)
     )
 endif()
 
+if (MINGW OR CYGWIN)
+    set(WIN32 TRUE)
+endif()
+
 # Winsock.
 if(WIN32)
-    set(CMAKE_EXTRA_INCLUDE_FILES winsock2.h ws2tcpip.h)
-    set(CMAKE_REQUIRED_LIBRARIES  ws2_32.lib)
-    set(CMAKE_REQUIRED_DEFINITIONS -FIwinsock2.h -FIws2tcpip.h)
+    set(CMAKE_REQUIRED_LIBRARIES  ws2_32 shell32 advapi32)
+    set(CMAKE_REQUIRED_DEFINITIONS -FIwinsock2.h -FIws2tcpip.h -D_WIN32_WINNT=0x0600)
 endif()
 if (SOLARIS)
     set(CMAKE_REQUIRED_LIBRARIES socket nsl)
 endif()
 
 # Check if _GNU_SOURCE is available.
-CHECK_SYMBOL_EXISTS(__GNU_LIBRARY__ "features.h" _GNU_SOURCE)
+if (NOT DEFINED _GNU_SOURCE)
+  CHECK_SYMBOL_EXISTS(__GNU_LIBRARY__ "features.h" _GNU_SOURCE)
+
+  if (NOT _GNU_SOURCE)
+    unset(_GNU_SOURCE CACHE)
+    CHECK_SYMBOL_EXISTS(_GNU_SOURCE "features.h" _GNU_SOURCE)
+  endif()
+
+  if (ANDROID)
+    set(_GNU_SOURCE TRUE)
+  endif()
+endif()
 
 if (_GNU_SOURCE)
-    add_definitions(-D_GNU_SOURCE)
-endif()
-
-CHECK_INCLUDE_FILE(sys/types.h EVENT__HAVE_SYS_TYPES_H)
-if(EVENT__HAVE_SYS_TYPES_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES sys/types.h)
-endif()
-
-CHECK_INCLUDE_FILE(sys/socket.h EVENT__HAVE_SYS_SOCKET_H)
-if(EVENT__HAVE_SYS_SOCKET_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES sys/socket.h)
-endif()
-
-CHECK_INCLUDE_FILE(netinet/in.h EVENT__HAVE_NETINET_IN_H)
-if(EVENT__HAVE_NETINET_IN_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES netinet/in.h)
-endif()
-
-CHECK_INCLUDE_FILE(netinet/in6.h EVENT__HAVE_NETINET_IN6_H)
-if(EVENT__HAVE_NETINET_IN6_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES netinet/in6.h)
-endif()
-
-CHECK_INCLUDE_FILE(unistd.h EVENT__HAVE_UNISTD_H)
-CHECK_INCLUDE_FILE(netdb.h EVENT__HAVE_NETDB_H)
-CHECK_INCLUDE_FILE(dlfcn.h EVENT__HAVE_DLFCN_H)
-CHECK_INCLUDE_FILE(arpa/inet.h EVENT__HAVE_ARPA_INET_H)
-CHECK_INCLUDE_FILE(fcntl.h EVENT__HAVE_FCNTL_H)
-if(EVENT__HAVE_FCNTL_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES fcntl.h)
-endif()
-CHECK_INCLUDE_FILE(inttypes.h EVENT__HAVE_INTTYPES_H)
-CHECK_INCLUDE_FILE(memory.h EVENT__HAVE_MEMORY_H)
-CHECK_INCLUDE_FILE(poll.h EVENT__HAVE_POLL_H)
-CHECK_INCLUDE_FILE(port.h EVENT__HAVE_PORT_H)
-if(EVENT__HAVE_PORT_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES port.h)
-endif()
-CHECK_INCLUDE_FILE(signal.h EVENT__HAVE_SIGNAL_H)
-CHECK_INCLUDE_FILE(stdarg.h EVENT__HAVE_STDARG_H)
-CHECK_INCLUDE_FILE(stddef.h EVENT__HAVE_STDDEF_H)
-CHECK_INCLUDE_FILE(stdint.h EVENT__HAVE_STDINT_H)
-CHECK_INCLUDE_FILE(stdlib.h EVENT__HAVE_STDLIB_H)
-CHECK_INCLUDE_FILE(strings.h EVENT__HAVE_STRINGS_H)
-CHECK_INCLUDE_FILE(string.h EVENT__HAVE_STRING_H)
-CHECK_INCLUDE_FILE(sys/devpoll.h EVENT__HAVE_SYS_DEVPOLL_H)
-CHECK_INCLUDE_FILE(sys/epoll.h EVENT__HAVE_SYS_EPOLL_H)
-CHECK_INCLUDE_FILE(sys/eventfd.h EVENT__HAVE_SYS_EVENTFD_H)
-CHECK_INCLUDE_FILE(sys/event.h EVENT__HAVE_SYS_EVENT_H)
-CHECK_INCLUDE_FILE(sys/ioctl.h EVENT__HAVE_SYS_IOCTL_H)
-CHECK_INCLUDE_FILE(sys/mman.h EVENT__HAVE_SYS_MMAN_H)
-CHECK_INCLUDE_FILE(sys/param.h EVENT__HAVE_SYS_PARAM_H)
-CHECK_INCLUDE_FILE(sys/queue.h EVENT__HAVE_SYS_QUEUE_H)
-CHECK_INCLUDE_FILE(sys/select.h EVENT__HAVE_SYS_SELECT_H)
-CHECK_INCLUDE_FILE(sys/sendfile.h EVENT__HAVE_SYS_SENDFILE_H)
-CHECK_INCLUDE_FILE(sys/stat.h EVENT__HAVE_SYS_STAT_H)
-CHECK_INCLUDE_FILE(sys/time.h EVENT__HAVE_SYS_TIME_H)
-if(EVENT__HAVE_SYS_TIME_H)
-    list(APPEND CMAKE_EXTRA_INCLUDE_FILES sys/time.h)
-endif()
-CHECK_INCLUDE_FILE(sys/uio.h EVENT__HAVE_SYS_UIO_H)
-CHECK_INCLUDE_FILES("sys/types.h;ifaddrs.h" EVENT__HAVE_IFADDRS_H)
-CHECK_INCLUDE_FILE(mach/mach_time.h EVENT__HAVE_MACH_MACH_TIME_H)
-CHECK_INCLUDE_FILE(netinet/tcp.h EVENT__HAVE_NETINET_TCP_H)
-CHECK_INCLUDE_FILE(sys/wait.h EVENT__HAVE_SYS_WAIT_H)
-CHECK_INCLUDE_FILE(sys/resource.h EVENT__HAVE_SYS_RESOURCE_H)
-CHECK_INCLUDE_FILE(sys/sysctl.h EVENT__HAVE_SYS_SYSCTL_H)
-CHECK_INCLUDE_FILE(sys/timerfd.h EVENT__HAVE_SYS_TIMERFD_H)
-CHECK_INCLUDE_FILE(errno.h EVENT__HAVE_ERRNO_H)
-
-
-CHECK_FUNCTION_EXISTS_EX(epoll_create EVENT__HAVE_EPOLL)
-CHECK_FUNCTION_EXISTS_EX(epoll_ctl EVENT__HAVE_EPOLL_CTL)
-CHECK_FUNCTION_EXISTS_EX(eventfd EVENT__HAVE_EVENTFD)
-if(NOT EVENT__DISABLE_CLOCK_GETTIME)
-    CHECK_FUNCTION_EXISTS_EX(clock_gettime EVENT__HAVE_CLOCK_GETTIME)
-endif()
-CHECK_FUNCTION_EXISTS_EX(fcntl EVENT__HAVE_FCNTL)
-CHECK_FUNCTION_EXISTS_EX(getaddrinfo EVENT__HAVE_GETADDRINFO)
-CHECK_FUNCTION_EXISTS_EX(getnameinfo EVENT__HAVE_GETNAMEINFO)
-CHECK_FUNCTION_EXISTS_EX(gettimeofday EVENT__HAVE_GETTIMEOFDAY)
-CHECK_FUNCTION_EXISTS_EX(getprotobynumber EVENT__HAVE_GETPROTOBYNUMBER)
-CHECK_FUNCTION_EXISTS_EX(getservbyname EVENT__HAVE_GETSERVBYNAME)
-CHECK_FUNCTION_EXISTS_EX(inet_ntop EVENT__HAVE_INET_NTOP)
-CHECK_FUNCTION_EXISTS_EX(inet_pton EVENT__HAVE_INET_PTON)
-CHECK_FUNCTION_EXISTS_EX(kqueue EVENT__HAVE_KQUEUE)
-CHECK_FUNCTION_EXISTS_EX(mmap EVENT__HAVE_MMAP)
-CHECK_FUNCTION_EXISTS_EX(pipe EVENT__HAVE_PIPE)
-CHECK_FUNCTION_EXISTS_EX(pipe2 EVENT__HAVE_PIPE2)
-CHECK_FUNCTION_EXISTS_EX(poll EVENT__HAVE_POLL)
-CHECK_FUNCTION_EXISTS_EX(port_create EVENT__HAVE_PORT_CREATE)
-CHECK_FUNCTION_EXISTS_EX(sendfile EVENT__HAVE_SENDFILE)
-CHECK_FUNCTION_EXISTS_EX(sigaction EVENT__HAVE_SIGACTION)
-CHECK_FUNCTION_EXISTS_EX(signal EVENT__HAVE_SIGNAL)
-CHECK_FUNCTION_EXISTS_EX(splice EVENT__HAVE_SPLICE)
-CHECK_FUNCTION_EXISTS_EX(strlcpy EVENT__HAVE_STRLCPY)
-CHECK_FUNCTION_EXISTS_EX(strsep EVENT__HAVE_STRSEP)
-CHECK_FUNCTION_EXISTS_EX(strtok_r EVENT__HAVE_STRTOK_R)
-CHECK_FUNCTION_EXISTS_EX(strtoll EVENT__HAVE_STRTOLL)
-CHECK_FUNCTION_EXISTS_EX(vasprintf EVENT__HAVE_VASPRINTF)
-CHECK_FUNCTION_EXISTS_EX(sysctl EVENT__HAVE_SYSCTL)
-CHECK_FUNCTION_EXISTS_EX(accept4 EVENT__HAVE_ACCEPT4)
-CHECK_FUNCTION_EXISTS_EX(arc4random EVENT__HAVE_ARC4RANDOM)
-CHECK_FUNCTION_EXISTS_EX(arc4random_buf EVENT__HAVE_ARC4RANDOM_BUF)
-CHECK_FUNCTION_EXISTS_EX(epoll_create1 EVENT__HAVE_EPOLL_CREATE1)
-CHECK_FUNCTION_EXISTS_EX(getegid EVENT__HAVE_GETEGID)
-CHECK_FUNCTION_EXISTS_EX(geteuid EVENT__HAVE_GETEUID)
-CHECK_FUNCTION_EXISTS_EX(getifaddrs EVENT__HAVE_GETIFADDRS)
-CHECK_FUNCTION_EXISTS_EX(issetugid EVENT__HAVE_ISSETUGID)
-CHECK_FUNCTION_EXISTS_EX(mach_absolute_time EVENT__HAVE_MACH_ABSOLUTE_TIME)
-CHECK_FUNCTION_EXISTS_EX(nanosleep EVENT__HAVE_NANOSLEEP)
-CHECK_FUNCTION_EXISTS_EX(usleep EVENT__HAVE_USLEEP)
-CHECK_FUNCTION_EXISTS_EX(timeradd EVENT__HAVE_TIMERADD)
-CHECK_FUNCTION_EXISTS_EX(timerclear EVENT__HAVE_TIMERCLEAR)
-CHECK_FUNCTION_EXISTS_EX(timercmp EVENT__HAVE_TIMERCMP)
-CHECK_FUNCTION_EXISTS_EX(timerfd_create HAVE_TIMERFD_CREATE)
-CHECK_FUNCTION_EXISTS_EX(timerisset EVENT__HAVE_TIMERISSET)
-CHECK_FUNCTION_EXISTS_EX(putenv EVENT__HAVE_PUTENV)
-CHECK_FUNCTION_EXISTS_EX(setenv EVENT__HAVE_SETENV)
-CHECK_FUNCTION_EXISTS_EX(setrlimit EVENT__HAVE_SETRLIMIT)
-CHECK_FUNCTION_EXISTS_EX(umask EVENT__HAVE_UMASK)
-CHECK_FUNCTION_EXISTS_EX(unsetenv EVENT__HAVE_UNSETENV)
+    add_definitions(-D_GNU_SOURCE=1)
+    set(CMAKE_REQUIRED_DEFINITIONS -D_GNU_SOURCE)
+endif()
 
-# Get the gethostbyname_r prototype.
-CHECK_FUNCTION_EXISTS_EX(gethostbyname_r EVENT__HAVE_GETHOSTBYNAME_R)
+# Check if header files exist
+list(APPEND FILES_TO_CHECK
+    fcntl.h
+    inttypes.h
+    memory.h
+    signal.h
+    stdarg.h
+    stddef.h
+    stdint.h
+    stdlib.h
+    string.h
+    errno.h
+    unistd.h
+    time.h
+    sys/types.h
+    sys/stat.h
+    sys/time.h
+    sys/param.h
+)
+if (WIN32)
+    list(APPEND FILES_TO_CHECK
+        io.h
+        winsock2.h
+        ws2tcpip.h
+        afunix.h
+    )
+else()
+    list(APPEND FILES_TO_CHECK
+        netdb.h
+        dlfcn.h
+        arpa/inet.h
+        poll.h
+        port.h
+        sys/socket.h
+        sys/random.h
+        sys/un.h
+        sys/devpoll.h
+        sys/epoll.h
+        sys/eventfd.h
+        sys/event.h
+        sys/ioctl.h
+        sys/mman.h
+        sys/queue.h
+        sys/select.h
+        sys/sendfile.h
+        sys/uio.h
+        sys/wait.h
+        sys/resource.h
+        sys/timerfd.h
+        netinet/in.h
+        netinet/in6.h
+        netinet/tcp.h
+        ifaddrs.h
+    )
+endif()
+
+if (NOT "${CMAKE_HOST_SYSTEM_NAME}" STREQUAL "Linux")
+    list(APPEND FILES_TO_CHECK sys/sysctl.h)
+endif()
+
+if (APPLE)
+    list(APPEND FILES_TO_CHECK
+        mach/mach_time.h
+        mach/mach.h
+    )
+endif()
+
+foreach(FILE ${FILES_TO_CHECK})
+    CHECK_INCLUDE_FILE_CONCAT(${FILE} "EVENT")
+endforeach()
+unset(FILES_TO_CHECK)
+
+# Check if functions exist
+list(APPEND SYMBOLS_TO_CHECK
+    getaddrinfo
+    getnameinfo
+    getprotobynumber
+    getservbyname
+    gethostbyname
+    inet_ntop
+    inet_pton
+    gettimeofday
+    signal
+    strtoll
+    splice
+    strlcpy
+    strsep
+    strtok_r
+    vasprintf
+    timerclear
+    timercmp
+    timerisset
+    timeradd
+    nanosleep
+    putenv
+    umask
+)
+if (NOT EVENT__DISABLE_CLOCK_GETTIME)
+    list(APPEND SYMBOLS_TO_CHECK clock_gettime)
+endif()
+
+if (WIN32)
+    list(APPEND SYMBOLS_TO_CHECK
+        _gmtime64_s
+        _gmtime64
+    )
+else()
+    list(APPEND SYMBOLS_TO_CHECK
+        getifaddrs
+        select
+        epoll_create
+        epoll_create1
+        epoll_ctl
+        eventfd
+        poll
+        port_create
+        kqueue
+        fcntl
+        mmap
+        pipe
+        pipe2
+        sendfile
+        sigaction
+        strsignal
+        sysctl
+        accept4
+        arc4random
+        arc4random_buf
+        arc4random_addrandom
+        getrandom
+        getegid
+        geteuid
+        issetugid
+        usleep
+        timerfd_create
+        setenv
+        unsetenv
+        setrlimit
+        gethostbyname_r
+    )
+    if (APPLE)
+        list(APPEND SYMBOLS_TO_CHECK mach_absolute_time)
+    endif()
+endif()
+
+# Add stdio.h for vasprintf
+set(EVENT_INCLUDES ${EVENT_INCLUDES} stdio.h)
+CHECK_SYMBOLS_EXIST("${SYMBOLS_TO_CHECK}" "${EVENT_INCLUDES}" "EVENT")
+unset(SYMBOLS_TO_CHECK)
+set(EVENT__HAVE_EPOLL ${EVENT__HAVE_EPOLL_CREATE})
 
+# Get the gethostbyname_r prototype.
 if(EVENT__HAVE_GETHOSTBYNAME_R)
     CHECK_PROTOTYPE_DEFINITION(gethostbyname_r
         "int gethostbyname_r(const char *name, struct hostent *hp, struct hostent_data *hdata)"
@@ -376,10 +539,10 @@ if(HAVE_PORT_H AND HAVE_PORT_CREATE)
     set(EVENT__HAVE_EVENT_PORTS 1)
 endif()
 
-if(NOT WIN32)
-    CHECK_FUNCTION_EXISTS_EX(select EVENT__HAVE_SELECT)
-endif()
+# Only `CHECK_TYPE_SIZE()' will use `CMAKE_EXTRA_INCLUDE_FILES'
+set(CMAKE_EXTRA_INCLUDE_FILES ${EVENT_INCLUDES})
 
+CHECK_TYPE_SIZE("struct sockaddr_un" EVENT__HAVE_STRUCT_SOCKADDR_UN)
 CHECK_TYPE_SIZE("uint8_t" EVENT__HAVE_UINT8_T)
 CHECK_TYPE_SIZE("uint16_t" EVENT__HAVE_UINT16_T)
 CHECK_TYPE_SIZE("uint32_t" EVENT__HAVE_UINT32_T)
@@ -402,7 +565,7 @@ endif()
 check_function_keywords("inline" "__inline" "__inline__")
 
 if (HAVE_INLINE)
-    set (EVENT__inline inline)
+    set(EVENT__inline inline)
 elseif (HAVE___INLINE)
     set(EVENT__inline __inline)
 elseif(HAVE___INLINE__)
@@ -411,16 +574,18 @@ else()
     set(EVENT__inline)
 endif()
 
+# __func__/__FUNCTION__ is not a macros in general
+CHECK_SYMBOL_EXISTS("__func__"     "" EVENT__HAVE___func__)
+CHECK_SYMBOL_EXISTS("__FUNCTION__" "" EVENT__HAVE___FUNCTION__)
+
 CHECK_SYMBOL_EXISTS(TAILQ_FOREACH sys/queue.h EVENT__HAVE_TAILQFOREACH)
-CHECK_SYMBOL_EXISTS(CTL_KERN sys/sysctl.h EVENT__HAVE_DECL_CTL_KERN)
-CHECK_SYMBOL_EXISTS(KERN_ARND sys/sysctl.h EVENT__HAVE_DECL_KERN_ARND)
-CHECK_SYMBOL_EXISTS(KERN_RANDOM sys/sysctl.h EVENT__HAVE_DECL_KERN_RANDOM)
-CHECK_SYMBOL_EXISTS(RANDOM_UUID sys/sysctl.h EVENT__HAVE_DECL_RANDOM_UUID)
+CHECK_CONST_EXISTS(CTL_KERN sys/sysctl.h EVENT__HAVE_DECL_CTL_KERN)
+CHECK_CONST_EXISTS(KERN_ARND sys/sysctl.h EVENT__HAVE_DECL_KERN_ARND)
 CHECK_SYMBOL_EXISTS(F_SETFD fcntl.h EVENT__HAVE_SETFD)
 
 CHECK_TYPE_SIZE(fd_mask EVENT__HAVE_FD_MASK)
 
-CHECK_TYPE_SIZE(size_t EVENT__SIZEOF_SIZEE_T)
+CHECK_TYPE_SIZE(size_t EVENT__SIZEOF_SIZE_T)
 if(NOT EVENT__SIZEOF_SIZE_T)
   set(EVENT__size_t "unsigned")
   set(EVENT__SIZEOF_SIZE_T ${EVENT__SIZEOF_UNSIGNED})
@@ -451,7 +616,6 @@ else()
     set(EVENT__SIZEOF_SSIZE_T ${EVENT__SIZEOF_INT})
 endif()
 
-
 CHECK_TYPE_SIZE(socklen_t EVENT__SIZEOF_SOCKLEN_T)
 if(NOT EVENT__SIZEOF_SOCKLEN_T)
   set(EVENT__socklen_t "unsigned int")
@@ -462,14 +626,15 @@ endif()
 
 CHECK_TYPE_SIZE(pid_t EVENT__SIZEOF_PID_T)
 if(NOT EVENT__SIZEOF_PID_T)
-  set(EVENT__pid_t "int")
   set(EVENT__SIZEOF_PID_T ${EVENT__SIZEOF_INT})
 else()
-	set(EVENT__pid_t "pid_t")
 	set(EVENT__SIZEOF_PID_T EVENT__SIZEOF_PID_T)
 endif()
 
 if (NOT EVENT__DISABLE_THREAD_SUPPORT)
+    if (NOT WIN32)
+        list(APPEND CMAKE_EXTRA_INCLUDE_FILES pthread.h)
+    endif()
     CHECK_TYPE_SIZE(pthread_t EVENT__SIZEOF_PTHREAD_T)
 endif()
 
@@ -480,6 +645,7 @@ endif()
 # we're just getting lazy now.
 CHECK_TYPE_SIZE("uintptr_t" EVENT__HAVE_UINTPTR_T)
 CHECK_TYPE_SIZE("void *" EVENT__SIZEOF_VOID_P)
+CHECK_TYPE_SIZE("time_t" EVENT__SIZEOF_TIME_T)
 
 # Tests file offset bits.
 # TODO: Add AIX test for if -D_LARGE_FILES is needed.
@@ -490,13 +656,10 @@ CHECK_TYPE_SIZE("void *" EVENT__SIZEOF_VOID_P)
 #      - ellzey
 
 #CHECK_FILE_OFFSET_BITS()
-#set(EVENT___FILE_OFFSET_BITS _FILE_OFFSET_BITS)
-
-include(CheckWaitpidSupportWNOWAIT)
 
 # Verify kqueue works with pipes.
 if (EVENT__HAVE_KQUEUE)
-    if (CMAKE_CROSSCOMPILING AND NOT EVENT__FORCE_KQUEUE_CHECK)
+    if ((CMAKE_CROSSCOMPILING OR APPLE) AND NOT EVENT__FORCE_KQUEUE_CHECK)
         message(WARNING "Cannot check if kqueue works with pipes when crosscompiling, use EVENT__FORCE_KQUEUE_CHECK to be sure (this requires manually running a test program on the cross compilation target)")
         set(EVENT__HAVE_WORKING_KQUEUE 1)
     else()
@@ -505,10 +668,6 @@ if (EVENT__HAVE_KQUEUE)
     endif()
 endif()
 
-CHECK_SYMBOL_EXISTS(_MINIX "stdio.h" EVENT___MINIX)
-CHECK_SYMBOL_EXISTS(_POSIX_1_SOURCE "stdio.h" EVENT___POSIX_1_SOURCE)
-CHECK_SYMBOL_EXISTS(_POSIX_SOURCE "stdio.h" EVENT___POSIX_SOURCE)
-
 if(EVENT__HAVE_NETDB_H)
     list(APPEND CMAKE_EXTRA_INCLUDE_FILES netdb.h)
     CHECK_TYPE_SIZE("struct addrinfo" EVENT__HAVE_STRUCT_ADDRINFO)
@@ -578,6 +737,8 @@ if(EVENT__HAVE_STRUCT_SOCKADDR_STORAGE)
             __ss_family "${SOCKADDR_HEADERS}" EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY)
 endif()
 
+CHECK_TYPE_SIZE("struct linger" EVENT__HAVE_STRUCT_LINGER)
+
 # Group the source files.
 set(HDR_PRIVATE
     bufferevent-internal.h
@@ -672,7 +833,7 @@ if(EVENT__HAVE_DEVPOLL)
 endif()
 
 if(EVENT__HAVE_EPOLL)
-    list(APPEND SRC_CORE epoll_sub.c epoll.c)
+    list(APPEND SRC_CORE epoll.c)
 endif()
 
 if(EVENT__HAVE_EVENT_PORTS)
@@ -689,7 +850,7 @@ if (NOT EVENT__DISABLE_OPENSSL)
 
     include_directories(${OPENSSL_INCLUDE_DIR})
 
-    list(APPEND SRC_CORE bufferevent_openssl.c)
+    list(APPEND SRC_OPENSSL bufferevent_openssl.c)
     list(APPEND HDR_PUBLIC include/event2/bufferevent_ssl.h)
     list(APPEND LIB_APPS ${OPENSSL_LIBRARIES})
 endif()
@@ -701,11 +862,10 @@ if (NOT EVENT__DISABLE_THREAD_SUPPORT)
         find_package(Threads REQUIRED)
         if (NOT CMAKE_USE_PTHREADS_INIT)
             message(FATAL_ERROR
-                            "Failed to find Pthreads, set EVENT__DISABLE_THREAD_SUPPORT to disable")
+                    "Failed to find Pthreads, set EVENT__DISABLE_THREAD_SUPPORT to disable")
         endif()
 
         set(EVENT__HAVE_PTHREADS 1)
-        list(APPEND SRC_CORE evthread_pthread.c)
         list(APPEND LIB_APPS ${CMAKE_THREAD_LIBS_INIT})
     endif()
 endif()
@@ -746,7 +906,7 @@ if(WIN32)
     list(APPEND HDR_PRIVATE WIN32-Code/getopt.h)
 
     set(EVENT__DNS_USE_FTIME_FOR_ID 1)
-    set(LIB_PLATFORM ws2_32)
+    set(LIB_PLATFORM ws2_32 shell32 advapi32)
     add_definitions(
             -D_CRT_SECURE_NO_WARNINGS
             -D_CRT_NONSTDC_NO_DEPRECATE)
@@ -754,10 +914,6 @@ if(WIN32)
     include_directories(./WIN32-Code)
 endif()
 
-if (UNIX)
-    list(APPEND LIB_PLATFORM m)
-endif()
-
 if (SOLARIS)
     list(APPEND LIB_PLATFORM socket nsl)
 endif()
@@ -772,19 +928,11 @@ source_group("Source Extra"     FILES ${SRC_EXTRA})
 # (Place them in the build dir so we don't polute the source tree with generated files).
 include_directories(BEFORE ${CMAKE_CURRENT_BINARY_DIR}/include)
 
-if (EVENT__BUILD_SHARED_LIBRARIES)
-  set(EVENT__LIBRARY_TYPE SHARED)
-
-  if ((CMAKE_COMPILER_IS_GNUCC) OR (${CMAKE_C_COMPILER_ID} STREQUAL "Clang"))
-        add_compiler_flags(-fvisibility=hidden)
-  elseif ("${CMAKE_C_COMPILER_ID}" STREQUAL "SunPro")
-    add_compiler_flags(-xldscope=hidden)
-  endif()
-
-  set(EVENT__NEED_DLLIMPORT 1)
-else (EVENT__BUILD_SHARED_LIBRARIES)
-  set(EVENT__LIBRARY_TYPE STATIC)
-endif (EVENT__BUILD_SHARED_LIBRARIES)
+if (${GNUC})
+    set(EVENT_SHARED_FLAGS -fvisibility=hidden)
+elseif ("${CMAKE_C_COMPILER_ID}" STREQUAL "SunPro")
+    set(EVENT_SHARED_FLAGS -xldscope=hidden)
+endif()
 
 configure_file(
     ${CMAKE_CURRENT_SOURCE_DIR}/event-config.h.cmake
@@ -798,164 +946,149 @@ configure_file(
 #
 # Create the libraries.
 #
+include(AddEventLibrary)
+add_event_library(event_core SOURCES ${SRC_CORE})
+add_event_library(event_extra
+    INNER_LIBRARIES event_core
+    SOURCES ${SRC_EXTRA})
 
-# TODO: Add dynamic versions of the libraries as well.
-add_library(event_core ${EVENT__LIBRARY_TYPE}
-    ${HDR_PRIVATE}
-    ${HDR_COMPAT}
-    ${HDR_PUBLIC}
-    ${SRC_CORE})
+if (NOT EVENT__DISABLE_OPENSSL)
+    add_event_library(event_openssl
+        INNER_LIBRARIES event_core
+        OUTER_INCLUDES ${OPENSSL_INCLUDE_DIR}
+        LIBRARIES ${OPENSSL_LIBRARIES}
+        SOURCES ${SRC_OPENSSL})
+endif()
 
-add_library(event_extra ${EVENT__LIBRARY_TYPE}
-    ${HDR_PRIVATE}
-    ${HDR_COMPAT}
-    ${HDR_PUBLIC}
-    ${SRC_CORE}
-    ${SRC_EXTRA})
+if (EVENT__HAVE_PTHREADS)
+    set(SRC_PTHREADS evthread_pthread.c)
+    add_event_library(event_pthreads
+        INNER_LIBRARIES event_core
+        SOURCES ${SRC_PTHREADS})
+endif()
 
 # library exists for historical reasons; it contains the contents of
 # both libevent_core and libevent_extra. You shouldnt use it; it may
 # go away in a future version of Libevent.
-add_library(event ${EVENT__LIBRARY_TYPE}
-    ${HDR_PRIVATE}
-    ${HDR_COMPAT}
-    ${HDR_PUBLIC}
-    ${SRC_CORE}
-    ${SRC_EXTRA})
-
-if (EVENT__BUILD_SHARED_LIBRARIES)
-    # Prepare static library to be linked to tests that need hidden symbols
-    add_library(event_extra_static STATIC
-        ${HDR_PRIVATE}
-        ${HDR_COMPAT}
-        ${HDR_PUBLIC}
-        ${SRC_CORE}
-        ${SRC_EXTRA})
-
-    set(EVENT_EXTRA_FOR_TEST event_extra_static)
-
-   target_link_libraries(event_core ${OPENSSL_LIBRARIES}
-                                    ${CMAKE_THREAD_LIBS_INIT}
-                                    ${LIB_PLATFORM})
-
-   target_link_libraries(event ${OPENSSL_LIBRARIES}
-                               ${CMAKE_THREAD_LIBS_INIT}
-                               ${LIB_PLATFORM})
-
-   target_link_libraries(event_extra ${OPENSSL_LIBRARIES}
-                                      ${CMAKE_THREAD_LIBS_INIT}
-                                      ${LIB_PLATFORM})
-
-  set_target_properties(event
-        PROPERTIES SOVERSION
-            ${EVENT_ABI_LIBVERSION})
-
-  set_target_properties(event_core
-        PROPERTIES SOVERSION
-            ${EVENT_ABI_LIBVERSION})
-
-  set_target_properties(event_extra
-        PROPERTIES SOVERSION
-            ${EVENT_ABI_LIBVERSION})
-
-else (EVENT__BUILD_SHARED_LIBRARIES)
-    set(EVENT_EXTRA_FOR_TEST event_extra)
-endif (EVENT__BUILD_SHARED_LIBRARIES)
+add_event_library(event SOURCES ${SRC_CORE} ${SRC_EXTRA})
+
+set(WIN32_GETOPT)
+if (WIN32)
+    set(_TMPLIBS)
+    if (${EVENT_LIBRARY_STATIC})
+        list(APPEND _TMPLIBS event_core_static event_static)
+    endif()
+    if (${EVENT_LIBRARY_SHARED})
+        list(APPEND _TMPLIBS event_core_shared event_shared)
+    endif()
+    foreach(lib ${_TMPLIBS})
+        target_link_libraries(${lib} iphlpapi)
+    endforeach()
+    unset(_TMPLIBS)
+
+    list(APPEND WIN32_GETOPT
+         WIN32-Code/getopt.c
+         WIN32-Code/getopt_long.c)
+endif()
 
 #
 # Samples.
 #
-
+macro(add_sample_prog ssl name)
+    add_executable(${name} ${ARGN})
+
+    target_link_libraries(${name}
+                          event_extra
+                          event_core
+                          ${LIB_APPS}
+                          ${LIB_PLATFORM})
+
+    if (${ssl})
+        target_link_libraries(${name} event_openssl)
+        if(WIN32)
+            target_link_libraries(${name} crypt32)
+        endif()
+    endif()
+endmacro()
 if (NOT EVENT__DISABLE_SAMPLES)
     set(SAMPLES
-        dns-example
         event-read-fifo
         hello-world
         signal-test
-        http-server
         http-connect
         time-test)
 
-    if (NOT EVENT__DISABLE_OPENSSL AND OPENSSL_LIBRARIES)
-        set(CMAKE_REQUIRED_LIBRARIES ${OPENSSL_LIBRARIES})
-        CHECK_FUNCTION_EXISTS_EX(ERR_remove_thread_state EVENT__HAVE_ERR_REMOVE_THREAD_STATE)
-        set(CMAKE_REQUIRED_LIBRARIES "")
-
-        # Special sample with more than one file.
-        add_executable(https-client
-            sample/https-client.c
-            sample/openssl_hostname_validation.c
-            sample/hostcheck.c)
-
-        target_link_libraries(https-client
-                    event_extra
-                    ${LIB_APPS}
-                    ${LIB_PLATFORM})
-
-        add_dependencies(https-client event_extra)
-
-        # Requires OpenSSL.
-        list(APPEND SAMPLES le-proxy)
-    endif()
-
     foreach(SAMPLE ${SAMPLES})
-        add_executable(${SAMPLE}
-                    sample/${SAMPLE}.c)
-
-        target_link_libraries(${SAMPLE}
-                    event_extra
-                    ${LIB_APPS}
-                    ${LIB_PLATFORM})
-
-        add_dependencies(${SAMPLE} event_extra)
+        add_sample_prog(OFF ${SAMPLE} sample/${SAMPLE}.c)
     endforeach()
 
-    if (WIN32)
-        target_sources(dns-example PUBLIC
-                       WIN32-Code/getopt.c
-                       WIN32-Code/getopt_long.c)
+    if (NOT EVENT__DISABLE_OPENSSL)
+        add_sample_prog(ON https-client
+                        sample/https-client.c
+                        sample/openssl_hostname_validation.c
+                        sample/hostcheck.c)
+        add_sample_prog(ON le-proxy
+                        sample/le-proxy.c)
     endif()
+
+    set(SAMPLES_WOPT
+        dns-example
+        http-server
+    )
+    foreach (SAMPLE ${SAMPLES_WOPT})
+        add_sample_prog(OFF ${SAMPLE} sample/${SAMPLE}.c ${WIN32_GETOPT})
+    endforeach()
 endif()
 
+#
+# Benchmarks
+#
+macro(add_bench_prog prog)
+    add_executable(${prog} ${ARGN})
+    target_link_libraries(${prog}
+                          event_extra
+                          event_core
+                          ${LIB_APPS}
+                          ${LIB_PLATFORM})
+endmacro()
 if (NOT EVENT__DISABLE_BENCHMARK)
-    foreach (BENCHMARK bench bench_cascade bench_http bench_httpclient)
-        set(BENCH_SRC test/${BENCHMARK}.c)
-
-        if (WIN32)
-            list(APPEND BENCH_SRC
-                            WIN32-Code/getopt.c
-                            WIN32-Code/getopt_long.c)
-        endif()
-
-        add_executable(${BENCHMARK} ${BENCH_SRC})
-
-        target_link_libraries(${BENCHMARK}
-                    event_extra
-                    ${LIB_PLATFORM})
-
-        add_dependencies(${BENCHMARK} event_extra)
+    foreach (BENCHMARK bench_http bench_httpclient)
+        add_bench_prog(${BENCHMARK} test/${BENCHMARK}.c)
     endforeach()
+
+    add_bench_prog(bench test/bench.c ${WIN32_GETOPT})
+    add_bench_prog(bench_cascade test/bench_cascade.c ${WIN32_GETOPT})
 endif()
 
+#
+# Tests
+#
+macro(add_test_prog prog)
+    add_executable(${prog} test/${prog}.c)
+    target_link_libraries(${prog}
+                          ${LIB_APPS}
+                          ${LIB_PLATFORM}
+                          event_core
+                          event_extra
+                          ${ARGN})
+endmacro()
 if (NOT EVENT__DISABLE_TESTS)
     #
     # Generate Regress tests.
     #
     if (NOT EVENT__DISABLE_REGRESS)
+        # (We require python to generate the regress tests)
+        find_package(PythonInterp 3)
 
-        # (We require python2 to generate the regress tests)
-        foreach (PY python2.6 python2.7 python2)
-            unset(FIND_PYTHON2 CACHE)
-            find_program(FIND_PYTHON2 ${PY})
-            if (FIND_PYTHON2)
-                set(PYTHON_EXECUTABLE "${PY}")
-                break()
-            endif()
-        endforeach()
-        find_package(PythonInterp)
-
-        if (PYTHONINTERP_FOUND AND PYTHON_VERSION_STRING VERSION_LESS "3.0.0")
+        if (PYTHONINTERP_FOUND)
             set(__FOUND_USABLE_PYTHON 1)
+        else()
+            find_package(PythonInterp 2)
+            if (PYTHONINTERP_FOUND)
+                set(__FOUND_USABLE_PYTHON 1)
+            else()
+                message(ERROR "No suitable Python version found, bailing...")
+            endif()
         endif()
 
         if (__FOUND_USABLE_PYTHON)
@@ -970,38 +1103,34 @@ if (NOT EVENT__DISABLE_TESTS)
                 DEPENDS
                     event_rpcgen.py
                     test/regress.rpc
-                COMMAND ${PYTHON_EXECUTABLE} ../event_rpcgen.py regress.rpc
+                COMMAND ${PYTHON_EXECUTABLE} ../event_rpcgen.py --quiet regress.rpc
                 WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/test)
 
             list(APPEND SRC_REGRESS
-                test/regress.c
-                test/regress.gen.c
-                test/regress.gen.h
-                test/regress_buffer.c
-                test/regress_bufferevent.c
-                test/regress_dns.c
-                test/regress_et.c
-                test/regress_finalize.c
-                test/regress_http.c
-                test/regress_listener.c
-                test/regress_main.c
-                test/regress_minheap.c
-                test/regress_rpc.c
-                test/regress_testutils.c
-                test/regress_testutils.h
-                test/regress_util.c
-                test/tinytest.c
-                ${SRC_CORE}
-                ${SRC_EXTRA})
+                 test/regress.c
+                 test/regress.gen.c
+                 test/regress.gen.h
+                 test/regress_buffer.c
+                 test/regress_bufferevent.c
+                 test/regress_dns.c
+                 test/regress_et.c
+                 test/regress_finalize.c
+                 test/regress_http.c
+                 test/regress_listener.c
+                 test/regress_main.c
+                 test/regress_minheap.c
+                 test/regress_rpc.c
+                 test/regress_testutils.c
+                 test/regress_testutils.h
+                 test/regress_util.c
+                 test/tinytest.c)
 
             if (WIN32)
                 list(APPEND SRC_REGRESS test/regress_iocp.c)
                 if (NOT EVENT__DISABLE_THREAD_SUPPORT)
                     list(APPEND SRC_REGRESS test/regress_thread.c)
                 endif()
-            endif()
-
-            if (CMAKE_USE_PTHREADS_INIT)
+            elseif (EVENT__HAVE_PTHREADS)
                 list(APPEND SRC_REGRESS test/regress_thread.c)
             endif()
 
@@ -1009,23 +1138,23 @@ if (NOT EVENT__DISABLE_TESTS)
                 list(APPEND SRC_REGRESS test/regress_zlib.c)
             endif()
 
-            if (OPENSSL_LIBRARIES)
+            if (NOT EVENT__DISABLE_OPENSSL)
                 list(APPEND SRC_REGRESS test/regress_ssl.c)
             endif()
 
             add_executable(regress ${SRC_REGRESS})
 
-            # While building the test suite we don't want the visibility
-            # header trying to "dllimport" the symbols on windows (it
-            # generates a ton of warnings due to different link
-            # attributes for all of the symbols)
-            SET_TARGET_PROPERTIES(regress
-                            PROPERTIES COMPILE_DEFINITIONS
-              "EVENT_BUILDING_REGRESS_TEST=1")
-
             target_link_libraries(regress
-                            ${LIB_APPS}
-                            ${LIB_PLATFORM})
+                                  ${LIB_APPS}
+                                  ${LIB_PLATFORM}
+                                  event_core
+                                  event_extra)
+            if (NOT EVENT__DISABLE_OPENSSL)
+                target_link_libraries(regress event_openssl)
+            endif()
+            if (CMAKE_USE_PTHREADS_INIT)
+                target_link_libraries(regress event_pthreads)
+            endif()
         else()
             message(WARNING "No suitable Python interpreter found, cannot generate regress tests!")
         endif()
@@ -1034,44 +1163,42 @@ if (NOT EVENT__DISABLE_TESTS)
     #
     # Test programs.
     #
-        # all of these, including the cmakelists.txt should be moved
-        # into the dirctory 'tests' first.
-        #
-        # doing this, we can remove all the DISABLE_TESTS stuff, and simply
-        # do something like:
-        #
-        # add_custom_targets(tests)
-        # add_executable(... EXCLUDE_FROM_ALL ...c)
-        # add_dependencis(tests testa testb testc)
-        # add_test(....)
-        #
-        # then you can just run 'make tests' instead of them all
-        # auto-compile|running
-        # - ellzey
-    set(TESTPROGS   test-changelist
-                    test-eof
-                    test-fdleak
-                    test-init
-                    test-time
-                    test-weof)
+    # all of these, including the cmakelists.txt should be moved
+    # into the dirctory 'tests' first.
+    #
+    # doing this, we can remove all the DISABLE_TESTS stuff, and simply
+    # do something like:
+    #
+    # add_custom_targets(tests)
+    # add_executable(... EXCLUDE_FROM_ALL ...c)
+    # add_dependencis(tests testa testb testc)
+    # add_test(....)
+    #
+    # then you can just run 'make tests' instead of them all
+    # auto-compile|running
+    # - ellzey
+    set(TESTPROGS test-changelist
+                  test-eof
+                  test-closed
+                  test-fdleak
+                  test-init
+                  test-time
+                  test-weof)
+
+    foreach (TESTPROG ${TESTPROGS} test-dumpevents)
+        add_test_prog(${TESTPROG})
+    endforeach()
+    if (UNIX)
+        add_test_prog(test-ratelim m)
+    else()
+        add_test_prog(test-ratelim)
+    endif()
 
     set(ALL_TESTPROGS
-            ${TESTPROGS}
-            test-dumpevents
-            test-ratelim)
-
-    # Create test program executables.
-    foreach (TESTPROG ${ALL_TESTPROGS})
-        add_executable(${TESTPROG}
-                    test/${TESTPROG}.c)
-
-        target_link_libraries(${TESTPROG}
-                    ${EVENT_EXTRA_FOR_TEST}
-                    ${LIB_PLATFORM})
-
-        add_dependencies(${TESTPROG}
-                    ${EVENT_EXTRA_FOR_TEST})
-    endforeach()
+        ${TESTPROGS}
+        test-dumpevents
+        test-ratelim
+    )
 
     #
     # We run all tests with the different backends turned on one at a time.
@@ -1111,7 +1238,7 @@ if (NOT EVENT__DISABLE_TESTS)
 
     # Default environment variables turns off all event systems,
     # then we enable each one, one at a time when creating the tests.
-    set(DEFAULT_TEST_ENV_VARS "EVENT_SHOW_METHOD=1;")
+    set(DEFAULT_TEST_ENV_VARS)
     foreach(BACKEND ${BACKENDS})
         set(BACKEND_ENV_VAR "EVENT_NO${BACKEND}=1")
         list(APPEND DEFAULT_TEST_ENV_VARS "${BACKEND_ENV_VAR}")
@@ -1125,12 +1252,12 @@ if (NOT EVENT__DISABLE_TESTS)
             set(TEST_NAME ${TESTPROG}__${BACKEND_TEST_NAME})
 
             add_test(${TEST_NAME}
-                            ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${TESTPROG})
+                     ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/${TESTPROG})
 
             list(APPEND TEST_NAMES ${TEST_NAME})
 
             set_tests_properties(${TEST_NAME}
-                            PROPERTIES ENVIRONMENT "${ENV_VARS}")
+                                 PROPERTIES ENVIRONMENT "${ENV_VARS}")
         endforeach()
 
         # Dump events test.
@@ -1138,21 +1265,21 @@ if (NOT EVENT__DISABLE_TESTS)
             set(TEST_NAME test-dumpevents__${BACKEND_TEST_NAME})
 
             add_test(${TEST_NAME}
-                            ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/test-dumpevents |
-                            ${PYTHON_EXECUTABLE}
-                            ${CMAKE_CURRENT_SOURCE_DIR}/test/check-dumpevents.py)
+                     ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/test-dumpevents |
+                     ${PYTHON_EXECUTABLE}
+                     ${CMAKE_CURRENT_SOURCE_DIR}/test/check-dumpevents.py)
 
             set_tests_properties(${TEST_NAME}
-                            PROPERTIES ENVIRONMENT "${ENV_VARS}")
+                                 PROPERTIES ENVIRONMENT "${ENV_VARS}")
         else()
             message(WARNING "test-dumpevents will be run without output check since python was not found!")
             set(TEST_NAME test-dumpevents__${BACKEND_TEST_NAME}_no_check)
 
             add_test(${TEST_NAME}
-                            ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/test-dumpevents)
+                     ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/test-dumpevents)
 
             set_tests_properties(${TEST_NAME}
-                            PROPERTIES ENVIRONMENT "${ENV_VARS}")
+                                 PROPERTIES ENVIRONMENT "${ENV_VARS}")
         endif()
 
         # Regress tests.
@@ -1160,16 +1287,16 @@ if (NOT EVENT__DISABLE_TESTS)
             set(TEST_NAME regress__${BACKEND_TEST_NAME})
 
             add_test(${TEST_NAME}
-                            ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/regress)
+                     ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/regress --quiet)
 
             set_tests_properties(${TEST_NAME}
-                            PROPERTIES ENVIRONMENT "${ENV_VARS}")
+                                 PROPERTIES ENVIRONMENT "${ENV_VARS}")
 
             add_test(${TEST_NAME}_debug
-                            ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/regress)
+                     ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/regress --quiet)
 
             set_tests_properties(${TEST_NAME}_debug
-                            PROPERTIES ENVIRONMENT "${ENV_VARS};EVENT_DEBUG_MODE=1")
+                                 PROPERTIES ENVIRONMENT "${ENV_VARS};EVENT_DEBUG_MODE=1")
         endif()
     endmacro()
 
@@ -1199,47 +1326,47 @@ if (NOT EVENT__DISABLE_TESTS)
     #
 
     # Group limits, no connection limit.
-        set(RL_BIN  ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/test-ratelim)
+    set(RL_BIN ${CMAKE_RUNTIME_OUTPUT_DIRECTORY}/test-ratelim)
 
     add_test(test-ratelim__group_lim
-                ${RL_BIN}
-                -g 30000
-                -n 30
-                -t 100
-                --check-grouplimit 1000
-                --check-stddev 100)
+             ${RL_BIN}
+             -g 30000
+             -n 30
+             -t 100
+             --check-grouplimit 1000
+             --check-stddev 100)
 
     # Connection limit, no group limit.
     add_test(test-ratelim__con_lim
-                ${RL_BIN}
-                -c 1000
-                -n 30
-                -t 100
-                --check-connlimit 50
-                --check-stddev 50)
+             ${RL_BIN}
+             -c 1000
+             -n 30
+             -t 100
+             --check-connlimit 50
+             --check-stddev 50)
 
     # Connection limit and group limit.
     add_test(test-ratelim__group_con_lim
-                ${RL_BIN}
-                -c 1000
-                -g 30000
-                -n 30
-                -t 100
-                --check-grouplimit 1000
-                --check-connlimit 50
-                --check-stddev 50)
+             ${RL_BIN}
+             -c 1000
+             -g 30000
+             -n 30
+             -t 100
+             --check-grouplimit 1000
+             --check-connlimit 50
+             --check-stddev 50)
 
     # Connection limit and group limit with independent drain.
     add_test(test-ratelim__group_con_lim_drain
-                ${RL_BIN}
-                -c 1000
-                -g 35000
-                -n 30
-                -t 100
-                -G 500
-                --check-grouplimit 1000
-                --check-connlimit 50
-                --check-stddev 50)
+             ${RL_BIN}
+             -c 1000
+             -g 35000
+             -n 30
+             -t 100
+             -G 500
+             --check-grouplimit 1000
+             --check-connlimit 50
+             --check-stddev 50)
 
     # Add a "make verify" target, same as for autoconf.
     # (Important! This will unset all EVENT_NO* environment variables.
@@ -1259,21 +1386,20 @@ if (NOT EVENT__DISABLE_TESTS)
         message(STATUS "${WINDOWS_CTEST_COMMAND}")
 
         file(COPY ${CMAKE_CURRENT_BINARY_DIR}/tmp/verify_tests.bat
-            DESTINATION
-                            ${CMAKE_CURRENT_BINARY_DIR}
-            FILE_PERMISSIONS
-                            OWNER_READ
-                            OWNER_WRITE
-                            OWNER_EXECUTE
-                            GROUP_READ
-                            GROUP_EXECUTE
-                            WORLD_READ WORLD_EXECUTE)
+             DESTINATION ${CMAKE_CURRENT_BINARY_DIR}
+             FILE_PERMISSIONS
+                             OWNER_READ
+                             OWNER_WRITE
+                             OWNER_EXECUTE
+                             GROUP_READ
+                             GROUP_EXECUTE
+                             WORLD_READ WORLD_EXECUTE)
 
         file(TO_NATIVE_PATH
                     "${CMAKE_CURRENT_BINARY_DIR}/verify_tests.bat" VERIFY_PATH)
 
         add_custom_target(verify COMMAND "${VERIFY_PATH}"
-                        DEPENDS event ${ALL_TESTPROGS})
+                          DEPENDS event ${ALL_TESTPROGS})
     else()
         # On some platforms doing exec(unset) as CMake does won't work, so make sure
         # we run the unset command in a shell instead.
@@ -1287,23 +1413,20 @@ if (NOT EVENT__DISABLE_TESTS)
 
         # Then we copy the file (this allows us to set execute permission on it)
         file(COPY ${CMAKE_CURRENT_BINARY_DIR}/tmp/verify_tests.sh
-            DESTINATION ${CMAKE_CURRENT_BINARY_DIR}
-            FILE_PERMISSIONS
-                            OWNER_READ
-                            OWNER_WRITE
-                            OWNER_EXECUTE
-                            GROUP_READ
-                            GROUP_EXECUTE
-                            WORLD_READ
-                            WORLD_EXECUTE)
+             DESTINATION ${CMAKE_CURRENT_BINARY_DIR}
+             FILE_PERMISSIONS
+                             OWNER_READ
+                             OWNER_WRITE
+                             OWNER_EXECUTE
+                             GROUP_READ
+                             GROUP_EXECUTE
+                             WORLD_READ
+                             WORLD_EXECUTE)
 
         # Create the target that runs the script.
         add_custom_target(verify
-                    COMMAND
-                        ${CMAKE_CURRENT_BINARY_DIR}/verify_tests.sh
-          DEPENDS
-                        event
-                        ${ALL_TESTPROGS})
+                          COMMAND ${CMAKE_CURRENT_BINARY_DIR}/verify_tests.sh
+                          DEPENDS event ${ALL_TESTPROGS})
     endif()
 
     if (NOT EVENT__DISABLE_REGRESS AND __FOUND_USABLE_PYTHON)
@@ -1329,31 +1452,23 @@ endif()
 # Installation preparation.
 #
 
-# Allow the user to override installation directories.
-set(EVENT_INSTALL_LIB_DIR       lib CACHE PATH "Installation directory for libraries")
-set(EVENT_INSTALL_BIN_DIR       bin CACHE PATH "Installation directory for executables")
-set(EVENT_INSTALL_INCLUDE_DIR   include CACHE PATH "Installation directory for header files")
+set(EVENT_INSTALL_CMAKE_DIR
+    "${CMAKE_INSTALL_PREFIX}/lib/cmake/libevent")
 
-if(WIN32 AND NOT CYGWIN)
-  set(DEF_INSTALL_CMAKE_DIR cmake)
-else()
-  set(DEF_INSTALL_CMAKE_DIR lib/cmake/libevent)
-endif()
-
-set(EVENT_INSTALL_CMAKE_DIR ${DEF_INSTALL_CMAKE_DIR} CACHE PATH "Installation directory for CMake files")
+export(PACKAGE libevent)
 
-# Make sure the paths are absolute.
-foreach(p LIB BIN INCLUDE CMAKE)
-    set(var EVENT_INSTALL_${p}_DIR)
-    if(NOT IS_ABSOLUTE "${${var}}")
-        set(${var} "${CMAKE_INSTALL_PREFIX}/${${var}}")
+function(gen_package_config forinstall)
+    if(${forinstall})
+        set(CONFIG_FOR_INSTALL_TREE 1)
+        set(dir "${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}")
+    else()
+        set(CONFIG_FOR_INSTALL_TREE 0)
+        set(dir "${PROJECT_BINARY_DIR}")
     endif()
-endforeach()
-
-# Export targets (This is used for other CMake projects to easily find the libraries and include files).
-export(TARGETS event event_extra event_core
-        FILE "${PROJECT_BINARY_DIR}/LibeventTargets.cmake")
-export(PACKAGE libevent)
+    configure_file(${PROJECT_SOURCE_DIR}/cmake/LibeventConfig.cmake.in
+                "${dir}/LibeventConfig.cmake"
+                @ONLY)
+endfunction()
 
 # Generate the config file for the build-tree.
 set(EVENT__INCLUDE_DIRS
@@ -1364,95 +1479,97 @@ set(LIBEVENT_INCLUDE_DIRS
     ${EVENT__INCLUDE_DIRS}
     CACHE PATH "Libevent include directories")
 
-configure_file(${PROJECT_SOURCE_DIR}/cmake/LibeventConfigBuildTree.cmake.in
-                ${PROJECT_BINARY_DIR}/LibeventConfig.cmake
-                @ONLY)
+gen_package_config(0)
 
 # Generate the config file for the installation tree.
-file(RELATIVE_PATH
-    REL_INCLUDE_DIR
-    "${EVENT_INSTALL_CMAKE_DIR}"
-    "${EVENT_INSTALL_INCLUDE_DIR}") # Calculate the relative directory from the Cmake dir.
-
-# Note the EVENT_CMAKE_DIR is defined in LibeventConfig.cmake.in,
-# we escape it here so it's evaluated when it is included instead
-# so that the include dirs are givenrelative to where the
-# config file is located.
-set(EVENT__INCLUDE_DIRS
-    "\${EVENT_CMAKE_DIR}/${REL_INCLUDE_DIR}")
-
-configure_file(${PROJECT_SOURCE_DIR}/cmake/LibeventConfig.cmake.in
-                ${PROJECT_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/LibeventConfig.cmake
-                @ONLY)
+gen_package_config(1)
 
 # Generate version info for both build-tree and install-tree.
 configure_file(${PROJECT_SOURCE_DIR}/cmake/LibeventConfigVersion.cmake.in
-                ${PROJECT_BINARY_DIR}/LibeventConfigVersion.cmake
-                @ONLY)
-
-# Define the public headers.
-set_target_properties(event event_core event_extra
-    PROPERTIES PUBLIC_HEADER "${HDR_PUBLIC}")
-
-#
-# Install targets.
-#
-install(TARGETS event event_core event_extra
-        EXPORT LibeventTargets
-        RUNTIME DESTINATION "${EVENT_INSTALL_BIN_DIR}" COMPONENT bin
-        LIBRARY DESTINATION "${EVENT_INSTALL_LIB_DIR}" COMPONENT lib
-        ARCHIVE DESTINATION "${EVENT_INSTALL_LIB_DIR}" COMPONENT lib
-        PUBLIC_HEADER DESTINATION "${EVENT_INSTALL_INCLUDE_DIR}/event2" COMPONENT dev)
+               ${PROJECT_BINARY_DIR}/LibeventConfigVersion.cmake
+               @ONLY)
 
 # Install compat headers
 install(FILES ${HDR_COMPAT}
-    DESTINATION
-            "${EVENT_INSTALL_INCLUDE_DIR}"
-    COMPONENT dev)
+        DESTINATION "include"
+        COMPONENT dev)
+
+# Install public headers
+install(FILES ${HDR_PUBLIC}
+        DESTINATION "include/event2"
+        COMPONENT dev)
 
 # Install the configs.
 install(FILES
-    ${PROJECT_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/LibeventConfig.cmake
-    ${PROJECT_BINARY_DIR}/LibeventConfigVersion.cmake
-    DESTINATION
-            "${EVENT_INSTALL_CMAKE_DIR}"
+        ${PROJECT_BINARY_DIR}/${CMAKE_FILES_DIRECTORY}/LibeventConfig.cmake
+        ${PROJECT_BINARY_DIR}/LibeventConfigVersion.cmake
+        DESTINATION "${EVENT_INSTALL_CMAKE_DIR}"
         COMPONENT dev)
 
 # Install exports for the install-tree.
-install(EXPORT LibeventTargets
-        DESTINATION
-                    "${EVENT_INSTALL_CMAKE_DIR}"
-                COMPONENT dev)
+macro(install_export type)
+    install(EXPORT LibeventTargets-${type}
+        NAMESPACE ${PROJECT_NAME}::
+        DESTINATION "${EVENT_INSTALL_CMAKE_DIR}"
+        COMPONENT dev)
+endmacro()
+
+if (${EVENT_LIBRARY_STATIC})
+    install_export(static)
+endif()
+if (${EVENT_LIBRARY_SHARED})
+    install_export(shared)
+endif()
 
-set(LIBEVENT_LIBRARIES
-        event
-        event_core
-        event_extra
-        CACHE STRING "Libevent libraries")
+# Install the scripts.
+install(PROGRAMS
+       ${CMAKE_CURRENT_SOURCE_DIR}/event_rpcgen.py
+       DESTINATION "bin"
+       COMPONENT runtime)
+
+# Create documents with doxygen.
+option(EVENT__DOXYGEN
+    "Enables doxygen documentation" OFF)
+if (EVENT__DOXYGEN)
+    include(UseDoxygen)
+    UseDoxygen()
+endif()
+
+
+if (NOT TARGET uninstall)
+	# Create the uninstall target.
+	# https://gitlab.kitware.com/cmake/community/wikis/FAQ#can-i-do-make-uninstall-with-cmake
+	configure_file(${PROJECT_SOURCE_DIR}/cmake/Uninstall.cmake.in
+				   ${PROJECT_BINARY_DIR}/Uninstall.cmake
+				   @ONLY)
+
+	add_custom_target(uninstall
+					  COMMAND ${CMAKE_COMMAND} -P ${PROJECT_BINARY_DIR}/Uninstall.cmake)
+endif()
 
 message(STATUS "")
 message(STATUS "        ---( Libevent " ${EVENT_VERSION} " )---")
 message(STATUS "")
 message(STATUS "Available event backends: ${BACKENDS}")
-message(STATUS "CMAKE_BINARY_DIR:         " ${CMAKE_BINARY_DIR})
-message(STATUS "CMAKE_CURRENT_BINARY_DIR: " ${CMAKE_CURRENT_BINARY_DIR})
-message(STATUS "CMAKE_SOURCE_DIR:         " ${CMAKE_SOURCE_DIR})
-message(STATUS "CMAKE_CURRENT_SOURCE_DIR: " ${CMAKE_CURRENT_SOURCE_DIR})
-message(STATUS "PROJECT_BINARY_DIR:       " ${PROJECT_BINARY_DIR})
-message(STATUS "PROJECT_SOURCE_DIR:       " ${PROJECT_SOURCE_DIR})
-message(STATUS "CMAKE_MODULE_PATH:        " ${CMAKE_MODULE_PATH})
-message(STATUS "CMAKE_COMMAND:            " ${CMAKE_COMMAND})
-message(STATUS "CMAKE_ROOT:               " ${CMAKE_ROOT} )
-message(STATUS "CMAKE_SYSTEM:             " ${CMAKE_SYSTEM} )
-message(STATUS "CMAKE_SYSTEM_NAME:        " ${CMAKE_SYSTEM_NAME} )
-message(STATUS "CMAKE_SYSTEM_VERSION:     " ${CMAKE_SYSTEM_VERSION} )
-message(STATUS "CMAKE_SYSTEM_PROCESSOR:   " ${CMAKE_SYSTEM_PROCESSOR} )
-message(STATUS "CMAKE_SKIP_RPATH:         " ${CMAKE_SKIP_RPATH} )
-message(STATUS "CMAKE_VERBOSE_MAKEFILE:   " ${CMAKE_VERBOSE_MAKEFILE} )
-message(STATUS "CMAKE_C_FLAGS:            " ${CMAKE_C_FLAGS} )
-message(STATUS "CMAKE_BUILD_TYPE:         " ${CMAKE_BUILD_TYPE} )
-message(STATUS "CMAKE_C_COMPILER:         " ${CMAKE_C_COMPILER} )
-message(STATUS "CMAKE_AR:                 " ${CMAKE_AR} )
-message(STATUS "CMAKE_RANLIB:             " ${CMAKE_RANLIB} )
+message(STATUS "CMAKE_BINARY_DIR:         ${CMAKE_BINARY_DIR}")
+message(STATUS "CMAKE_CURRENT_BINARY_DIR: ${CMAKE_CURRENT_BINARY_DIR}")
+message(STATUS "CMAKE_SOURCE_DIR:         ${CMAKE_SOURCE_DIR}")
+message(STATUS "CMAKE_CURRENT_SOURCE_DIR: ${CMAKE_CURRENT_SOURCE_DIR}")
+message(STATUS "PROJECT_BINARY_DIR:       ${PROJECT_BINARY_DIR}")
+message(STATUS "PROJECT_SOURCE_DIR:       ${PROJECT_SOURCE_DIR}")
+message(STATUS "CMAKE_MODULE_PATH:        ${CMAKE_MODULE_PATH}")
+message(STATUS "CMAKE_COMMAND:            ${CMAKE_COMMAND}")
+message(STATUS "CMAKE_ROOT:               ${CMAKE_ROOT}")
+message(STATUS "CMAKE_SYSTEM:             ${CMAKE_SYSTEM}")
+message(STATUS "CMAKE_SYSTEM_NAME:        ${CMAKE_SYSTEM_NAME}")
+message(STATUS "CMAKE_SYSTEM_VERSION:     ${CMAKE_SYSTEM_VERSION}")
+message(STATUS "CMAKE_SYSTEM_PROCESSOR:   ${CMAKE_SYSTEM_PROCESSOR}")
+message(STATUS "CMAKE_SKIP_RPATH:         ${CMAKE_SKIP_RPATH}")
+message(STATUS "CMAKE_VERBOSE_MAKEFILE:   ${CMAKE_VERBOSE_MAKEFILE}")
+message(STATUS "CMAKE_C_FLAGS:            ${CMAKE_C_FLAGS}")
+message(STATUS "CMAKE_BUILD_TYPE:         ${CMAKE_BUILD_TYPE}")
+message(STATUS "CMAKE_C_COMPILER:         ${CMAKE_C_COMPILER} (id ${CMAKE_C_COMPILER_ID}, clang ${CLANG}, GNUC ${GNUC})")
+message(STATUS "CMAKE_AR:                 ${CMAKE_AR}")
+message(STATUS "CMAKE_RANLIB:             ${CMAKE_RANLIB}")
 message(STATUS "")
 
diff --git a/ipc/chromium/src/third_party/libevent/ChangeLog b/ipc/chromium/src/third_party/libevent/ChangeLog
index 740bdfccbd7d..17874b14b92b 100644
--- a/ipc/chromium/src/third_party/libevent/ChangeLog
+++ b/ipc/chromium/src/third_party/libevent/ChangeLog
@@ -1,3 +1,316 @@
+Changes in version 2.1.12-stable (05 Jul 2020)
+
+ This release contains mostly bug fixes (I decided not to port some features
+ that can be ported even without ABI breakage, if you cannot find feature that
+ you are interested in, please give us a note!)
+
+ Since 2.1.12 libevent will use github actions as main CI, since
+ it recommends itself better then travis/appveyor (and had been removed from
+ upstream).
+
+ Look carefully at "slightly touches the behaviour" section.
+
+ Below you will find some of changes (this list has been cleaned up from the
+ patches that touches only tests and similar):
+
+ CI:
+  o Backport github actions to 2.1 (be3acd7c Azat Khuzhin)
+  o Merge branch 'event_rpcgen.py-cleanup' (f0ded5f3, 48e04887 Enji Cooper)
+  o Add API/ABI checker (using LVC) (709210d4, 2af1f6cc yuangongji)
+
+ test:
+  o tinytest: support timeout on Windows (794e8f75 yuangongji)
+  o Merge branch 'osx-clock' (e85afbe3 Azat Khuzhin)
+  o test-ratelim: calculate timers bias (for slow CPUs) to avoid false-positive (8ad26d0b Azat Khuzhin)
+
+ fixes:
+  o buffer: do not pass NULL to memcpy() from evbuffer_pullup() (5b063049 Azat Khuzhin)
+  o http: fix undefined-shift in EVUTIL_IS*_ helpers (6b8d02a7 Azat Khuzhin)
+  o Check error code of evhttp_add_header_internal() in evhttp_parse_query_impl() (97e28f09 Azat Khuzhin)
+  o http: fix EVHTTP_CON_AUTOFREE in case of timeout (and some else) (1be25938 Azat Khuzhin)
+  o evdns: Add additional validation for values of dns options (c2972453 ayuseleznev)
+  o There is typo in GetAdaptersAddresses windows library. It should be iphlpapi.dll (891adda9 Aleksandr-Melnikov)
+  o Merge branch 'EV_CLOSED-and-EV_ET-fixes' (db2efdf5 Azat Khuzhin)
+  o Fix memory corruption in EV_CLOSURE_EVENT_FINALIZE with debug enabled (8ccd8f56 Jan Kasiak)
+  o increase segment refcnt only if evbuffer_add_file_segment() succeeds (30662a3c yuangongji)
+  o evdns: fix a crash when evdns_base with waiting requests is freed (6f8e0e97 ayuseleznev)
+  o event_base_once: fix potential null pointer threat (2e9ceb16 chenguolong)
+  o http: do not assume body for CONNECT (1b42270b Azat Khuzhin)
+  o evbuffer_add_file: fix freeing of segment in the error path (5f017bde Azat Khuzhin)
+  o Fix checking return value of the evdns_base_resolv_conf_parse() (fc51bf2c Azat Khuzhin)
+  o Merge branch 'fix-signal-leak' (poll/select now needs reinit) (1c9cc07b Azat Khuzhin)
+
+ improvements:
+  o evutil_time: improve evutil_gettimeofday on Windows (a8219143 Nick Grifka)
+  o Support EV_CLOSED on linux for poll(2) (2530e7c6 Azat Khuzhin)
+  o Parse IPv6 scope IDs. (f602211f Philip Homburg)
+  o evutil_time: Implements usleep() using wait funtion on Windows (d42240d1 yuangongji)
+  o evutil_time: detect and use _gmtime64_s()/_gmtime64() (f4a6152c yuangongji)
+
+ slightly touches the behaviour:
+  o bufferevent: allow setting priority on socket and openssl type (4dd3acdd Nicolas J. Bouliane)
+  o Fix EV_CLOSED detection/reporting (epoll only) (1df324d4 Azat Khuzhin) (XXX)
+  o Revert "Warn if forked from the event loop during event_reinit()" (71f5c0d3 Azat Khuzhin)
+
+ samples:
+  o https-client: load certificates from the system cert store on Windows (e9478640 yuangongji)
+
+ build fixes:
+  o Do not use sysctl.h on linux (it had been deprecated) (d2871a37 Azat Khuzhin)
+  o cmake: avoid problems from use of CMAKE_USE_PTHREADS_INIT (a62ec765 Paul Osborne)
+  o Update list of cmake files for autotools dist archive (2016f017 Azat Khuzhin)
+  o LibeventConfig.cmake: restore CMAKE_FIND_LIBRARY_SUFFIXES and LIBEVENT_STATIC_LINK default (640f9cf6 Mario Emmenlauer)
+  o cmake: fix getaddrinfo checking error (dea51c2e yuangongji)
+  o autoconf: fix getaddrinfo checking errors on mingw (b9bf7fa7 yuangongji)
+  o Do not use shared global structures on CYGWIN (8a9b5655 Azat Khuzhin)
+  o Added uninstall target check to cmakelists (3f1fb1f9 Dimo Markov)
+  o Fix compilation without OPENSSL_API_COMPAT (921bdcdd Azat Khuzhin)
+  o cmake: improve package config file (1c047618, baec84f2 yuangongji)
+  o Link with iphlpapi only on windows (976f7d34 Azat Khuzhin)
+  o autotools: fails build when need but can not find openssl (93174bb5 yuangongji)
+  o Merge branch 'http-connect' (e2424229 Azat Khuzhin)
+  o Fix compat with NetBSD >= 10 (5febb4e1 Kamil Rytarowski)
+  o cmake: fix getrandom() detection (e0e5f3bd Azat Khuzhin)
+  o arc4random: replace sysctl() with getrandom (on linux) (66ec78fd Azat Khuzhin)
+  o Upgrade autoconf (after upgrading minimum required to 2.67) (45da7d9d yuangongji)
+  o eliminate some C4267 warnings in Windows (9e468c77 yuangongji)
+  o autotools: attach doxygen target into all target (5d1e8570 yuangongji)
+  o cmake: attach doxygen target into all target (7a85300a yuangongji)
+  o Change the minimum version of automake to 1.13 and autoconf to 2.67 (fdb8fb66 ygj6)
+  o Add Uninstall.cmake.in into dist archive (877f2355 Azat Khuzhin)
+
+Changes in version 2.1.11-stable (01 Aug 2019)
+
+ This release contains one ABI breakage fix (that had been introduced in
+ 2.1.10, and strictly speaking this release breaks ABI again to make it
+ compatible with 2.1.9 and less, please take a look at 18104973 for more
+ details). Apart from that it contains some bug fixes, that grouped below.
+
+ And even though the return value for evbuffer_setcb() had been changed it
+ should ABI compatible (anyway that function is in -compat.h header).
+
+ There is also one patch that introduce new functionality, this is 546a366c,
+ to tune SO_RCVBUF/SO_SNDBUF in evdns, but one can count it as a bug-fix on
+ the application level, since before you cannot tune this settings and hence
+ you could stumble on problems.
+
+ ABI breakage:
+  o Protect min_heap_push_ against integer overflow. (8c899768 Tobias Stoeckmann)
+  o Revert "Protect min_heap_push_ against integer overflow." (18104973 Azat Khuzhin)
+
+ functionality:
+  o evdns: add new options -- so-rcvbuf/so-sndbuf (546a366c Azat Khuzhin)
+
+ build:
+  o Change autoconf version to 2.62 and automake version to 1.11.2 (2a333008 yuangongji)
+  o cmake: install shared library only if it was requested (596855f7 Azat Khuzhin)
+  o Missing <winerror.h> on win7/MinGW(MINGW32_NT-6.1)/MSYS (9559349c yuangongji)
+  o cmake: set library names to be the same as with autotools (305251b9 yuangongji)
+  o Enable _GNU_SOURCE for Android (f013fc7d Keith Smiley)
+  o Enable kqueue for APPLE targets (3aa68a82 Keith Smiley)
+  o autotools: do not install bufferevent_ssl.h under --disable-openssl (5349a07e Azat Khuzhin)
+  o cmake: link against shell32.lib/advapi32.lib (c9ce638c Azat Khuzhin)
+  o Add README.md into dist archive (3660a4cc Azat Khuzhin)
+  o cmake: add missing autotools targets (doxygen, uninstall, event_rpcgen.py) (2d65071c yuangongji)
+  o m4/libevent_openssl.m4: fix detection of openssl (d4056e59 Fabrice Fontaine)
+  o Fix detection of the __has_attribute() for apple clang [ci skip] (7fd7c5ef Azat Khuzhin)
+
+ lib:
+  o buffer: fix possible NULL dereference in evbuffer_setcb() on ENOMEM (598f247d Azat Khuzhin)
+  o Warn if forked from the event loop during event_reinit() (b75922ae Azat Khuzhin)
+  o evutil: set the have_checked_interfaces in evutil_check_interfaces()
+    (ef498aa2, a09265ac jeremyerb)
+
+ samples:
+  o https-client: correction error checking (a8a04565 wenyg)
+
+
+Changes in version 2.1.10-stable (26 May 2019)
+
+ This release contains mostly fixes (some evbuffer oddity, AF_UNIX handling in
+ http server, some UB fixes and others) but also some new functionality
+ (without ABI breakage as usual) and now dist archive can be used for building
+ on windows (getopt had been added into it).
+
+ Above you will find changelog for this particular release (but with some
+ trivial fixes pruned out from it - to make it a little bit more informative).
+
+ To view full changelog please use git:
+   git log --format='  o %s (%h %aN)' release-2.1.9-beta...release-2.1.10-stable
+
+ dist:
+  o Add getopt into dist archive (7042ff24 Azat Khuzhin)
+
+ functionality:
+  o evdns: add DNS_OPTION_NAMESERVERS_NO_DEFAULT/EVDNS_BASE_NAMESERVERS_NO_DEFAULT
+  (58e81106 Azat Khuzhin)
+  o Add support for EV_TIMEOUT to event_base_active_by_fd (3f893f0a John Ohl)
+
+ fixes:
+  o Merge branch 'evbuffer-fixes-806-v2' (2fea04b3 Azat Khuzhin)
+  o Merge branch 'issue-807-accept4-getnameinfo-AF_UNIX' (7c4da937, e2790a7f
+    Azat Khuzhin)
+  o kqueue: Avoid undefined behaviour. (e70e18e9 Tobias Stoeckmann)
+  o Prevent integer overflow in kq_build_changes_list. (43a55a23 Tobias Stoeckmann)
+  o evdns: fix lock/unlock mismatch in evdns_close_server_port() (54103883 zhuizhuhaomeng)
+  o Merge remote-tracking branch 'official/pr/804' -- Enforce limit of NSIG
+    signals (87fa93a8 Tobias Stoeckmann)
+  o Protect min_heap_push_ against integer overflow. (0b46bb8c Tobias Stoeckmann)
+  o le-proxy: initiate use of the Winsock DLL (2a1e1530 linxiaohui)
+  o Fix leaks in error path of the bufferevent_init_common_() (bb0f8fe7 Azat Khuzhin)
+  o buffer: make evbuffer_prepend() of zero-length array no-op (61fa7b7d Azat Khuzhin)
+  o Merge branch 'evbuffer-empty-chain-handling' (6a3dd717 Azat Khuzhin)
+  o Don't loose top error in SSL (3d1a7a1d Yury Korzhetsky)
+  o Remove needless check for arc4_seeded_ok (6602a97d Seong-Joong Kim)
+  o Merge pull request #769 from sungjungk/fix-return-handling (91084140 Nathan French)
+
+ build:
+  o Define `_GNU_SOURCE` properly/consistently per autoconf (00ba9fa2 Enji Cooper)
+  o signal: guard __cdecl definition with #ifdef (d89045a6 Azat Khuzhin)
+  o Link test/regress with event_core/event_extra over event (22380996 Azat Khuzhin)
+
+ tests:
+  o Use kill() over raise() for raising the signal (fixes osx 10.14 with
+    kqueue) (3db5296b, a45f6733 Azat Khuzhin)
+  o tinytest: implement per-test timeout (via alarm() under !win32 only)
+    (b64dbfb6, 75d7e1ff Azat Khuzhin)
+
+Changes in version 2.1.9-beta (10 February 2019)
+
+ This changelog will differs from other releases in the next few clauses:
+ - contains only highlighted changes (so now it will not contains a lot of
+   patches that fixes some stuff in regression tests, typos, leaks fixes in
+   samples and so forth)
+ - no authors (since merge commits breaks them anyway, but AUTHORS sections in
+   README will be kept up to date)
+ - group name trimmed from commit subjects trimmed
+ - it's been 2 years since the previoius release, so it is pretty huge
+
+ And I think that this is more useful, so from now on it will always has the
+ same look (until there will too many objections of course).
+
+ To view full changelog please use git:
+   git log --format='  o %s (%h %aN)' release-2.1.8-stable...release-2.1.9-beta
+
+
+ dist archive:
+  o Add cmake rules into dist archive (bf3a67cf)
+  o Add missing print-winsock-errors.c into dist archive (822d6462)
+  o Include openssl-compat.h into dist archive (08658136)
+
+ core:
+  o Merge branch 'check-O_NONBLOCK-in-debug' (a39898f3, a8155c62)
+  o Merge branch 'event-ET-#636-v2' (ca4b6404)
+  o Fix visibility issues under (mostly on win32)
+    (349081e1g, 802be13ag, a1f28e2f)
+  o Define __EXT_POSIX2 for QNX (a2176f2c)
+  o Cleanup __func__ detection (b3af7bdd)
+  o Add convenience macros for user-triggered events (06ec5de6)
+  o Notify event base if there are no more events, so it can exit without delay (d9d1c09e)
+  o Fix base unlocking in event_del() if event_base_set() runned in another thread (4f0f40e3)
+  o If precise_time is false, we should not set EVENT_BASE_FLAG_PRECISE_TIMER (27dee54d)
+  o Fix race in access to ev_res from event loop with event_active() (43d92a6d)
+  o Return from event_del() after the last event callback termination (876c7ac7)
+
+ http:
+  o Merge branch 'http-EVHTTP_CON_READ_ON_WRITE_ERROR-fixes-v2' (eb7b472b)
+  o Preserve socket error from listen across closesocket cleanup (2ccd00a6)
+  o fix connection retries when there more then one request for connection (d30e7bba)
+  o improve error path for bufferevent_{setfd,enable,disable}() (a8cc449e)
+  o Fix conceivable UAF of the bufferevent in evhttp_connection_free() (6ac2ec25)
+  o Merge branch 'http-request-line-parsing' (cdcfbafe)
+  o Fix evhttp_connection_get_addr() fox incomming http connections (4215c003)
+  o fix leaks in evhttp_uriencode() (123362e9)
+  o CONNECT method only takes an authority (7d1ffe64)
+  o Allow bodies for GET/DELETE/OPTIONS/CONNECT (23eb38b9)
+  o Do not crash when evhttp_send_reply_start() is called after a timeout. (826f1134)
+  o Fix crashing http server when callback do not reply in place (5b40744d, b2581380)
+  o fix handling of close_notify (ssl) in http with openssl bufferevents (7e91622b)
+
+ evrpc:
+  o use *_new_with_arg() to match function prototype (a95cc9e3)
+  o avoid NULL dereference on request is not EVHTTP_REQ_POST (e05136c7)
+
+ regression tests:
+  o Merge branch 'TT_RETRIABLE' (6ea1ec68, f9b592aa)
+
+ bufferevent:
+  o Merge branch 'iocp-fixes' (6bfac964)
+  o Merge branch 'be-wm-overrun-v2' (3f692fff)
+  o bufferevent_socket_connect{,_hostname}() missing event callback and use ret code (1dde74ef)
+  o don't fail be_null_filter if bytes are copied (b92b0792)
+  o Call underlying bev ctrl GET_FD on filtered bufferevents (ebfac517)
+
+ bufferevent_openssl/openssl:
+  o Merge branch 'ssl_bufferevent_wm_filter-fix' (30020a35)
+  o be_openssl: avoid leaking of SSL structure (e86ccfe5)
+  o Fix build with LibreSSL 2.7 (894ca48a)
+  o Add missing includes into openssl-compat.h (01bc36c1)
+  o Explicitly call SSL_clear when reseting the fd. (29b7a516)
+  o Unbreak build with LibreSSL after openssl 1.1 support added (230af9f0)
+
+ samples:
+  o Merge branch 'sample-http-server' (b6309bcc)
+  o sample/https-client: use host SSL certificate store by default (5c0132f3)
+
+ listener:
+  o ipv6only socket bind support (ba148796)
+  o Merge branch 'listener-immediate-close' (df2ed13f)
+  o Merge branch 'evconnlistener-do-not-close-client-fd' (42e851bb)
+
+ evdns:
+  o evdns: handle NULL filename explicitly (0033f5cc)
+  o Merge branch 'evdns_getaddrinfo-race-fix' (3237d697)
+  o Generating evdns_base_config_windows_nameservers docs on all platforms (3bd2ce43)
+
+ utils:
+  o Merge branch 'evutil_found_ifaddr-dev' (b07e43e6)
+  o Avoid possible SEGVs in select() (in unit tests) (8818c86c)
+  o Port `event_rpcgen.py` and `test/check-dumpevents.py` to Python 3. (532a8cc3)
+
+ buffer:
+  o Fix assert() condition in evbuffer_drain() for IOCP (d6326104)
+  o fix incorrect unlock of the buffer mutex (for deferred callbacks) (2b4d127d)
+  o Fix wrong assert in evbuffer_drain() (9f4d0dce)
+
+ cmake:
+  o fix checking of devpoll backend (like in autotools, by devpoll.h existence) (7f161902)
+  o support static runtime (MSVC) (c8b3ec17, 61fb055a)
+  o do not build both (SHARED and STATIC) for MSVC/win32 (bc7f2fd9)
+  o introduce EVENT__LIBRARY_TYPE option (eb10a738)
+  o ensure windows dll's are installed as well as lib files (29590718)
+  o Fix generation of LibeventConfig.cmake for the installation tree (7fa08c4b)
+  o fix pkgconfig generation (copy-paste typo) (cc554d87)
+  o Merge branch 'cmake-missing-bits' (9806b126)
+  o Fix detection of timerfd_create() in CMake. (e50af331)
+  o Merge branch 'cmake-configure-fixes-v2' (a0bfe2c4)
+  o Do not add epoll_sub (syscall wrappers) for epoll in cmake (cea61de6)
+  o Fix RPATH for APPLE (45b1f379)
+
+ autotools:
+  o include win32 specific headers for socklen_t detection on win32/mingw (d7579fb9)
+  o Ignore evconfig-private.h for autotools (37423849)
+  o config.h can't be prefixed unconditionally (63a054f8)
+  o Merge branch 'pull-628' (7e56c8b2)
+  o Provide Makefile variables LIBEVENT_{CFLAGS,CPPFLAGS,LDFLAGS} (2f060c5f)
+  o confirm openssl is working before using (b39ccf8e)
+  o pass $(OPENSSL_INCS) for samples (FTBFS macOS) (c2495265)
+  o Add configure check for midipix (d433201e)
+  o Fix tests with detached builds (c46ff439)
+
+ build:
+  o Fix arc4random_addrandom() detecting and fallback (regression) (303d6d77)
+  o Merge branch 'win32-fixes' (ebd12e6d)
+  o Merge branch 'fix-openssl-linking' (e7bd9e03)
+  o Merge branch 'fix-struct-linger' (8567f2f5)
+
+ CI:
+  o travis-ci/appveyor now uses fast_finish+allow_failures
+    (5e97b6e6, dd472e7d, dfb5fc167)
+  o Merge branch 'travis-ci-osx-fixes' (9f02b39c)
+  o Merge branch 'win64-fixes' (aee0fcd5)
+
+
 Changes in version 2.1.8-stable (22 January 2017)
 
  Libevent 2.1.8-stable, it contains openssl fixes for resetting fd and using
diff --git a/ipc/chromium/src/third_party/libevent/ChangeLog-1.4 b/ipc/chromium/src/third_party/libevent/ChangeLog-1.4
index 166d30872f81..d7f6517b2b92 100644
--- a/ipc/chromium/src/third_party/libevent/ChangeLog-1.4
+++ b/ipc/chromium/src/third_party/libevent/ChangeLog-1.4
@@ -175,7 +175,7 @@ Changes in 1.4.1-beta:
  o support for 32-bit tag numbers in rpc structures; this is wire compatible, but changes the API slightly.
  o prefix {encode,decode}_tag functions with evtag to avoid collisions
  o Correctly handle DNS replies with no answers set (Fixes bug 1846282)
- o The configure script now takes an --enable-gcc-warnigns option that turns on many optional gcc warnings.  (Nick has been building with these for a while, but they might be useful to other developers.)
+ o The configure script now takes an --enable-gcc-warnings option that turns on many optional gcc warnings.  (Nick has been building with these for a while, but they might be useful to other developers.)
  o When building with GCC, use the "format" attribute to verify type correctness of calls to printf-like functions.
  o removed linger from http server socket; reported by Ilya Martynov
  o allow \r or \n individually to separate HTTP headers instead of the standard "\r\n"; from Charles Kerr.
diff --git a/ipc/chromium/src/third_party/libevent/ChangeLog-2.0 b/ipc/chromium/src/third_party/libevent/ChangeLog-2.0
index a925d33b180a..16f36008cdec 100644
--- a/ipc/chromium/src/third_party/libevent/ChangeLog-2.0
+++ b/ipc/chromium/src/third_party/libevent/ChangeLog-2.0
@@ -1143,7 +1143,7 @@ Changes in 2.0.1-alpha (17 Apr 2009):
  o Check return value of event_add in signal.c
  o Add a more powerful evbuffer_readln as a replacement for evbuffer_readline.  The new function handles more newline styles, and is more useful with buffers that may contain a nul characters.
  o Do not mangle socket handles on 64-bit windows.
- o The configure script now takes an --enable-gcc-warnigns option that turns on many optional gcc warnings.  (Nick has been building with these for a while, but they might be useful to other developers.)
+ o The configure script now takes an --enable-gcc-warnings option that turns on many optional gcc warnings.  (Nick has been building with these for a while, but they might be useful to other developers.)
  o move EV_PERSIST handling out of the event backends
  o small improvements to evhttp documentation
  o always generate Date and Content-Length headers for HTTP/1.1 replies
diff --git a/ipc/chromium/src/third_party/libevent/Doxyfile b/ipc/chromium/src/third_party/libevent/Doxyfile
index d9d6603459c3..3f094f72134e 100644
--- a/ipc/chromium/src/third_party/libevent/Doxyfile
+++ b/ipc/chromium/src/third_party/libevent/Doxyfile
@@ -17,11 +17,11 @@
 # The PROJECT_NAME tag is a single word (or a sequence of words surrounded 
 # by quotes) that should identify the project.
 
-PROJECT_NAME           = libevent
+PROJECT_NAME           = $(PROJECT)-$(VERSION)
 
 # Place all output under 'doxygen/'
 
-OUTPUT_DIRECTORY        = doxygen/
+OUTPUT_DIRECTORY        = $(DOCDIR)
 
 # If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen 
 # will interpret the first line (until the first dot) of a JavaDoc-style 
@@ -64,24 +64,24 @@ STRIP_FROM_PATH        = include/
 # with spaces.
 
 INPUT                  = \
-        include/event2/buffer.h \
-        include/event2/buffer_compat.h \
-        include/event2/bufferevent.h \
-        include/event2/bufferevent_compat.h \
-        include/event2/bufferevent_ssl.h \
-        include/event2/dns.h \
-        include/event2/dns_compat.h \
-        include/event2/event.h \
-        include/event2/event_compat.h \
-        include/event2/http.h \
-        include/event2/http_compat.h \
-        include/event2/listener.h \
-        include/event2/rpc.h \
-        include/event2/rpc_compat.h \
-        include/event2/tag.h \
-        include/event2/tag_compat.h \
-        include/event2/thread.h \
-        include/event2/util.h
+        $(SRCDIR)/include/event2/buffer.h \
+        $(SRCDIR)/include/event2/buffer_compat.h \
+        $(SRCDIR)/include/event2/bufferevent.h \
+        $(SRCDIR)/include/event2/bufferevent_compat.h \
+        $(SRCDIR)/include/event2/bufferevent_ssl.h \
+        $(SRCDIR)/include/event2/dns.h \
+        $(SRCDIR)/include/event2/dns_compat.h \
+        $(SRCDIR)/include/event2/event.h \
+        $(SRCDIR)/include/event2/event_compat.h \
+        $(SRCDIR)/include/event2/http.h \
+        $(SRCDIR)/include/event2/http_compat.h \
+        $(SRCDIR)/include/event2/listener.h \
+        $(SRCDIR)/include/event2/rpc.h \
+        $(SRCDIR)/include/event2/rpc_compat.h \
+        $(SRCDIR)/include/event2/tag.h \
+        $(SRCDIR)/include/event2/tag_compat.h \
+        $(SRCDIR)/include/event2/thread.h \
+        $(SRCDIR)/include/event2/util.h
 
 #---------------------------------------------------------------------------
 # configuration options related to the HTML output
@@ -90,7 +90,7 @@ INPUT                  = \
 # If the GENERATE_HTML tag is set to YES (the default) Doxygen will 
 # generate HTML output.
 
-GENERATE_HTML          = YES
+GENERATE_HTML          = $(GENERATE_HTML)
 
 #---------------------------------------------------------------------------
 # configuration options related to the LaTeX output
@@ -99,7 +99,7 @@ GENERATE_HTML          = YES
 # If the GENERATE_LATEX tag is set to YES (the default) Doxygen will 
 # generate Latex output.
 
-GENERATE_LATEX         = YES
+GENERATE_LATEX         = $(GENERATE_LATEX)
 
 # The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. 
 # If a relative path is entered the value of OUTPUT_DIRECTORY will be 
@@ -175,7 +175,7 @@ LATEX_HIDE_INDICES     = NO
 # If the GENERATE_MAN tag is set to YES (the default) Doxygen will 
 # generate man pages
 
-GENERATE_MAN           = NO
+GENERATE_MAN           = $(GENERATE_MAN)
 
 # The MAN_EXTENSION tag determines the extension that is added to 
 # the generated man pages (default is the subroutine's section .3)
diff --git a/ipc/chromium/src/third_party/libevent/Makefile.am b/ipc/chromium/src/third_party/libevent/Makefile.am
index 0f741bc9c3a1..21815008a43c 100644
--- a/ipc/chromium/src/third_party/libevent/Makefile.am
+++ b/ipc/chromium/src/third_party/libevent/Makefile.am
@@ -5,8 +5,8 @@
 # See LICENSE for copying information.
 
 # 'foreign' means that we're not enforcing GNU package rules strictly.
-# '1.9' means that we need automake 1.9 or later (and we do).
-AUTOMAKE_OPTIONS = foreign 1.9 subdir-objects
+# '1.13' means that we need automake 1.13 or later (and we do).
+AUTOMAKE_OPTIONS = foreign 1.13 subdir-objects
 
 ACLOCAL_AMFLAGS = -I m4
 
@@ -38,7 +38,7 @@ RELEASE = -release 2.1
 #
 # Once an RC is out, DO NOT MAKE ANY ABI-BREAKING CHANGES IN THAT SERIES
 # UNLESS YOU REALLY REALLY HAVE TO.
-VERSION_INFO = 6:2:0
+VERSION_INFO = 7:1:0
 
 # History:          RELEASE    VERSION_INFO
 #  2.0.1-alpha --     2.0        1:0:0
@@ -71,7 +71,11 @@ VERSION_INFO = 6:2:0
 #  2.1.5-beta  --     2.1        5:0:0 (ABI changed slightly)
 #  2.1.6-beta  --     2.1        6:0:0 (ABI changed slightly)
 #  2.1.7-beta  --     2.1        6:1:0 (ABI changed slightly)
-#  2.1.8-stable--     2.1        6:2:0 (ABI changed slightly)
+#  2.1.8-stable--     2.1        6:2:0 (No ABI change)
+#  2.1.9-beta--       2.1        6:3:0 (No ABI change)
+#  2.1.10-stable--    2.1        6:4:0 (No ABI change, WRONG)
+#  2.1.11-stable--    2.1        7:0:0 (ABI changed)
+#  2.1.12-stable--    2.1        7:1:0 (No ABI change)
 
 # ABI version history for this package effectively restarts every time
 # we change RELEASE.  Version 1.4.x had RELEASE of 1.4.
@@ -104,6 +108,29 @@ PLATFORM_DEPENDENT_SRC = \
 	arc4random.c \
 	epoll_sub.c
 
+CMAKE_FILES = \
+	cmake/AddCompilerFlags.cmake \
+	cmake/AddEventLibrary.cmake \
+	cmake/CheckConstExists.cmake \
+	cmake/CheckFileOffsetBits.c \
+	cmake/CheckFileOffsetBits.cmake \
+	cmake/CheckFunctionKeywords.cmake \
+	cmake/CheckPrototypeDefinition.c.in \
+	cmake/CheckPrototypeDefinition.cmake \
+	cmake/CheckWorkingKqueue.cmake \
+	cmake/CodeCoverage.cmake \
+	cmake/COPYING-CMAKE-SCRIPTS \
+	cmake/Copyright.txt \
+	cmake/LibeventConfig.cmake.in \
+	cmake/LibeventConfigVersion.cmake.in \
+	cmake/Macros.cmake \
+	cmake/Uninstall.cmake.in \
+	cmake/UseDoxygen.cmake \
+	cmake/VersionViaGit.cmake \
+	event-config.h.cmake \
+	evconfig-private.h.cmake \
+	CMakeLists.txt
+
 EXTRA_DIST = \
 	ChangeLog-1.4 \
 	ChangeLog-2.0 \
@@ -116,6 +143,8 @@ EXTRA_DIST = \
 	make-event-config.sed \
 	whatsnew-2.0.txt \
 	whatsnew-2.1.txt \
+	README.md \
+	$(CMAKE_FILES) \
 	$(PLATFORM_DEPENDENT_SRC)
 
 LIBEVENT_LIBS_LA = libevent.la libevent_core.la libevent_extra.la
@@ -148,6 +177,7 @@ include test/include.am
 
 if BUILD_WIN32
 
+SYS_CORE_LIBS = -liphlpapi
 SYS_LIBS = -lws2_32 -lshell32 -ladvapi32
 SYS_SRC = win32select.c buffer_iocp.c event_iocp.c \
 	bufferevent_async.c
@@ -159,6 +189,7 @@ endif
 
 else
 
+SYS_CORE_LIBS =
 SYS_LIBS =
 SYS_SRC =
 SYS_INCLUDES =
@@ -228,14 +259,18 @@ NO_UNDEFINED =
 MAYBE_CORE =
 endif
 
-GENERIC_LDFLAGS = -version-info $(VERSION_INFO) $(RELEASE) $(NO_UNDEFINED)
+AM_CFLAGS = $(LIBEVENT_CFLAGS)
+AM_CPPFLAGS = -I$(srcdir)/compat -I./include -I$(srcdir)/include $(SYS_INCLUDES) $(LIBEVENT_CPPFLAGS)
+AM_LDFLAGS = $(LIBEVENT_LDFLAGS)
+
+GENERIC_LDFLAGS = -version-info $(VERSION_INFO) $(RELEASE) $(NO_UNDEFINED) $(AM_LDFLAGS)
 
 libevent_la_SOURCES = $(CORE_SRC) $(EXTRAS_SRC)
-libevent_la_LIBADD = @LTLIBOBJS@ $(SYS_LIBS)
+libevent_la_LIBADD = @LTLIBOBJS@ $(SYS_LIBS) $(SYS_CORE_LIBS)
 libevent_la_LDFLAGS = $(GENERIC_LDFLAGS)
 
 libevent_core_la_SOURCES = $(CORE_SRC)
-libevent_core_la_LIBADD = @LTLIBOBJS@ $(SYS_LIBS)
+libevent_core_la_LIBADD = @LTLIBOBJS@ $(SYS_LIBS) $(SYS_CORE_LIBS)
 libevent_core_la_LDFLAGS = $(GENERIC_LDFLAGS)
 
 if PTHREADS
@@ -258,14 +293,16 @@ endif
 noinst_HEADERS +=				\
 	WIN32-Code/nmake/evconfig-private.h	\
 	WIN32-Code/nmake/event2/event-config.h	\
+	WIN32-Code/getopt.h			\
+	WIN32-Code/getopt.c			\
+	WIN32-Code/getopt_long.c	\
 	WIN32-Code/tree.h			\
-	bufferevent-internal.h			\
-	changelist-internal.h			\
+	bufferevent-internal.h		\
+	changelist-internal.h		\
 	compat/sys/queue.h			\
 	defer-internal.h			\
-	epolltable-internal.h			\
+	epolltable-internal.h		\
 	evbuffer-internal.h			\
-	evconfig-private.h			\
 	event-internal.h			\
 	evmap-internal.h			\
 	evrpc-internal.h			\
@@ -283,7 +320,8 @@ noinst_HEADERS +=				\
 	ratelim-internal.h			\
 	strlcpy-internal.h			\
 	time-internal.h				\
-	util-internal.h
+	util-internal.h				\
+	openssl-compat.h
 
 EVENT1_HDRS = \
 	include/evdns.h \
@@ -298,13 +336,9 @@ else
 noinst_HEADERS += $(EVENT1_HDRS)
 endif
 
-AM_CPPFLAGS = -I$(srcdir)/compat -I$(srcdir)/include -I./include $(SYS_INCLUDES)
-
 verify: check
 
-doxygen: FORCE
-	doxygen $(srcdir)/Doxyfile
-FORCE:
+include doxygen.am
 
 DISTCLEANFILES += *~ libevent.pc libevent_core.pc libevent_extra.pc ./include/event2/event-config.h
 
diff --git a/ipc/chromium/src/third_party/libevent/README.md b/ipc/chromium/src/third_party/libevent/README.md
index 5e3eb4df8fe0..1247e220f50e 100644
--- a/ipc/chromium/src/third_party/libevent/README.md
+++ b/ipc/chromium/src/third_party/libevent/README.md
@@ -4,9 +4,10 @@
 
 
 
-[![Appveyor Win32 Build Status](https://ci.appveyor.com/api/projects/status/github/libevent/libevent?branch=master&svg=true)](https://ci.appveyor.com/project/nmathewson/libevent)
+[![Appveyor Win32 Build Status](https://ci.appveyor.com/api/projects/status/ng3jg0uhy44mp7ik?svg=true)](https://ci.appveyor.com/project/libevent/libevent)
 [![Travis Build Status](https://travis-ci.org/libevent/libevent.svg?branch=master)](https://travis-ci.org/libevent/libevent)
 [![Coverage Status](https://coveralls.io/repos/github/libevent/libevent/badge.svg)](https://coveralls.io/github/libevent/libevent)
+[![Join the chat at https://gitter.im/libevent/libevent](https://badges.gitter.im/libevent/libevent.svg)](https://gitter.im/libevent/libevent?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)
 
 
 
@@ -19,42 +20,34 @@
      $ make verify   # (optional)
      $ sudo make install
 
-## Cmake (General)
+## CMake (General)
 
 
-The following Libevent specific Cmake variables are as follows (the values being
+The following Libevent specific CMake variables are as follows (the values being
 the default).
 
 ```
-# Installation directory for executables
-EVENT_INSTALL_BIN_DIR:PATH=bin
+# Type of the library to build (SHARED or STATIC)
+# Default is: SHARED for MSVC, otherwise BOTH
+EVENT__LIBRARY_TYPE:STRING=DEFAULT
 
 # Installation directory for CMake files
 EVENT_INSTALL_CMAKE_DIR:PATH=lib/cmake/libevent
 
-## Installation directory for header files
-EVENT_INSTALL_INCLUDE_DIR:PATH=include
-
-## Installation directory for libraries
-EVENT_INSTALL_LIB_DIR:PATH=lib
-
-## Define if libevent should be built with shared libraries instead of archives
-EVENT__BUILD_SHARED_LIBRARIES:BOOL=OFF
-
 # Enable running gcov to get a test coverage report (only works with
 # GCC/CLang). Make sure to enable -DCMAKE_BUILD_TYPE=Debug as well.
 EVENT__COVERAGE:BOOL=OFF
 
-# Defines if libevent should build without the benchmark exectuables
+# Defines if Libevent should build without the benchmark executables
 EVENT__DISABLE_BENCHMARK:BOOL=OFF
 
-# Define if libevent should build without support for a debug mode
+# Define if Libevent should build without support for a debug mode
 EVENT__DISABLE_DEBUG_MODE:BOOL=OFF
 
-# Define if libevent should not allow replacing the mm functions
+# Define if Libevent should not allow replacing the mm functions
 EVENT__DISABLE_MM_REPLACEMENT:BOOL=OFF
 
-# Define if libevent should build without support for OpenSSL encrpytion
+# Define if Libevent should build without support for OpenSSL encryption
 EVENT__DISABLE_OPENSSL:BOOL=OFF
 
 # Disable the regress tests
@@ -66,20 +59,17 @@ EVENT__DISABLE_SAMPLES:BOOL=OFF
 # If tests should be compiled or not
 EVENT__DISABLE_TESTS:BOOL=OFF
 
-# Define if libevent should not be compiled with thread support
+# Define if Libevent should not be compiled with thread support
 EVENT__DISABLE_THREAD_SUPPORT:BOOL=OFF
 
 # Enables verbose debugging
 EVENT__ENABLE_VERBOSE_DEBUG:BOOL=OFF
 
-# When crosscompiling forces running a test program that verifies that Kqueue
+# When cross compiling, forces running a test program that verifies that Kqueue
 # works with pipes. Note that this requires you to manually run the test program
-# on the the cross compilation target to verify that it works. See cmake
+# on the the cross compilation target to verify that it works. See CMake
 # documentation for try_run for more details
 EVENT__FORCE_KQUEUE_CHECK:BOOL=OFF
-
-# set EVENT_STAGE_VERSION
-EVENT__STAGE_VERSION:STRING=beta
 ```
 
 __More variables can be found by running `cmake -LAH <sourcedir_path>`__
@@ -87,7 +77,7 @@ __More variables can be found by running `cmake -LAH <sourcedir_path>`__
 
 ## CMake (Windows)
 
-Install CMake: <http://www.cmake.org>
+Install CMake: <https://www.cmake.org>
 
 
      $ md build && cd build
@@ -106,12 +96,12 @@ Install CMake: <http://www.cmake.org>
 
 ## Autoconf
 
-To build libevent, type
+To build Libevent, type
 
      $ ./configure && make
 
 
- (If you got libevent from the git repository, you will
+ (If you got Libevent from the git repository, you will
   first need to run the included "autogen.sh" script in order to
   generate the configure script.)
 
@@ -125,36 +115,36 @@ Install as root via
 
 Before reporting any problems, please run the regression tests.
 
-To enable the low-level tracing build the library as:
+To enable low-level tracing, build the library as:
 
      $ CFLAGS=-DUSE_DEBUG ./configure [...]
 
 Standard configure flags should work.  In particular, see:
 
-   --disable-shared          Only build static libraries
-   --prefix                  Install all files relative to this directory.
+     --disable-shared          Only build static libraries.
+     --prefix                  Install all files relative to this directory.
 
 
 The configure script also supports the following flags:
 
-   --enable-gcc-warnings     Enable extra compiler checking with GCC.
-   --disable-malloc-replacement
-                             Don't let applications replace our memory
-                             management functions
-   --disable-openssl         Disable support for OpenSSL encryption.
-   --disable-thread-support  Don't support multithreaded environments.
+     --enable-gcc-warnings     Enable extra compiler checking with GCC.
+     --disable-malloc-replacement
+                               Don't let applications replace our memory
+                               management functions.
+     --disable-openssl         Disable support for OpenSSL encryption.
+     --disable-thread-support  Don't support multithreaded environments.
 
 ## CMake (Windows)
 
 (Note that autoconf is currently the most mature and supported build
-enviroment for libevent; the cmake instructions here are new and
-experimental, though they _should_ be solid.  We hope that cmake will
+environment for Libevent; the CMake instructions here are new and
+experimental, though they _should_ be solid.  We hope that CMake will
 still be supported in future versions of Libevent, and will try to
 make sure that happens.)
 
-First of all install <http://www.cmake.org>.
+First of all install <https://www.cmake.org>.
 
-To build libevent using Microsoft Visual studio open the "Visual Studio Command prompt" and type:
+To build Libevent using Microsoft Visual studio open the "Visual Studio Command prompt" and type:
 
 ```
 $ cd <libevent source dir>
@@ -183,11 +173,6 @@ $ cmake -LH ..
 CMake also provides a GUI that lets you specify the source directory and output (binary) directory
 that the build should be placed in.
 
-### OpenSSL support
-
-To build Libevent with OpenSSL support you will need to have OpenSSL binaries available when building,
-these can be found here: <http://www.openssl.org/related/binaries.html>
-
 # 2. USEFUL LINKS:
 
 For the latest released version of Libevent, see the official website at
@@ -205,15 +190,15 @@ $ git clone https://github.com/libevent/libevent.git
 
 You can browse the git repository online at:
 
-<https://github.com/libevent/Libevent>
+<https://github.com/libevent/libevent>
 
 To report bugs, issues, or ask for new features:
 
 __Patches__: https://github.com/libevent/libevent/pulls
-> OK, those are not really _patches_ You fork, modify, and hit the "Create Pull Request" button.
-> You can still submit normal git patchs via the mailing list.
+> OK, those are not really _patches_. You fork, modify, and hit the "Create Pull Request" button.
+> You can still submit normal git patches via the mailing list.
 
-__Bugs, Features [RFC], and Issus__: https://github.com/libevent/libevent/issues
+__Bugs, Features [RFC], and Issues__: https://github.com/libevent/libevent/issues
 > Or you can do it via the mailing list.
 
 There's also a libevent-users mailing list for talking about Libevent
@@ -427,5 +412,76 @@ fixing bugs:
  * johnsonlee
  * Philip Prindeville
  * Vis Virial
+ * Andreas Gustafsson
+ * Andrey Okoshkin
+ * an-tao
+ * baixiangcpp
+ * Bernard Spil
+ * Bogdan Harjoc
+ * Carlo Marcelo Arenas Beln
+ * David Benjamin
+ * David Disseldorp
+ * Dmitry Alimov
+ * Dominic Chen
+ * dpayne
+ * ejurgensen
+ * Fredrik Strupe
+ * Gonalo Ribeiro
+ * James Synge
+ * Jan Beich
+ * Jesse Fang
+ * Jiri Luznicky
+ * Jos Luis Milln
+ * Kiyoshi Aman
+ * Leo Zhang
+ * lightningkay
+ * Luke Dashjr
+ * Marcin Szewczyk
+ * Maximilian Brunner
+ * Maya Rashish
+ * Murat Demirten
+ * Nathan French
+ * Nikolay Edigaryev
+ * Philip Herron
+ * Redfoxmoon
+ * stenn
+ * SuckShit
+ * The Gitter Badger
+ * tim-le
+ * Vincent JARDIN
+ * Xiang Zhang
+ * Xiaozhou Liu
+ * yongqing.jiao
+ * Enji Cooper
+ * linxiaohui
+ * Seong-Joong Kim
+ * Tobias Stoeckmann
+ * Yury Korzhetsky
+ * zhuizhuhaomeng
+ * Pierce Lopez
+ * yuangongji
+ * Keith Smiley
+ * jeremyerb
+ * Fabrice Fontaine
+ * wenyg
+ * Aleksandr-Melnikov
+ * ayuseleznev
+ * chenguolong
+ * Dimo Markov
+ * dota17
+ * fanquake
+ * Jan Kasiak
+ * Kamil Rytarowski
+ * Mario Emmenlauer
+ * Michael Davidsaver
+ * mohuang
+ * Nick Grifka
+ * Nicolas J. Bouliane
+ * Paul Osborne
+ * Philip Homburg
+ * Wataru Ashihara
+ * William A Rowe Jr
+ * yangyongsheng
+
 
 If we have forgotten your name, please contact us.
diff --git a/ipc/chromium/src/third_party/libevent/README.mozilla b/ipc/chromium/src/third_party/libevent/README.mozilla
index 262a6228e436..c2fcb5a1f424 100644
--- a/ipc/chromium/src/third_party/libevent/README.mozilla
+++ b/ipc/chromium/src/third_party/libevent/README.mozilla
@@ -1,4 +1,4 @@
-This is a clean copy of libevent-2.1.8-stable with the following modifications.
+This is a clean copy of libevent-2.1.12-stable with the following modifications.
 
 1. Add the following files:
 
@@ -6,9 +6,10 @@ This is a clean copy of libevent-2.1.8-stable with the following modifications.
 - bsd/event2/event-config.h
 - linux/event2/event-config.h
 - mac/event2/event-config.h
+- solaris/event2/event-config.h
 - evconfig-private.h
 
-These files are taken from libevent-2.1.8-stable built on the development
+These files are taken from libevent-2.1.12-stable built on the development
 environment indicated by the first path component. You have to run
 "./configure" and "make" to get all of the pre-processing done. The
 event-config.h header can then be found in include/event2/ sub-directory and
@@ -21,18 +22,6 @@ distinguish the two cases. If you get something wrong, the CHECK_EVENT_SIZEOF
 static assertions in message_pump_libevent.cc will fail. If a new constant is
 added, also add a static assertion for it to message_pump_libevent.cc.
 
-2. Apply the following patches from
-ipc/chromium/src/third_party/libevent/patches/:
-
-- "openbsd-no-arc4random_addrandom.patch". Fixes the build on OpenBSD,
-  FreeBSD and Android (which don't provide arc4random_addrandom anymore).
-  See bug 931354, bug 1259218, bug 1497169.
-
-- "dont-use-issetugid-on-android.patch". Fixes Android startup crashes.
-  See bug 1030899.
-
-- "linux-no-sysctl.patch". Fixes the build on Linux systems without sysctl.h.
-  See bug 1263429.
-
-- "android-api-level.patch". Fixes the build under clang or NDK r16.
-  See bug 1281596, bug 1282141, and bug 1428182.
+2. No additional patches are needed at this time, but be careful to avoid
+clobbering changes to the various event-config.h files which have been customized
+over time to avoid various build bustages.
diff --git a/ipc/chromium/src/third_party/libevent/WIN32-Code/getopt_long.c b/ipc/chromium/src/third_party/libevent/WIN32-Code/getopt_long.c
index 03f0c01a15ec..092defbc4bed 100644
--- a/ipc/chromium/src/third_party/libevent/WIN32-Code/getopt_long.c
+++ b/ipc/chromium/src/third_party/libevent/WIN32-Code/getopt_long.c
@@ -173,7 +173,8 @@ getopt_long(nargc, nargv, options, long_options, index)
 
 	if ((retval = getopt_internal(nargc, nargv, options)) == -2) {
 		char *current_argv = nargv[optind++] + 2, *has_equal;
-		int i, current_argv_len, match = -1;
+		int i, match = -1;
+		size_t current_argv_len;
 
 		if (*current_argv == '\0') {
 			return(-1);
@@ -184,11 +185,11 @@ getopt_long(nargc, nargv, options, long_options, index)
 		} else
 			current_argv_len = strlen(current_argv);
 
-		for (i = 0; long_options[i].name; i++) { 
+		for (i = 0; long_options[i].name; i++) {
 			if (strncmp(current_argv, long_options[i].name, current_argv_len))
 				continue;
 
-			if (strlen(long_options[i].name) == (unsigned)current_argv_len) { 
+			if (strlen(long_options[i].name) == current_argv_len) {
 				match = i;
 				break;
 			}
diff --git a/ipc/chromium/src/third_party/libevent/WIN32-Code/nmake/event2/event-config.h b/ipc/chromium/src/third_party/libevent/WIN32-Code/nmake/event2/event-config.h
index e6ed3aa4dcc3..3f3a0d2968dc 100644
--- a/ipc/chromium/src/third_party/libevent/WIN32-Code/nmake/event2/event-config.h
+++ b/ipc/chromium/src/third_party/libevent/WIN32-Code/nmake/event2/event-config.h
@@ -192,9 +192,6 @@
 /* Define to 1 if the system has the type `struct sockaddr_storage'. */
 #define EVENT__HAVE_STRUCT_SOCKADDR_STORAGE 1
 
-/* Define to 1 if you have the <sys/devpoll.h> header file. */
-/* #undef EVENT__HAVE_SYS_DEVPOLL_H */
-
 /* Define to 1 if you have the <sys/epoll.h> header file. */
 /* #undef EVENT__HAVE_SYS_EPOLL_H */
 
@@ -274,7 +271,7 @@
 /* #undef EVENT__HAVE_WORKING_KQUEUE */
 
 /* Numeric representation of the version */
-#define EVENT__NUMERIC_VERSION 0x02010800
+#define EVENT__NUMERIC_VERSION 0x02010c00
 
 /* Name of package */
 #define EVENT__PACKAGE "libevent"
@@ -324,29 +321,22 @@
 #define EVENT__SIZEOF_VOID_P 4
 #endif
 
-/* Define to 1 if you have the ANSI C header files. */
-#define EVENT__STDC_HEADERS 1
+/* The size of `time_t`, as computed by sizeof. */
+#ifdef _WIN64
+#define EVENT__SIZEOF_TIME_T 8
+#else
+#define EVENT__SIZEOF_TIME_T 4
+#endif
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #define EVENT__TIME_WITH_SYS_TIME 1
 
 /* Version number of package */
-#define EVENT__VERSION "2.1.8-stable"
-
-/* Define to appropriate substitue if compiler doesnt have __func__ */
-#define EVENT____func__ __FUNCTION__
-
-/* Define to empty if `const' does not conform to ANSI C. */
-/* #undef EVENT__const */
+#define EVENT__VERSION "2.1.12-stable"
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef _EVENT___cplusplus
 #define EVENT__inline __inline
-#endif
-
-/* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__pid_t */
 
 /* Define to `unsigned' if <sys/types.h> does not define. */
 /* #undef EVENT__size_t */
diff --git a/ipc/chromium/src/third_party/libevent/android/event2/event-config.h b/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
index 2922acb52e11..3be94e0ef4f3 100644
--- a/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
+++ b/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
@@ -30,15 +30,17 @@
 /* #undef EVENT__HAVE_ACCEPT4 */
 #endif
 
+/* Define to 1 if you have the <afunix.h> header file. */
+/* #undef EVENT__HAVE_AFUNIX_H */
+
 /* Define to 1 if you have the `arc4random' function. */
 #define EVENT__HAVE_ARC4RANDOM 1
 
+/* Define to 1 if you have the `arc4random_addrandom' function. */
+/* #undef EVENT__HAVE_ARC4RANDOM_ADDRANDOM */
+
 /* Define to 1 if you have the `arc4random_buf' function. */
-#if __ANDROID_API__ >= 21 || defined(__ANDROID_API_L__)
 #define EVENT__HAVE_ARC4RANDOM_BUF 1
-#else
-/* #undef EVENT__HAVE_ARC4RANDOM_BUF */
-#endif
 
 /* Define to 1 if you have the <arpa/inet.h> header file. */
 #define EVENT__HAVE_ARPA_INET_H 1
@@ -54,14 +56,6 @@
    don't. */
 /* #undef EVENT__HAVE_DECL_KERN_ARND */
 
-/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if you
-   don't. */
-/* #undef EVENT__HAVE_DECL_KERN_RANDOM */
-
-/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if you
-   don't. */
-/* #undef EVENT__HAVE_DECL_RANDOM_UUID */
-
 /* Define if /dev/poll is available */
 /* #undef EVENT__HAVE_DEVPOLL */
 
@@ -80,9 +74,6 @@
 /* Define to 1 if you have the <errno.h> header file. */
 #define EVENT__HAVE_ERRNO_H 1
 
-/* Define to 1 if you have ERR_remove_thread_stat(). */
-/* #undef EVENT__HAVE_ERR_REMOVE_THREAD_STATE */
-
 /* Define to 1 if you have the `eventfd' function. */
 #define EVENT__HAVE_EVENTFD 1
 
@@ -128,6 +119,9 @@
 /* Define to 1 if you have the `getprotobynumber' function. */
 #define EVENT__HAVE_GETPROTOBYNUMBER 1
 
+/* Define to 1 if you have the `getrandom' function. */
+/* #undef EVENT__HAVE_GETRANDOM */
+
 /* Define to 1 if you have the `getservbyname' function. */
 #define EVENT__HAVE_GETSERVBYNAME 1
 
@@ -152,12 +146,18 @@
 /* Define to 1 if you have the `kqueue' function. */
 /* #undef EVENT__HAVE_KQUEUE */
 
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef EVENT__HAVE_LIBWS2_32 */
+
 /* Define if the system has zlib */
 #define EVENT__HAVE_LIBZ 1
 
 /* Define to 1 if you have the `mach_absolute_time' function. */
 /* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */
 
+/* Define to 1 if you have the <mach/mach.h> header file. */
+/* #undef EVENT__HAVE_MACH_MACH_H */
+
 /* Define to 1 if you have the <mach/mach_time.h> header file. */
 /* #undef EVENT__HAVE_MACH_MACH_TIME_H */
 
@@ -185,6 +185,9 @@
 /* Define if the system has openssl */
 /* #undef EVENT__HAVE_OPENSSL */
 
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+/* #undef EVENT__HAVE_OPENSSL_SSL_H */
+
 /* Define to 1 if you have the `pipe' function. */
 #define EVENT__HAVE_PIPE 1
 
@@ -281,6 +284,9 @@
 /* Define to 1 if `s6_addr32' is a member of `struct in6_addr'. */
 #define EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 1
 
+/* Define to 1 if the system has the type `struct linger'. */
+#define EVENT__HAVE_STRUCT_LINGER 1
+
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
 #define EVENT__HAVE_STRUCT_SOCKADDR_IN6 1
 
@@ -299,8 +305,8 @@
 /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
 /* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
 
-/* Define to 1 if the system has the type `struct so_linger'. */
-#define EVENT__HAVE_STRUCT_SO_LINGER 1
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define EVENT__HAVE_STRUCT_SOCKADDR_UN 1
 
 /* Define to 1 if you have the `sysctl' function. */
 /* #undef EVENT__HAVE_SYSCTL */
@@ -329,6 +335,9 @@
 /* Define to 1 if you have the <sys/queue.h> header file. */
 #define EVENT__HAVE_SYS_QUEUE_H 1
 
+/* Define to 1 if you have the <sys/random.h> header file. */
+/* #undef EVENT__HAVE_SYS_RANDOM_H */
+
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #define EVENT__HAVE_SYS_RESOURCE_H 1
 
@@ -359,6 +368,9 @@
 /* Define to 1 if you have the <sys/uio.h> header file. */
 #define EVENT__HAVE_SYS_UIO_H 1
 
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define EVENT__HAVE_SYS_UN_H 1
+
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #define EVENT__HAVE_SYS_WAIT_H 1
 
@@ -410,20 +422,29 @@
 /* Define to 1 if you have the `vasprintf' function. */
 #define EVENT__HAVE_VASPRINTF 1
 
-/* Define if waitpid() supports WNOWAIT */
-#define EVENT__HAVE_WAITPID_WITH_WNOWAIT 1
-
 /* Define if kqueue works correctly with pipes */
 /* #undef EVENT__HAVE_WORKING_KQUEUE */
 
 /* Define to 1 if you have the <zlib.h> header file. */
 #define EVENT__HAVE_ZLIB_H 1
 
+/* Define to 1 if you have the `_gmtime64' function. */
+/* #undef EVENT__HAVE__GMTIME64 */
+
+/* Define to 1 if you have the `_gmtime64_s' function. */
+/* #undef EVENT__HAVE__GMTIME64_S */
+
+/* Define to 1 if compiler have __FUNCTION__ */
+#define EVENT__HAVE___FUNCTION__ 1
+
+/* Define to 1 if compiler have __func__ */
+#define EVENT__HAVE___func__ 1
+
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define EVENT__LT_OBJDIR ".libs/"
 
 /* Numeric representation of the version */
-#define EVENT__NUMERIC_VERSION 0x02010800
+#define EVENT__NUMERIC_VERSION 0x02010c00
 
 /* Name of package */
 #define EVENT__PACKAGE "libevent"
@@ -435,7 +456,7 @@
 #define EVENT__PACKAGE_NAME "libevent"
 
 /* Define to the full name and version of this package. */
-#define EVENT__PACKAGE_STRING "libevent 2.1.8-stable"
+#define EVENT__PACKAGE_STRING "libevent 2.1.12-stable"
 
 /* Define to the one symbol short name of this package. */
 #define EVENT__PACKAGE_TARNAME "libevent"
@@ -444,7 +465,7 @@
 #define EVENT__PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define EVENT__PACKAGE_VERSION "2.1.8-stable"
+#define EVENT__PACKAGE_VERSION "2.1.12-stable"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -492,6 +513,13 @@
 #define EVENT__SIZEOF_SIZE_T 4
 #endif
 
+/* The size of `time_t', as computed by sizeof. */
+#ifdef __LP64__
+#define EVENT__SIZEOF_TIME_T 8
+#else
+#define EVENT__SIZEOF_TIME_T 4
+#endif
+
 /* The size of `void *', as computed by sizeof. */
 #ifdef __LP64__
 #define EVENT__SIZEOF_VOID_P 8
@@ -500,79 +528,79 @@
 #endif
 
 /* Define to 1 if you have the ANSI C header files. */
-#define EVENT__STDC_HEADERS 1
+#define STDC_HEADERS 1
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #define EVENT__TIME_WITH_SYS_TIME 1
 
 /* Enable extensions on AIX 3, Interix.  */
-#ifndef EVENT___ALL_SOURCE
-# define EVENT___ALL_SOURCE 1
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
 #endif
 /* Enable GNU extensions on systems that have them.  */
-#ifndef EVENT___GNU_SOURCE
-# define EVENT___GNU_SOURCE 1
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
 #endif
 /* Enable threading extensions on Solaris.  */
-#ifndef EVENT___POSIX_PTHREAD_SEMANTICS
-# define EVENT___POSIX_PTHREAD_SEMANTICS 1
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
 #endif
 /* Enable extensions on HP NonStop.  */
-#ifndef EVENT___TANDEM_SOURCE
-# define EVENT___TANDEM_SOURCE 1
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
 #endif
 /* Enable general extensions on Solaris.  */
-#ifndef EVENT____EXTENSIONS__
-# define EVENT____EXTENSIONS__ 1
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
 #endif
 
 
 /* Version number of package */
-#define EVENT__VERSION "2.1.8-stable"
+#define EVENT__VERSION "2.1.12-stable"
 
 /* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef EVENT___DARWIN_USE_64_BIT_INODE
-# define EVENT___DARWIN_USE_64_BIT_INODE 1
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
 #endif
 
 /* Number of bits in a file offset, on hosts where this is settable. */
-/* #undef EVENT___FILE_OFFSET_BITS */
+/* #undef _FILE_OFFSET_BITS */
 
 /* Define for large files, on AIX-style hosts. */
-/* #undef EVENT___LARGE_FILES */
+/* #undef _LARGE_FILES */
 
 /* Define to 1 if on MINIX. */
-/* #undef EVENT___MINIX */
+/* #undef _MINIX */
 
 /* Define to 2 if the system does not provide POSIX.1 features except with
    this defined. */
-/* #undef EVENT___POSIX_1_SOURCE */
+/* #undef _POSIX_1_SOURCE */
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
-/* #undef EVENT___POSIX_SOURCE */
+/* #undef _POSIX_SOURCE */
 
 /* Define to appropriate substitue if compiler doesnt have __func__ */
-/* #undef EVENT____func__ */
+/* #undef __func__ */
 
 /* Define to empty if `const' does not conform to ANSI C. */
-/* #undef EVENT__const */
+/* #undef const */
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef EVENT____cplusplus
-/* #undef EVENT__inline */
+#ifndef __cplusplus
+/* #undef inline */
 #endif
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__pid_t */
+/* #undef pid_t */
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef EVENT__size_t */
+/* #undef size_t */
 
 /* Define to unsigned int if you dont have it */
-/* #undef EVENT__socklen_t */
+/* #undef socklen_t */
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__ssize_t */
+/* #undef ssize_t */
 
 #endif /* event2/event-config.h */
diff --git a/ipc/chromium/src/third_party/libevent/appveyor.yml b/ipc/chromium/src/third_party/libevent/appveyor.yml
deleted file mode 100644
index 6beb5457cbb6..000000000000
--- a/ipc/chromium/src/third_party/libevent/appveyor.yml
+++ /dev/null
@@ -1,60 +0,0 @@
-version: 2.1.8.{build}
-
-os: Visual Studio 2015
-
-build:
-  verbosity: detailed
-
-environment:
-  global:
-    CYG_ROOT: C:/MinGW/msys/1.0
-  matrix:
-    - EVENT_BUILD_METHOD: "autotools"
-      EVENT_CONFIGURE_OPTIONS: ""
-    - EVENT_BUILD_METHOD: "autotools"
-      EVENT_CONFIGURE_OPTIONS: "--disable-openssl"
-    - EVENT_BUILD_METHOD: "autotools"
-      EVENT_CONFIGURE_OPTIONS: "--disable-thread-support"
-    - EVENT_BUILD_METHOD: "autotools"
-      EVENT_CONFIGURE_OPTIONS: "--disable-debug-mode"
-    - EVENT_BUILD_METHOD: "autotools"
-      EVENT_CONFIGURE_OPTIONS: "--disable-malloc-replacement"
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: ""
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: "-DEVENT__DISABLE_OPENSSL=ON"
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: "-DEVENT__DISABLE_THREAD_SUPPORT=ON"
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: "-DEVENT__DISABLE_DEBUG_MODE=ON"
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: "-DEVENT__DISABLE_MM_REPLACEMENT=ON"
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: "-DEVENT__ENABLE_VERBOSE_DEBUG=ON"
-    - EVENT_BUILD_METHOD: "cmake"
-      EVENT_CMAKE_OPTIONS: "-DCMAKE_C_FLAGS='-DUNICODE -D_UNICODE'"
-init:
-  - 'echo Building libevent %version% for Windows'
-  - 'echo System architecture: %PLATFORM%'
-  - 'echo Repo build branch is: %APPVEYOR_REPO_BRANCH%'
-  - 'echo Build folder is: %APPVEYOR_BUILD_FOLDER%'
-  - 'echo Repo build commit is: %APPVEYOR_REPO_COMMIT%'
-  - 'echo Cygwin root is: %CYG_ROOT%'
-install:
-  - C:\MinGW\bin\mingw-get install autotools autoconf automake
-build_script:
-  - ps: |
-      if ($env:EVENT_BUILD_METHOD -eq 'autotools') {
-        $env:PATH="$env:CYG_ROOT\bin;C:\MinGW\bin;$($env:PATH)"
-        bash -lc "echo 'C:\MinGW /mingw' > /etc/fstab"
-        bash -lc "echo 'C:\OpenSSL-Win32 /ssl' >> /etc/fstab"
-        $env:APPVEYOR_BUILD_FOLDER = $env:APPVEYOR_BUILD_FOLDER -replace "\\", "/"
-        bash -lc "exec 0</dev/null; exec 2>&1; cd $env:APPVEYOR_BUILD_FOLDER; bash -x ./autogen.sh && ./configure LDFLAGS='-L/ssl -L/ssl/lib -L/ssl/lib/MinGW' CFLAGS=-I/ssl/include $env:EVENT_CONFIGURE_OPTIONS && make && make verify -j20"
-      } else {
-        md build
-        cd build
-        cmake .. $env:EVENT_CMAKE_OPTIONS
-        cmake --build .
-        $env:CTEST_PARALLEL_LEVEL="20"
-        ctest --output-on-failure
-      }
diff --git a/ipc/chromium/src/third_party/libevent/arc4random.c b/ipc/chromium/src/third_party/libevent/arc4random.c
index a2338e692a10..8729f6b92fe7 100644
--- a/ipc/chromium/src/third_party/libevent/arc4random.c
+++ b/ipc/chromium/src/third_party/libevent/arc4random.c
@@ -54,6 +54,7 @@
 #ifdef _WIN32
 #include <wincrypt.h>
 #include <process.h>
+#include <winerror.h>
 #else
 #include <fcntl.h>
 #include <unistd.h>
@@ -62,6 +63,9 @@
 #ifdef EVENT__HAVE_SYS_SYSCTL_H
 #include <sys/sysctl.h>
 #endif
+#ifdef EVENT__HAVE_SYS_RANDOM_H
+#include <sys/random.h>
+#endif
 #endif
 #include <limits.h>
 #include <stdlib.h>
@@ -89,7 +93,6 @@ static int rs_initialized;
 static struct arc4_stream rs;
 static pid_t arc4_stir_pid;
 static int arc4_count;
-static int arc4_seeded_ok;
 
 static inline unsigned char arc4_getbyte(void);
 
@@ -163,22 +166,15 @@ arc4_seed_win32(void)
 		return -1;
 	arc4_addrandom(buf, sizeof(buf));
 	evutil_memclear_(buf, sizeof(buf));
-	arc4_seeded_ok = 1;
 	return 0;
 }
 #endif
 
-#if defined(EVENT__HAVE_SYS_SYSCTL_H) && defined(EVENT__HAVE_SYSCTL)
-#if EVENT__HAVE_DECL_CTL_KERN && EVENT__HAVE_DECL_KERN_RANDOM && EVENT__HAVE_DECL_RANDOM_UUID
-#define TRY_SEED_SYSCTL_LINUX
+#if defined(EVENT__HAVE_GETRANDOM)
+#define TRY_SEED_GETRANDOM
 static int
-arc4_seed_sysctl_linux(void)
+arc4_seed_getrandom(void)
 {
-	/* Based on code by William Ahern, this function tries to use the
-	 * RANDOM_UUID sysctl to get entropy from the kernel.  This can work
-	 * even if /dev/urandom is inaccessible for some reason (e.g., we're
-	 * running in a chroot). */
-	int mib[] = { CTL_KERN, KERN_RANDOM, RANDOM_UUID };
 	unsigned char buf[ADD_ENTROPY];
 	size_t len, n;
 	unsigned i;
@@ -189,7 +185,7 @@ arc4_seed_sysctl_linux(void)
 	for (len = 0; len < sizeof(buf); len += n) {
 		n = sizeof(buf) - len;
 
-		if (0 != sysctl(mib, 3, &buf[len], &n, NULL, 0))
+		if (0 == getrandom(&buf[len], n, 0))
 			return -1;
 	}
 	/* make sure that the buffer actually got set. */
@@ -201,11 +197,11 @@ arc4_seed_sysctl_linux(void)
 
 	arc4_addrandom(buf, sizeof(buf));
 	evutil_memclear_(buf, sizeof(buf));
-	arc4_seeded_ok = 1;
 	return 0;
 }
-#endif
+#endif /* EVENT__HAVE_GETRANDOM */
 
+#if defined(EVENT__HAVE_SYS_SYSCTL_H) && defined(EVENT__HAVE_SYSCTL)
 #if EVENT__HAVE_DECL_CTL_KERN && EVENT__HAVE_DECL_KERN_ARND
 #define TRY_SEED_SYSCTL_BSD
 static int
@@ -241,7 +237,6 @@ arc4_seed_sysctl_bsd(void)
 
 	arc4_addrandom(buf, sizeof(buf));
 	evutil_memclear_(buf, sizeof(buf));
-	arc4_seeded_ok = 1;
 	return 0;
 }
 #endif
@@ -287,7 +282,6 @@ arc4_seed_proc_sys_kernel_random_uuid(void)
 	}
 	evutil_memclear_(entropy, sizeof(entropy));
 	evutil_memclear_(buf, sizeof(buf));
-	arc4_seeded_ok = 1;
 	return 0;
 }
 #endif
@@ -311,7 +305,6 @@ static int arc4_seed_urandom_helper_(const char *fname)
 		return -1;
 	arc4_addrandom(buf, sizeof(buf));
 	evutil_memclear_(buf, sizeof(buf));
-	arc4_seeded_ok = 1;
 	return 0;
 }
 
@@ -347,6 +340,10 @@ arc4_seed(void)
 	if (0 == arc4_seed_win32())
 		ok = 1;
 #endif
+#ifdef TRY_SEED_GETRANDOM
+	if (0 == arc4_seed_getrandom())
+		ok = 1;
+#endif
 #ifdef TRY_SEED_URANDOM
 	if (0 == arc4_seed_urandom())
 		ok = 1;
@@ -356,12 +353,6 @@ arc4_seed(void)
 	    0 == arc4_seed_proc_sys_kernel_random_uuid())
 		ok = 1;
 #endif
-#ifdef TRY_SEED_SYSCTL_LINUX
-	/* Apparently Linux is deprecating sysctl, and spewing warning
-	 * messages when you try to use it. */
-	if (!ok && 0 == arc4_seed_sysctl_linux())
-		ok = 1;
-#endif
 #ifdef TRY_SEED_SYSCTL_BSD
 	if (0 == arc4_seed_sysctl_bsd())
 		ok = 1;
@@ -379,8 +370,7 @@ arc4_stir(void)
 		rs_initialized = 1;
 	}
 
-	arc4_seed();
-	if (!arc4_seeded_ok)
+	if (0 != arc4_seed())
 		return -1;
 
 	/*
diff --git a/ipc/chromium/src/third_party/libevent/bsd/event2/event-config.h b/ipc/chromium/src/third_party/libevent/bsd/event2/event-config.h
index 7a4578b82b5f..50f20c26091e 100644
--- a/ipc/chromium/src/third_party/libevent/bsd/event2/event-config.h
+++ b/ipc/chromium/src/third_party/libevent/bsd/event2/event-config.h
@@ -24,13 +24,19 @@
 /* #undef EVENT__DISABLE_THREAD_SUPPORT */
 
 /* Define to 1 if you have the `accept4' function. */
-#if !defined(__NetBSD__)
 #define EVENT__HAVE_ACCEPT4 1
-#endif
+
+/* Define to 1 if you have the <afunix.h> header file. */
+/* #undef EVENT__HAVE_AFUNIX_H */
 
 /* Define to 1 if you have the `arc4random' function. */
 #define EVENT__HAVE_ARC4RANDOM 1
 
+/* Define to 1 if you have the `arc4random_addrandom' function. */
+#if defined(__DragonFly__) || defined(__NetBSD__)
+#define EVENT__HAVE_ARC4RANDOM_ADDRANDOM 1
+#endif
+
 /* Define to 1 if you have the `arc4random_buf' function. */
 #define EVENT__HAVE_ARC4RANDOM_BUF 1
 
@@ -48,14 +54,6 @@
    don't. */
 #define EVENT__HAVE_DECL_KERN_ARND 1
 
-/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if you
-   don't. */
-#define EVENT__HAVE_DECL_KERN_RANDOM 0
-
-/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if you
-   don't. */
-#define EVENT__HAVE_DECL_RANDOM_UUID 0
-
 /* Define if /dev/poll is available */
 /* #undef EVENT__HAVE_DEVPOLL */
 
@@ -74,9 +72,6 @@
 /* Define to 1 if you have the <errno.h> header file. */
 #define EVENT__HAVE_ERRNO_H 1
 
-/* Define to 1 if you have ERR_remove_thread_stat(). */
-/* #undef EVENT__HAVE_ERR_REMOVE_THREAD_STATE */
-
 /* Define to 1 if you have the `eventfd' function. */
 /* #undef EVENT__HAVE_EVENTFD */
 
@@ -122,6 +117,11 @@
 /* Define to 1 if you have the `getprotobynumber' function. */
 #define EVENT__HAVE_GETPROTOBYNUMBER 1
 
+/* Define to 1 if you have the `getrandom' function. */
+#if !defined(__OpenBSD__)
+#define EVENT__HAVE_GETRANDOM 1
+#endif
+
 /* Define to 1 if you have the `getservbyname' function. */
 #define EVENT__HAVE_GETSERVBYNAME 1
 
@@ -146,12 +146,18 @@
 /* Define to 1 if you have the `kqueue' function. */
 #define EVENT__HAVE_KQUEUE 1
 
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef EVENT__HAVE_LIBWS2_32 */
+
 /* Define if the system has zlib */
 #define EVENT__HAVE_LIBZ 1
 
 /* Define to 1 if you have the `mach_absolute_time' function. */
 /* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */
 
+/* Define to 1 if you have the <mach/mach.h> header file. */
+/* #undef EVENT__HAVE_MACH_MACH_H */
+
 /* Define to 1 if you have the <mach/mach_time.h> header file. */
 /* #undef EVENT__HAVE_MACH_MACH_TIME_H */
 
@@ -179,6 +185,9 @@
 /* Define if the system has openssl */
 /* #undef EVENT__HAVE_OPENSSL */
 
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+/* #undef EVENT__HAVE_OPENSSL_SSL_H */
+
 /* Define to 1 if you have the `pipe' function. */
 #define EVENT__HAVE_PIPE 1
 
@@ -275,6 +284,9 @@
 /* Define to 1 if `s6_addr32' is a member of `struct in6_addr'. */
 /* #undef EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 */
 
+/* Define to 1 if the system has the type `struct linger'. */
+#define EVENT__HAVE_STRUCT_LINGER 1
+
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
 #define EVENT__HAVE_STRUCT_SOCKADDR_IN6 1
 
@@ -293,8 +305,8 @@
 /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
 /* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
 
-/* Define to 1 if the system has the type `struct so_linger'. */
-#define EVENT__HAVE_STRUCT_SO_LINGER 1
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define EVENT__HAVE_STRUCT_SOCKADDR_UN 1
 
 /* Define to 1 if you have the `sysctl' function. */
 #define EVENT__HAVE_SYSCTL 1
@@ -323,6 +335,11 @@
 /* Define to 1 if you have the <sys/queue.h> header file. */
 #define EVENT__HAVE_SYS_QUEUE_H 1
 
+/* Define to 1 if you have the <sys/random.h> header file. */
+#if !defined(__OpenBSD__)
+#define EVENT__HAVE_SYS_RANDOM_H 1
+#endif
+
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #define EVENT__HAVE_SYS_RESOURCE_H 1
 
@@ -350,6 +367,9 @@
 /* Define to 1 if you have the <sys/types.h> header file. */
 #define EVENT__HAVE_SYS_TYPES_H 1
 
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define EVENT__HAVE_SYS_UN_H 1
+
 /* Define to 1 if you have the <sys/uio.h> header file. */
 #define EVENT__HAVE_SYS_UIO_H 1
 
@@ -404,22 +424,29 @@
 /* Define to 1 if you have the `vasprintf' function. */
 #define EVENT__HAVE_VASPRINTF 1
 
-/* Define if waitpid() supports WNOWAIT */
-#if !defined(__DragonFly__) && !defined(__OpenBSD__)
-#define EVENT__HAVE_WAITPID_WITH_WNOWAIT 1
-#endif
-
 /* Define if kqueue works correctly with pipes */
 #define EVENT__HAVE_WORKING_KQUEUE 1
 
 /* Define to 1 if you have the <zlib.h> header file. */
 #define EVENT__HAVE_ZLIB_H 1
 
+/* Define to 1 if you have the `_gmtime64' function. */
+/* #undef EVENT__HAVE__GMTIME64 */
+
+/* Define to 1 if you have the `_gmtime64_s' function. */
+/* #undef EVENT__HAVE__GMTIME64_S */
+
+/* Define to 1 if compiler have __FUNCTION__ */
+#define EVENT__HAVE___FUNCTION__ 1
+
+/* Define to 1 if compiler have __func__ */
+#define EVENT__HAVE___func__ 1
+
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define EVENT__LT_OBJDIR ".libs/"
 
 /* Numeric representation of the version */
-#define EVENT__NUMERIC_VERSION 0x02010800
+#define EVENT__NUMERIC_VERSION 0x02010c00
 
 /* Name of package */
 #define EVENT__PACKAGE "libevent"
@@ -431,7 +458,7 @@
 #define EVENT__PACKAGE_NAME "libevent"
 
 /* Define to the full name and version of this package. */
-#define EVENT__PACKAGE_STRING "libevent 2.1.8-stable"
+#define EVENT__PACKAGE_STRING "libevent 2.1.12-stable"
 
 /* Define to the one symbol short name of this package. */
 #define EVENT__PACKAGE_TARNAME "libevent"
@@ -440,7 +467,7 @@
 #define EVENT__PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define EVENT__PACKAGE_VERSION "2.1.8-stable"
+#define EVENT__PACKAGE_VERSION "2.1.12-stable"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -484,6 +511,13 @@
 #define EVENT__SIZEOF_SIZE_T 4
 #endif
 
+/* The size of `time_t', as computed by sizeof. */
+#ifdef __LP64__
+#define EVENT__SIZEOF_TIME_T 8
+#else
+#define EVENT__SIZEOF_TIME_T 4
+#endif
+
 /* The size of `void *', as computed by sizeof. */
 #ifdef __LP64__
 #define EVENT__SIZEOF_VOID_P 8
@@ -496,79 +530,79 @@
 /* ------------------------------------------------------------------------ */
 
 /* Define to 1 if you have the ANSI C header files. */
-#define EVENT__STDC_HEADERS 1
+#define STDC_HEADERS 1
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #define EVENT__TIME_WITH_SYS_TIME 1
 
 /* Enable extensions on AIX 3, Interix.  */
-#ifndef EVENT___ALL_SOURCE
-# define EVENT___ALL_SOURCE 1
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
 #endif
 /* Enable GNU extensions on systems that have them.  */
-#ifndef EVENT___GNU_SOURCE
-# define EVENT___GNU_SOURCE 1
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
 #endif
 /* Enable threading extensions on Solaris.  */
-#ifndef EVENT___POSIX_PTHREAD_SEMANTICS
-# define EVENT___POSIX_PTHREAD_SEMANTICS 1
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
 #endif
 /* Enable extensions on HP NonStop.  */
-#ifndef EVENT___TANDEM_SOURCE
-# define EVENT___TANDEM_SOURCE 1
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
 #endif
 /* Enable general extensions on Solaris.  */
-#ifndef EVENT____EXTENSIONS__
-# define EVENT____EXTENSIONS__ 1
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
 #endif
 
 
 /* Version number of package */
-#define EVENT__VERSION "2.1.8-stable"
+#define EVENT__VERSION "2.1.12-stable"
 
 /* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef EVENT___DARWIN_USE_64_BIT_INODE
-# define EVENT___DARWIN_USE_64_BIT_INODE 1
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
 #endif
 
 /* Number of bits in a file offset, on hosts where this is settable. */
-/* #undef EVENT___FILE_OFFSET_BITS */
+/* #undef _FILE_OFFSET_BITS */
 
 /* Define for large files, on AIX-style hosts. */
-/* #undef EVENT___LARGE_FILES */
+/* #undef _LARGE_FILES */
 
 /* Define to 1 if on MINIX. */
-/* #undef EVENT___MINIX */
+/* #undef _MINIX */
 
 /* Define to 2 if the system does not provide POSIX.1 features except with
    this defined. */
-/* #undef EVENT___POSIX_1_SOURCE */
+/* #undef _POSIX_1_SOURCE */
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
-/* #undef EVENT___POSIX_SOURCE */
+/* #undef _POSIX_SOURCE */
 
 /* Define to appropriate substitue if compiler doesnt have __func__ */
-/* #undef EVENT____func__ */
+/* #undef __func__ */
 
 /* Define to empty if `const' does not conform to ANSI C. */
-/* #undef EVENT__const */
+/* #undef const */
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef EVENT____cplusplus
-/* #undef EVENT__inline */
+#ifndef __cplusplus
+/* #undef inline */
 #endif
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__pid_t */
+/* #undef pid_t */
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef EVENT__size_t */
+/* #undef size_t */
 
 /* Define to unsigned int if you dont have it */
-/* #undef EVENT__socklen_t */
+/* #undef socklen_t */
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__ssize_t */
+/* #undef ssize_t */
 
 #endif /* event2/event-config.h */
diff --git a/ipc/chromium/src/third_party/libevent/buffer.c b/ipc/chromium/src/third_party/libevent/buffer.c
index b7e3a69f4b20..3524b3504d43 100644
--- a/ipc/chromium/src/third_party/libevent/buffer.c
+++ b/ipc/chromium/src/third_party/libevent/buffer.c
@@ -95,6 +95,7 @@
 #include "evthread-internal.h"
 #include "evbuffer-internal.h"
 #include "bufferevent-internal.h"
+#include "event-internal.h"
 
 /* some systems do not have MAP_FAILED */
 #ifndef MAP_FAILED
@@ -522,8 +523,8 @@ evbuffer_invoke_callbacks_(struct evbuffer *buffer)
 			evbuffer_incref_and_lock_(buffer);
 			if (buffer->parent)
 				bufferevent_incref_(buffer->parent);
+			EVBUFFER_UNLOCK(buffer);
 		}
-		EVBUFFER_UNLOCK(buffer);
 	}
 
 	evbuffer_run_callbacks(buffer, 0);
@@ -703,13 +704,17 @@ static int
 advance_last_with_data(struct evbuffer *buf)
 {
 	int n = 0;
+	struct evbuffer_chain **chainp = buf->last_with_datap;
+
 	ASSERT_EVBUFFER_LOCKED(buf);
 
-	if (!*buf->last_with_datap)
+	if (!*chainp)
 		return 0;
 
-	while ((*buf->last_with_datap)->next && (*buf->last_with_datap)->next->off) {
-		buf->last_with_datap = &(*buf->last_with_datap)->next;
+	while ((*chainp)->next) {
+		chainp = &(*chainp)->next;
+		if ((*chainp)->off)
+			buf->last_with_datap = chainp;
 		++n;
 	}
 	return n;
@@ -1146,7 +1151,7 @@ evbuffer_drain(struct evbuffer *buf, size_t len)
 		}
 
 		buf->first = chain;
-		EVUTIL_ASSERT(chain && remaining <= chain->off);
+		EVUTIL_ASSERT(remaining <= chain->off);
 		chain->misalign += remaining;
 		chain->off -= remaining;
 	}
@@ -1298,7 +1303,7 @@ evbuffer_remove_buffer(struct evbuffer *src, struct evbuffer *dst,
 		chain = chain->next;
 	}
 
-	if (nread) {
+	if (chain != src->first) {
 		/* we can remove the chain */
 		struct evbuffer_chain **chp;
 		chp = evbuffer_free_trailing_empty_chains(dst);
@@ -1416,9 +1421,11 @@ evbuffer_pullup(struct evbuffer *buf, ev_ssize_t size)
 	for (; chain != NULL && (size_t)size >= chain->off; chain = next) {
 		next = chain->next;
 
-		memcpy(buffer, chain->buffer + chain->misalign, chain->off);
-		size -= chain->off;
-		buffer += chain->off;
+		if (chain->buffer) {
+			memcpy(buffer, chain->buffer + chain->misalign, chain->off);
+			size -= chain->off;
+			buffer += chain->off;
+		}
 		if (chain == last_with_data)
 			removed_last_with_data = 1;
 		if (&chain->next == buf->last_with_datap)
@@ -1534,11 +1541,11 @@ evbuffer_find_eol_char(struct evbuffer_ptr *it)
 	return (-1);
 }
 
-static inline int
+static inline size_t
 evbuffer_strspn(
 	struct evbuffer_ptr *ptr, const char *chrset)
 {
-	int count = 0;
+	size_t count = 0;
 	struct evbuffer_chain *chain = ptr->internal_.chain;
 	size_t i = ptr->internal_.pos_in_chain;
 
@@ -1824,6 +1831,10 @@ evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen)
 
 	EVBUFFER_LOCK(buf);
 
+	if (datlen == 0) {
+		result = 0;
+		goto done;
+	}
 	if (buf->freeze_start) {
 		goto done;
 	}
@@ -1877,7 +1888,7 @@ evbuffer_prepend(struct evbuffer *buf, const void *data, size_t datlen)
 	if ((tmp = evbuffer_chain_new(datlen)) == NULL)
 		goto done;
 	buf->first = tmp;
-	if (buf->last_with_datap == &buf->first)
+	if (buf->last_with_datap == &buf->first && chain->off)
 		buf->last_with_datap = &tmp->next;
 
 	tmp->next = chain;
@@ -2227,11 +2238,13 @@ evbuffer_read_setup_vecs_(struct evbuffer *buf, ev_ssize_t howmuch,
 	so_far = 0;
 	/* Let firstchain be the first chain with any space on it */
 	firstchainp = buf->last_with_datap;
+	EVUTIL_ASSERT(*firstchainp);
 	if (CHAIN_SPACE_LEN(*firstchainp) == 0) {
 		firstchainp = &(*firstchainp)->next;
 	}
 
 	chain = *firstchainp;
+	EVUTIL_ASSERT(chain);
 	for (i = 0; i < n_vecs_avail && so_far < (size_t)howmuch; ++i) {
 		size_t avail = (size_t) CHAIN_SPACE_LEN(chain);
 		if (avail > (howmuch - so_far) && exact)
@@ -2465,7 +2478,7 @@ evbuffer_write_sendfile(struct evbuffer *buffer, evutil_socket_t dest_fd,
 	ev_off_t len = chain->off;
 #elif defined(SENDFILE_IS_LINUX) || defined(SENDFILE_IS_SOLARIS)
 	ev_ssize_t res;
-	ev_off_t offset = chain->misalign;
+	off_t offset = chain->misalign;
 #endif
 
 	ASSERT_EVBUFFER_LOCKED(buffer);
@@ -3198,7 +3211,6 @@ evbuffer_add_file_segment(struct evbuffer *buf,
 			}
 		}
 	}
-	++seg->refcnt;
 	EVLOCK_UNLOCK(seg->lock, 0);
 
 	if (buf->freeze_end)
@@ -3262,6 +3274,9 @@ evbuffer_add_file_segment(struct evbuffer *buf,
 		chain->off = length;
 	}
 
+	EVLOCK_LOCK(seg->lock, 0);
+	++seg->refcnt;
+	EVLOCK_UNLOCK(seg->lock, 0);
 	extra->segment = seg;
 	buf->n_add_for_cb += length;
 	evbuffer_chain_insert(buf, chain);
@@ -3293,7 +3308,7 @@ evbuffer_add_file(struct evbuffer *buf, int fd, ev_off_t offset, ev_off_t length
 	return r;
 }
 
-void
+int
 evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)
 {
 	EVBUFFER_LOCK(buffer);
@@ -3304,10 +3319,15 @@ evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg)
 	if (cb) {
 		struct evbuffer_cb_entry *ent =
 		    evbuffer_add_cb(buffer, NULL, cbarg);
+		if (!ent) {
+			EVBUFFER_UNLOCK(buffer);
+			return -1;
+		}
 		ent->cb.cb_obsolete = cb;
 		ent->flags |= EVBUFFER_CB_OBSOLETE;
 	}
 	EVBUFFER_UNLOCK(buffer);
+	return 0;
 }
 
 struct evbuffer_cb_entry *
diff --git a/ipc/chromium/src/third_party/libevent/buffer_iocp.c b/ipc/chromium/src/third_party/libevent/buffer_iocp.c
index 2d76a90e7702..2af0c49cc64b 100644
--- a/ipc/chromium/src/third_party/libevent/buffer_iocp.c
+++ b/ipc/chromium/src/third_party/libevent/buffer_iocp.c
@@ -44,6 +44,7 @@
 #include "mm-internal.h"
 
 #include <winsock2.h>
+#include <winerror.h>
 #include <windows.h>
 #include <stdio.h>
 
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent-internal.h b/ipc/chromium/src/third_party/libevent/bufferevent-internal.h
index 9960aefa5d10..87ab9ad9c0f7 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent-internal.h
+++ b/ipc/chromium/src/third_party/libevent/bufferevent-internal.h
@@ -306,6 +306,13 @@ extern const struct bufferevent_ops bufferevent_ops_pair;
 #define BEV_IS_FILTER(bevp) ((bevp)->be_ops == &bufferevent_ops_filter)
 #define BEV_IS_PAIR(bevp) ((bevp)->be_ops == &bufferevent_ops_pair)
 
+#if defined(EVENT__HAVE_OPENSSL)
+extern const struct bufferevent_ops bufferevent_ops_openssl;
+#define BEV_IS_OPENSSL(bevp) ((bevp)->be_ops == &bufferevent_ops_openssl)
+#else
+#define BEV_IS_OPENSSL(bevp) 0
+#endif
+
 #ifdef _WIN32
 extern const struct bufferevent_ops bufferevent_ops_async;
 #define BEV_IS_ASYNC(bevp) ((bevp)->be_ops == &bufferevent_ops_async)
@@ -314,13 +321,16 @@ extern const struct bufferevent_ops bufferevent_ops_async;
 #endif
 
 /** Initialize the shared parts of a bufferevent. */
+EVENT2_EXPORT_SYMBOL
 int bufferevent_init_common_(struct bufferevent_private *, struct event_base *, const struct bufferevent_ops *, enum bufferevent_options options);
 
 /** For internal use: temporarily stop all reads on bufev, until the conditions
  * in 'what' are over. */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_suspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags what);
 /** For internal use: clear the conditions 'what' on bufev, and re-enable
  * reading if there are no conditions left. */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_unsuspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags what);
 
 /** For internal use: temporarily stop all writes on bufev, until the conditions
@@ -347,16 +357,19 @@ void bufferevent_unsuspend_write_(struct bufferevent *bufev, bufferevent_suspend
   @return 0 if successful, or -1 if an error occurred
   @see bufferevent_disable()
  */
+EVENT2_EXPORT_SYMBOL
 int bufferevent_disable_hard_(struct bufferevent *bufev, short event);
 
 /** Internal: Set up locking on a bufferevent.  If lock is set, use it.
  * Otherwise, use a new lock. */
+EVENT2_EXPORT_SYMBOL
 int bufferevent_enable_locking_(struct bufferevent *bufev, void *lock);
 /** Internal: backwards compat macro for the now public function
  * Increment the reference count on bufev. */
 #define bufferevent_incref_(bufev) bufferevent_incref(bufev)
 /** Internal: Lock bufev and increase its reference count.
  * unlocking it otherwise. */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_incref_and_lock_(struct bufferevent *bufev);
 /** Internal: backwards compat macro for the now public function
  * Decrement the reference count on bufev.  Returns 1 if it freed
@@ -365,17 +378,21 @@ void bufferevent_incref_and_lock_(struct bufferevent *bufev);
 
 /** Internal: Drop the reference count on bufev, freeing as necessary, and
  * unlocking it otherwise.  Returns 1 if it freed the bufferevent. */
+EVENT2_EXPORT_SYMBOL
 int bufferevent_decref_and_unlock_(struct bufferevent *bufev);
 
 /** Internal: If callbacks are deferred and we have a read callback, schedule
  * a readcb.  Otherwise just run the readcb. Ignores watermarks. */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_run_readcb_(struct bufferevent *bufev, int options);
 /** Internal: If callbacks are deferred and we have a write callback, schedule
  * a writecb.  Otherwise just run the writecb. Ignores watermarks. */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_run_writecb_(struct bufferevent *bufev, int options);
 /** Internal: If callbacks are deferred and we have an eventcb, schedule
  * it to run with events "what".  Otherwise just run the eventcb.
  * See bufferevent_trigger_event for meaning of "options". */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_run_eventcb_(struct bufferevent *bufev, short what, int options);
 
 /** Internal: Run or schedule (if deferred or options contain
@@ -399,6 +416,7 @@ bufferevent_trigger_nolock_(struct bufferevent *bufev, short iotype, int options
 
 /** Internal: Add the event 'ev' with timeout tv, unless tv is set to 0, in
  * which case add ev with no timeout. */
+EVENT2_EXPORT_SYMBOL
 int bufferevent_add_event_(struct event *ev, const struct timeval *tv);
 
 /* =========
@@ -408,19 +426,33 @@ int bufferevent_add_event_(struct event *ev, const struct timeval *tv);
 /** Internal use: Set up the ev_read and ev_write callbacks so that
  * the other "generic_timeout" functions will work on it.  Call this from
  * the constructor function. */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_init_generic_timeout_cbs_(struct bufferevent *bev);
 /** Internal use: Add or delete the generic timeout events as appropriate.
  * (If an event is enabled and a timeout is set, we add the event.  Otherwise
  * we delete it.)  Call this from anything that changes the timeout values,
  * that enabled EV_READ or EV_WRITE, or that disables EV_READ or EV_WRITE. */
+EVENT2_EXPORT_SYMBOL
 int bufferevent_generic_adj_timeouts_(struct bufferevent *bev);
+EVENT2_EXPORT_SYMBOL
 int bufferevent_generic_adj_existing_timeouts_(struct bufferevent *bev);
 
+EVENT2_EXPORT_SYMBOL
 enum bufferevent_options bufferevent_get_options_(struct bufferevent *bev);
 
+EVENT2_EXPORT_SYMBOL
 const struct sockaddr*
 bufferevent_socket_get_conn_address_(struct bufferevent *bev);
 
+EVENT2_EXPORT_SYMBOL
+void
+bufferevent_socket_set_conn_address_fd_(struct bufferevent *bev, evutil_socket_t fd);
+
+EVENT2_EXPORT_SYMBOL
+void
+bufferevent_socket_set_conn_address_(struct bufferevent *bev, struct sockaddr *addr, size_t addrlen);
+
+
 /** Internal use: We have just successfully read data into an inbuf, so
  * reset the read timeout (if any). */
 #define BEV_RESET_GENERIC_READ_TIMEOUT(bev)				\
@@ -465,11 +497,15 @@ bufferevent_socket_get_conn_address_(struct bufferevent *bev);
 
 /* ==== For rate-limiting. */
 
+EVENT2_EXPORT_SYMBOL
 int bufferevent_decrement_write_buckets_(struct bufferevent_private *bev,
     ev_ssize_t bytes);
+EVENT2_EXPORT_SYMBOL
 int bufferevent_decrement_read_buckets_(struct bufferevent_private *bev,
     ev_ssize_t bytes);
+EVENT2_EXPORT_SYMBOL
 ev_ssize_t bufferevent_get_read_max_(struct bufferevent_private *bev);
+EVENT2_EXPORT_SYMBOL
 ev_ssize_t bufferevent_get_write_max_(struct bufferevent_private *bev);
 
 int bufferevent_ratelim_init_(struct bufferevent_private *bev);
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent.c b/ipc/chromium/src/third_party/libevent/bufferevent.c
index 490b59839cca..08c0486c087d 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent.c
@@ -66,8 +66,7 @@ static void bufferevent_finalize_cb_(struct event_callback *evcb, void *arg_);
 void
 bufferevent_suspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags what)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	BEV_LOCK(bufev);
 	if (!bufev_private->read_suspended)
 		bufev->be_ops->disable(bufev, EV_READ);
@@ -78,8 +77,7 @@ bufferevent_suspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags w
 void
 bufferevent_unsuspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags what)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	BEV_LOCK(bufev);
 	bufev_private->read_suspended &= ~what;
 	if (!bufev_private->read_suspended && (bufev->enabled & EV_READ))
@@ -90,8 +88,7 @@ bufferevent_unsuspend_read_(struct bufferevent *bufev, bufferevent_suspend_flags
 void
 bufferevent_suspend_write_(struct bufferevent *bufev, bufferevent_suspend_flags what)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	BEV_LOCK(bufev);
 	if (!bufev_private->write_suspended)
 		bufev->be_ops->disable(bufev, EV_WRITE);
@@ -102,8 +99,7 @@ bufferevent_suspend_write_(struct bufferevent *bufev, bufferevent_suspend_flags
 void
 bufferevent_unsuspend_write_(struct bufferevent *bufev, bufferevent_suspend_flags what)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	BEV_LOCK(bufev);
 	bufev_private->write_suspended &= ~what;
 	if (!bufev_private->write_suspended && (bufev->enabled & EV_WRITE))
@@ -111,6 +107,28 @@ bufferevent_unsuspend_write_(struct bufferevent *bufev, bufferevent_suspend_flag
 	BEV_UNLOCK(bufev);
 }
 
+/**
+ * Sometimes bufferevent's implementation can overrun high watermarks
+ * (one of examples is openssl) and in this case if the read callback
+ * will not handle enough data do over condition above the read
+ * callback will never be called again (due to suspend above).
+ *
+ * To avoid this we are scheduling read callback again here, but only
+ * from the user callback to avoid multiple scheduling:
+ * - when the data had been added to it
+ * - when the data had been drained from it (user specified read callback)
+ */
+static void bufferevent_inbuf_wm_check(struct bufferevent *bev)
+{
+	if (!bev->wm_read.high)
+		return;
+	if (!(bev->enabled & EV_READ))
+		return;
+	if (evbuffer_get_length(bev->input) < bev->wm_read.high)
+		return;
+
+	bufferevent_trigger(bev, EV_READ, BEV_OPT_DEFER_CALLBACKS);
+}
 
 /* Callback to implement watermarks on the input buffer.  Only enabled
  * if the watermark is set. */
@@ -147,6 +165,7 @@ bufferevent_run_deferred_callbacks_locked(struct event_callback *cb, void *arg)
 	if (bufev_private->readcb_pending && bufev->readcb) {
 		bufev_private->readcb_pending = 0;
 		bufev->readcb(bufev, bufev->cbarg);
+		bufferevent_inbuf_wm_check(bufev);
 	}
 	if (bufev_private->writecb_pending && bufev->writecb) {
 		bufev_private->writecb_pending = 0;
@@ -187,6 +206,7 @@ bufferevent_run_deferred_callbacks_unlocked(struct event_callback *cb, void *arg
 		void *cbarg = bufev->cbarg;
 		bufev_private->readcb_pending = 0;
 		UNLOCKED(readcb(bufev, cbarg));
+		bufferevent_inbuf_wm_check(bufev);
 	}
 	if (bufev_private->writecb_pending && bufev->writecb) {
 		bufferevent_data_cb writecb = bufev->writecb;
@@ -221,8 +241,7 @@ void
 bufferevent_run_readcb_(struct bufferevent *bufev, int options)
 {
 	/* Requires that we hold the lock and a reference */
-	struct bufferevent_private *p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *p = BEV_UPCAST(bufev);
 	if (bufev->readcb == NULL)
 		return;
 	if ((p->options|options) & BEV_OPT_DEFER_CALLBACKS) {
@@ -230,6 +249,7 @@ bufferevent_run_readcb_(struct bufferevent *bufev, int options)
 		SCHEDULE_DEFERRED(p);
 	} else {
 		bufev->readcb(bufev, bufev->cbarg);
+		bufferevent_inbuf_wm_check(bufev);
 	}
 }
 
@@ -237,8 +257,7 @@ void
 bufferevent_run_writecb_(struct bufferevent *bufev, int options)
 {
 	/* Requires that we hold the lock and a reference */
-	struct bufferevent_private *p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *p = BEV_UPCAST(bufev);
 	if (bufev->writecb == NULL)
 		return;
 	if ((p->options|options) & BEV_OPT_DEFER_CALLBACKS) {
@@ -266,8 +285,7 @@ void
 bufferevent_run_eventcb_(struct bufferevent *bufev, short what, int options)
 {
 	/* Requires that we hold the lock and a reference */
-	struct bufferevent_private *p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *p = BEV_UPCAST(bufev);
 	if (bufev->errorcb == NULL)
 		return;
 	if ((p->options|options) & BEV_OPT_DEFER_CALLBACKS) {
@@ -297,14 +315,12 @@ bufferevent_init_common_(struct bufferevent_private *bufev_private,
 
 	if (!bufev->input) {
 		if ((bufev->input = evbuffer_new()) == NULL)
-			return -1;
+			goto err;
 	}
 
 	if (!bufev->output) {
-		if ((bufev->output = evbuffer_new()) == NULL) {
-			evbuffer_free(bufev->input);
-			return -1;
-		}
+		if ((bufev->output = evbuffer_new()) == NULL)
+			goto err;
 	}
 
 	bufev_private->refcnt = 1;
@@ -316,7 +332,8 @@ bufferevent_init_common_(struct bufferevent_private *bufev_private,
 
 	bufev->be_ops = ops;
 
-	bufferevent_ratelim_init_(bufev_private);
+	if (bufferevent_ratelim_init_(bufev_private))
+		goto err;
 
 	/*
 	 * Set to EV_WRITE so that using bufferevent_write is going to
@@ -327,20 +344,14 @@ bufferevent_init_common_(struct bufferevent_private *bufev_private,
 
 #ifndef EVENT__DISABLE_THREAD_SUPPORT
 	if (options & BEV_OPT_THREADSAFE) {
-		if (bufferevent_enable_locking_(bufev, NULL) < 0) {
-			/* cleanup */
-			evbuffer_free(bufev->input);
-			evbuffer_free(bufev->output);
-			bufev->input = NULL;
-			bufev->output = NULL;
-			return -1;
-		}
+		if (bufferevent_enable_locking_(bufev, NULL) < 0)
+			goto err;
 	}
 #endif
 	if ((options & (BEV_OPT_DEFER_CALLBACKS|BEV_OPT_UNLOCK_CALLBACKS))
 	    == BEV_OPT_UNLOCK_CALLBACKS) {
 		event_warnx("UNLOCK_CALLBACKS requires DEFER_CALLBACKS");
-		return -1;
+		goto err;
 	}
 	if (options & BEV_OPT_UNLOCK_CALLBACKS)
 		event_deferred_cb_init_(
@@ -361,6 +372,17 @@ bufferevent_init_common_(struct bufferevent_private *bufev_private,
 	evbuffer_set_parent_(bufev->output, bufev);
 
 	return 0;
+
+err:
+	if (bufev->input) {
+		evbuffer_free(bufev->input);
+		bufev->input = NULL;
+	}
+	if (bufev->output) {
+		evbuffer_free(bufev->output);
+		bufev->output = NULL;
+	}
+	return -1;
 }
 
 void
@@ -459,8 +481,7 @@ bufferevent_read_buffer(struct bufferevent *bufev, struct evbuffer *buf)
 int
 bufferevent_enable(struct bufferevent *bufev, short event)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	short impl_events = event;
 	int r = 0;
 
@@ -474,6 +495,8 @@ bufferevent_enable(struct bufferevent *bufev, short event)
 
 	if (impl_events && bufev->be_ops->enable(bufev, impl_events) < 0)
 		r = -1;
+	if (r)
+		event_debug(("%s: cannot enable 0x%hx on %p", __func__, event, bufev));
 
 	bufferevent_decref_and_unlock_(bufev);
 	return r;
@@ -533,8 +556,7 @@ int
 bufferevent_disable_hard_(struct bufferevent *bufev, short event)
 {
 	int r = 0;
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 
 	BEV_LOCK(bufev);
 	bufev->enabled &= ~event;
@@ -557,6 +579,8 @@ bufferevent_disable(struct bufferevent *bufev, short event)
 
 	if (bufev->be_ops->disable(bufev, event) < 0)
 		r = -1;
+	if (r)
+		event_debug(("%s: cannot disable 0x%hx on %p", __func__, event, bufev));
 
 	BEV_UNLOCK(bufev);
 	return r;
@@ -570,8 +594,7 @@ void
 bufferevent_setwatermark(struct bufferevent *bufev, short events,
     size_t lowmark, size_t highmark)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 
 	BEV_LOCK(bufev);
 	if (events & EV_WRITE) {
@@ -656,8 +679,7 @@ bufferevent_flush(struct bufferevent *bufev,
 void
 bufferevent_incref_and_lock_(struct bufferevent *bufev)
 {
-	struct bufferevent_private *bufev_private =
-	    BEV_UPCAST(bufev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	BEV_LOCK(bufev);
 	++bufev_private->refcnt;
 }
@@ -683,8 +705,7 @@ bufferevent_transfer_lock_ownership_(struct bufferevent *donor,
 int
 bufferevent_decref_and_unlock_(struct bufferevent *bufev)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 	int n_cbs = 0;
 #define MAX_CBS 16
 	struct event_callback *cbs[MAX_CBS];
@@ -727,8 +748,7 @@ bufferevent_finalize_cb_(struct event_callback *evcb, void *arg_)
 {
 	struct bufferevent *bufev = arg_;
 	struct bufferevent *underlying;
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 
 	BEV_LOCK(bufev);
 	underlying = bufferevent_get_underlying(bufev);
@@ -794,8 +814,7 @@ bufferevent_free(struct bufferevent *bufev)
 void
 bufferevent_incref(struct bufferevent *bufev)
 {
-	struct bufferevent_private *bufev_private =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_private = BEV_UPCAST(bufev);
 
 	/* XXX: now that this function is public, we might want to
 	 * - return the count from this function
@@ -851,6 +870,8 @@ bufferevent_setfd(struct bufferevent *bev, evutil_socket_t fd)
 	BEV_LOCK(bev);
 	if (bev->be_ops->ctrl)
 		res = bev->be_ops->ctrl(bev, BEV_CTRL_SET_FD, &d);
+	if (res)
+		event_debug(("%s: cannot set fd for %p to "EV_SOCK_FMT, __func__, bev, fd));
 	BEV_UNLOCK(bev);
 	return res;
 }
@@ -864,6 +885,8 @@ bufferevent_getfd(struct bufferevent *bev)
 	BEV_LOCK(bev);
 	if (bev->be_ops->ctrl)
 		res = bev->be_ops->ctrl(bev, BEV_CTRL_GET_FD, &d);
+	if (res)
+		event_debug(("%s: cannot get fd for %p", __func__, bev));
 	BEV_UNLOCK(bev);
 	return (res<0) ? -1 : d.fd;
 }
@@ -871,8 +894,7 @@ bufferevent_getfd(struct bufferevent *bev)
 enum bufferevent_options
 bufferevent_get_options_(struct bufferevent *bev)
 {
-	struct bufferevent_private *bev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 	enum bufferevent_options options;
 
 	BEV_LOCK(bev);
@@ -948,8 +970,7 @@ int
 bufferevent_generic_adj_timeouts_(struct bufferevent *bev)
 {
 	const short enabled = bev->enabled;
-	struct bufferevent_private *bev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 	int r1=0, r2=0;
 	if ((enabled & EV_READ) && !bev_p->read_suspended &&
 	    evutil_timerisset(&bev->timeout_read))
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent_async.c b/ipc/chromium/src/third_party/libevent/bufferevent_async.c
index 6395e57a9f0c..40c7c5e8d0d3 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent_async.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent_async.c
@@ -46,6 +46,7 @@
 
 #ifdef _WIN32
 #include <winsock2.h>
+#include <winerror.h>
 #include <ws2tcpip.h>
 #endif
 
@@ -100,11 +101,32 @@ const struct bufferevent_ops bufferevent_ops_async = {
 	be_async_ctrl,
 };
 
+static inline void
+be_async_run_eventcb(struct bufferevent *bev, short what, int options)
+{ bufferevent_run_eventcb_(bev, what, options|BEV_TRIG_DEFER_CALLBACKS); }
+
+static inline void
+be_async_trigger_nolock(struct bufferevent *bev, short what, int options)
+{ bufferevent_trigger_nolock_(bev, what, options|BEV_TRIG_DEFER_CALLBACKS); }
+
+static inline int
+fatal_error(int err)
+{
+	switch (err) {
+		/* We may have already associated this fd with a port.
+		 * Let's hope it's this port, and that the error code
+		 * for doing this neer changes. */
+		case ERROR_INVALID_PARAMETER:
+			return 0;
+	}
+	return 1;
+}
+
 static inline struct bufferevent_async *
 upcast(struct bufferevent *bev)
 {
 	struct bufferevent_async *bev_a;
-	if (bev->be_ops != &bufferevent_ops_async)
+	if (!BEV_IS_ASYNC(bev))
 		return NULL;
 	bev_a = EVUTIL_UPCAST(bev, struct bufferevent_async, bev.bev);
 	return bev_a;
@@ -217,7 +239,7 @@ bev_async_consider_writing(struct bufferevent_async *beva)
 	    &beva->write_overlapped)) {
 		bufferevent_decref_(bev);
 		beva->ok = 0;
-		bufferevent_run_eventcb_(bev, BEV_EVENT_ERROR, 0);
+		be_async_run_eventcb(bev, BEV_EVENT_ERROR, 0);
 	} else {
 		beva->write_in_progress = at_most;
 		bufferevent_decrement_write_buckets_(&beva->bev, at_most);
@@ -270,7 +292,7 @@ bev_async_consider_reading(struct bufferevent_async *beva)
 	bufferevent_incref_(bev);
 	if (evbuffer_launch_read_(bev->input, at_most, &beva->read_overlapped)) {
 		beva->ok = 0;
-		bufferevent_run_eventcb_(bev, BEV_EVENT_ERROR, 0);
+		be_async_run_eventcb(bev, BEV_EVENT_ERROR, 0);
 		bufferevent_decref_(bev);
 	} else {
 		beva->read_in_progress = at_most;
@@ -381,10 +403,10 @@ be_async_destruct(struct bufferevent *bev)
 	bev_async_del_write(bev_async);
 
 	fd = evbuffer_overlapped_get_fd_(bev->input);
-	if (fd != (evutil_socket_t)INVALID_SOCKET &&
+	if (fd != (evutil_socket_t)EVUTIL_INVALID_SOCKET &&
 		(bev_p->options & BEV_OPT_CLOSE_ON_FREE)) {
 		evutil_closesocket(fd);
-		evbuffer_overlapped_set_fd_(bev->input, INVALID_SOCKET);
+		evbuffer_overlapped_set_fd_(bev->input, EVUTIL_INVALID_SOCKET);
 	}
 }
 
@@ -428,8 +450,7 @@ connect_complete(struct event_overlapped *eo, ev_uintptr_t key,
 	else
 		bev_async_set_wsa_error(bev, eo);
 
-	bufferevent_run_eventcb_(bev,
-			ok? BEV_EVENT_CONNECTED : BEV_EVENT_ERROR, 0);
+	be_async_run_eventcb(bev, ok ? BEV_EVENT_CONNECTED : BEV_EVENT_ERROR, 0);
 
 	event_base_del_virtual_(bev->ev_base);
 
@@ -459,16 +480,16 @@ read_complete(struct event_overlapped *eo, ev_uintptr_t key,
 	if (bev_a->ok) {
 		if (ok && nbytes) {
 			BEV_RESET_GENERIC_READ_TIMEOUT(bev);
-			bufferevent_trigger_nolock_(bev, EV_READ, 0);
+			be_async_trigger_nolock(bev, EV_READ, 0);
 			bev_async_consider_reading(bev_a);
 		} else if (!ok) {
 			what |= BEV_EVENT_ERROR;
 			bev_a->ok = 0;
-			bufferevent_run_eventcb_(bev, what, 0);
+			be_async_run_eventcb(bev, what, 0);
 		} else if (!nbytes) {
 			what |= BEV_EVENT_EOF;
 			bev_a->ok = 0;
-			bufferevent_run_eventcb_(bev, what, 0);
+			be_async_run_eventcb(bev, what, 0);
 		}
 	}
 
@@ -502,16 +523,16 @@ write_complete(struct event_overlapped *eo, ev_uintptr_t key,
 	if (bev_a->ok) {
 		if (ok && nbytes) {
 			BEV_RESET_GENERIC_WRITE_TIMEOUT(bev);
-			bufferevent_trigger_nolock_(bev, EV_WRITE, 0);
+			be_async_trigger_nolock(bev, EV_WRITE, 0);
 			bev_async_consider_writing(bev_a);
 		} else if (!ok) {
 			what |= BEV_EVENT_ERROR;
 			bev_a->ok = 0;
-			bufferevent_run_eventcb_(bev, what, 0);
+			be_async_run_eventcb(bev, what, 0);
 		} else if (!nbytes) {
 			what |= BEV_EVENT_EOF;
 			bev_a->ok = 0;
-			bufferevent_run_eventcb_(bev, what, 0);
+			be_async_run_eventcb(bev, what, 0);
 		}
 	}
 
@@ -532,11 +553,7 @@ bufferevent_async_new_(struct event_base *base,
 		return NULL;
 
 	if (fd >= 0 && event_iocp_port_associate_(iocp, fd, 1)<0) {
-		int err = GetLastError();
-		/* We may have alrady associated this fd with a port.
-		 * Let's hope it's this port, and that the error code
-		 * for doing this neer changes. */
-		if (err != ERROR_INVALID_PARAMETER)
+		if (fatal_error(GetLastError()))
 			return NULL;
 	}
 
@@ -580,7 +597,6 @@ bufferevent_async_set_connected_(struct bufferevent *bev)
 {
 	struct bufferevent_async *bev_async = upcast(bev);
 	bev_async->ok = 1;
-	bufferevent_init_generic_timeout_cbs_(bev);
 	/* Now's a good time to consider reading/writing */
 	be_async_enable(bev, bev->enabled);
 }
@@ -654,25 +670,29 @@ be_async_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,
 		data->fd = evbuffer_overlapped_get_fd_(bev->input);
 		return 0;
 	case BEV_CTRL_SET_FD: {
+		struct bufferevent_async *bev_a = upcast(bev);
 		struct event_iocp_port *iocp;
 
 		if (data->fd == evbuffer_overlapped_get_fd_(bev->input))
 			return 0;
 		if (!(iocp = event_base_get_iocp_(bev->ev_base)))
 			return -1;
-		if (event_iocp_port_associate_(iocp, data->fd, 1) < 0)
-			return -1;
+		if (event_iocp_port_associate_(iocp, data->fd, 1) < 0) {
+			if (fatal_error(GetLastError()))
+				return -1;
+		}
 		evbuffer_overlapped_set_fd_(bev->input, data->fd);
 		evbuffer_overlapped_set_fd_(bev->output, data->fd);
+		bev_a->ok = data->fd >= 0;
 		return 0;
 	}
 	case BEV_CTRL_CANCEL_ALL: {
 		struct bufferevent_async *bev_a = upcast(bev);
 		evutil_socket_t fd = evbuffer_overlapped_get_fd_(bev->input);
-		if (fd != (evutil_socket_t)INVALID_SOCKET &&
+		if (fd != (evutil_socket_t)EVUTIL_INVALID_SOCKET &&
 		    (bev_a->bev.options & BEV_OPT_CLOSE_ON_FREE)) {
 			closesocket(fd);
-			evbuffer_overlapped_set_fd_(bev->input, INVALID_SOCKET);
+			evbuffer_overlapped_set_fd_(bev->input, EVUTIL_INVALID_SOCKET);
 		}
 		bev_a->ok = 0;
 		return 0;
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent_filter.c b/ipc/chromium/src/third_party/libevent/bufferevent_filter.c
index d47f9452bbd2..a7bdedddfe1d 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent_filter.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent_filter.c
@@ -118,11 +118,11 @@ static inline struct bufferevent_filtered *
 upcast(struct bufferevent *bev)
 {
 	struct bufferevent_filtered *bev_f;
-	if (bev->be_ops != &bufferevent_ops_filter)
+	if (!BEV_IS_FILTER(bev))
 		return NULL;
 	bev_f = (void*)( ((char*)bev) -
 			 evutil_offsetof(struct bufferevent_filtered, bev.bev));
-	EVUTIL_ASSERT(bev_f->bev.bev.be_ops == &bufferevent_ops_filter);
+	EVUTIL_ASSERT(BEV_IS_FILTER(&bev_f->bev.bev));
 	return bev_f;
 }
 
@@ -160,7 +160,7 @@ be_null_filter(struct evbuffer *src, struct evbuffer *dst, ev_ssize_t lim,
 	       enum bufferevent_flush_mode state, void *ctx)
 {
 	(void)state;
-	if (evbuffer_remove_buffer(src, dst, lim) == 0)
+	if (evbuffer_remove_buffer(src, dst, lim) >= 0)
 		return BEV_OK;
 	else
 		return BEV_ERROR;
@@ -605,6 +605,7 @@ be_filter_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,
 		data->ptr = bevf->underlying;
 		return 0;
 	case BEV_CTRL_SET_FD:
+	case BEV_CTRL_GET_FD:
 		bevf = upcast(bev);
 
 		if (bevf->underlying &&
@@ -612,9 +613,10 @@ be_filter_ctrl(struct bufferevent *bev, enum bufferevent_ctrl_op op,
 			bevf->underlying->be_ops->ctrl) {
 		    return (bevf->underlying->be_ops->ctrl)(bevf->underlying, op, data);
 		}
+		EVUTIL_FALLTHROUGH;
 
-	case BEV_CTRL_GET_FD:
 	case BEV_CTRL_CANCEL_ALL:
+		EVUTIL_FALLTHROUGH;
 	default:
 		return -1;
 	}
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent_openssl.c b/ipc/chromium/src/third_party/libevent/bufferevent_openssl.c
index da3963af06a8..b51b834bca7f 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent_openssl.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent_openssl.c
@@ -63,7 +63,6 @@
 #include "bufferevent-internal.h"
 #include "log-internal.h"
 
-#include <openssl/bio.h>
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 #include "openssl-compat.h"
@@ -155,7 +154,7 @@ bio_bufferevent_read(BIO *b, char *out, int outlen)
 	return r;
 }
 
-/* Called to write data info the BIO */
+/* Called to write data into the BIO */
 static int
 bio_bufferevent_write(BIO *b, const char *in, int inlen)
 {
@@ -251,7 +250,7 @@ BIO_s_bufferevent(void)
 /* Create a new BIO to wrap communication around a bufferevent.  If close_flag
  * is true, the bufferevent will be freed when the BIO is closed. */
 static BIO *
-BIO_new_bufferevent(struct bufferevent *bufferevent, int close_flag)
+BIO_new_bufferevent(struct bufferevent *bufferevent)
 {
 	BIO *result;
 	if (!bufferevent)
@@ -260,7 +259,9 @@ BIO_new_bufferevent(struct bufferevent *bufferevent, int close_flag)
 		return NULL;
 	BIO_set_init(result, 1);
 	BIO_set_data(result, bufferevent);
-	BIO_set_shutdown(result, close_flag ? 1 : 0);
+	/* We don't tell the BIO to close the bufferevent; we do it ourselves on
+	 * be_openssl_destruct() */
+	BIO_set_shutdown(result, 0);
 	return result;
 }
 
@@ -354,11 +355,11 @@ static inline struct bufferevent_openssl *
 upcast(struct bufferevent *bev)
 {
 	struct bufferevent_openssl *bev_o;
-	if (bev->be_ops != &bufferevent_ops_openssl)
+	if (!BEV_IS_OPENSSL(bev))
 		return NULL;
 	bev_o = (void*)( ((char*)bev) -
 			 evutil_offsetof(struct bufferevent_openssl, bev.bev));
-	EVUTIL_ASSERT(bev_o->bev.bev.be_ops == &bufferevent_ops_openssl);
+	EVUTIL_ASSERT(BEV_IS_OPENSSL(&bev_o->bev.bev));
 	return bev_o;
 }
 
@@ -510,12 +511,15 @@ conn_closed(struct bufferevent_openssl *bev_ssl, int when, int errcode, int ret)
 		/* IO error; possibly a dirty shutdown. */
 		if ((ret == 0 || ret == -1) && ERR_peek_error() == 0)
 			dirty_shutdown = 1;
+		put_error(bev_ssl, errcode);
 		break;
 	case SSL_ERROR_SSL:
 		/* Protocol error. */
+		put_error(bev_ssl, errcode);
 		break;
 	case SSL_ERROR_WANT_X509_LOOKUP:
 		/* XXXX handle this. */
+		put_error(bev_ssl, errcode);
 		break;
 	case SSL_ERROR_NONE:
 	case SSL_ERROR_WANT_READ:
@@ -803,7 +807,7 @@ consider_reading(struct bufferevent_openssl *bev_ssl)
 
 		if (bev_ssl->bev.read_suspended)
 			break;
-        
+
 		/* Read all pending data.  This won't hit the network
 		 * again, and will (most importantly) put us in a state
 		 * where we don't need to read anything else until the
@@ -963,8 +967,8 @@ be_openssl_writeeventcb(evutil_socket_t fd, short what, void *ptr)
 	bufferevent_decref_and_unlock_(&bev_ssl->bev.bev);
 }
 
-static int
-be_openssl_auto_fd(struct bufferevent_openssl *bev_ssl, int fd)
+static evutil_socket_t
+be_openssl_auto_fd(struct bufferevent_openssl *bev_ssl, evutil_socket_t fd)
 {
 	if (!bev_ssl->underlying) {
 		struct bufferevent *bev = &bev_ssl->bev.bev;
@@ -1030,7 +1034,7 @@ do_handshake(struct bufferevent_openssl *bev_ssl)
 	decrement_buckets(bev_ssl);
 
 	if (r==1) {
-		int fd = event_get_fd(&bev_ssl->bev.bev.ev_read);
+		evutil_socket_t fd = event_get_fd(&bev_ssl->bev.bev.ev_read);
 		/* We're done! */
 		bev_ssl->state = BUFFEREVENT_SSL_OPEN;
 		set_open_callbacks(bev_ssl, fd); /* XXXX handle failure */
@@ -1228,7 +1232,7 @@ be_openssl_destruct(struct bufferevent *bev)
 
 	if (bev_ssl->bev.options & BEV_OPT_CLOSE_ON_FREE) {
 		if (! bev_ssl->underlying) {
-			evutil_socket_t fd = -1;
+			evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 			BIO *bio = SSL_get_wbio(bev_ssl->ssl);
 			if (bio)
 				fd = BIO_get_fd(bio, NULL);
@@ -1261,17 +1265,21 @@ be_openssl_flush(struct bufferevent *bufev,
 
 static int
 be_openssl_set_fd(struct bufferevent_openssl *bev_ssl,
-    enum bufferevent_ssl_state state, int fd)
+    enum bufferevent_ssl_state state, evutil_socket_t fd)
 {
 	bev_ssl->state = state;
 
 	switch (state) {
 	case BUFFEREVENT_SSL_ACCEPTING:
+		if (!SSL_clear(bev_ssl->ssl))
+			return -1;
 		SSL_set_accept_state(bev_ssl->ssl);
 		if (set_handshake_callbacks(bev_ssl, fd) < 0)
 			return -1;
 		break;
 	case BUFFEREVENT_SSL_CONNECTING:
+		if (!SSL_clear(bev_ssl->ssl))
+			return -1;
 		SSL_set_connect_state(bev_ssl->ssl);
 		if (set_handshake_callbacks(bev_ssl, fd) < 0)
 			return -1;
@@ -1296,11 +1304,11 @@ be_openssl_ctrl(struct bufferevent *bev,
 	case BEV_CTRL_SET_FD:
 		if (!bev_ssl->underlying) {
 			BIO *bio;
-			bio = BIO_new_socket(data->fd, 0);
+			bio = BIO_new_socket((int)data->fd, 0);
 			SSL_set_bio(bev_ssl->ssl, bio, bio);
 		} else {
 			BIO *bio;
-			if (!(bio = BIO_new_bufferevent(bev_ssl->underlying, 0)))
+			if (!(bio = BIO_new_bufferevent(bev_ssl->underlying)))
 				return -1;
 			SSL_set_bio(bev_ssl->ssl, bio, bio);
 		}
@@ -1343,8 +1351,9 @@ bufferevent_openssl_new_impl(struct event_base *base,
 	struct bufferevent_private *bev_p = NULL;
 	int tmp_options = options & ~BEV_OPT_THREADSAFE;
 
+	/* Only one can be set. */
 	if (underlying != NULL && fd >= 0)
-		return NULL; /* Only one can be set. */
+		goto err;
 
 	if (!(bev_ssl = mm_calloc(1, sizeof(struct bufferevent_openssl))))
 		goto err;
@@ -1392,8 +1401,12 @@ bufferevent_openssl_new_impl(struct event_base *base,
 
 	return &bev_ssl->bev.bev;
 err:
-	if (bev_ssl)
+	if (options & BEV_OPT_CLOSE_ON_FREE)
+		SSL_free(ssl);
+	if (bev_ssl) {
+		bev_ssl->ssl = NULL;
 		bufferevent_free(&bev_ssl->bev.bev);
+	}
 	return NULL;
 }
 
@@ -1404,19 +1417,24 @@ bufferevent_openssl_filter_new(struct event_base *base,
     enum bufferevent_ssl_state state,
     int options)
 {
-	/* We don't tell the BIO to close the bufferevent; we do it ourselves
-	 * on be_openssl_destruct */
-	int close_flag = 0; /* options & BEV_OPT_CLOSE_ON_FREE; */
 	BIO *bio;
+	struct bufferevent *bev;
+
 	if (!underlying)
-		return NULL;
-	if (!(bio = BIO_new_bufferevent(underlying, close_flag)))
-		return NULL;
+		goto err;
+	if (!(bio = BIO_new_bufferevent(underlying)))
+		goto err;
 
 	SSL_set_bio(ssl, bio, bio);
 
-	return bufferevent_openssl_new_impl(
+	bev = bufferevent_openssl_new_impl(
 		base, underlying, -1, ssl, state, options);
+	return bev;
+
+err:
+	if (options & BEV_OPT_CLOSE_ON_FREE)
+		SSL_free(ssl);
+	return NULL;
 }
 
 struct bufferevent *
@@ -1443,14 +1461,14 @@ bufferevent_openssl_socket_new(struct event_base *base,
 		} else {
 			/* We specified an fd different from that of the SSL.
 			   This is probably an error on our part.  Fail. */
-			return NULL;
+			goto err;
 		}
-		(void) BIO_set_close(bio, 0);
+		BIO_set_close(bio, 0);
 	} else {
 		/* The SSL isn't configured with a BIO with an fd. */
 		if (fd >= 0) {
 			/* ... and we have an fd we want to use. */
-			bio = BIO_new_socket(fd, 0);
+			bio = BIO_new_socket((int)fd, 0);
 			SSL_set_bio(ssl, bio, bio);
 		} else {
 			/* Leave the fd unset. */
@@ -1459,6 +1477,11 @@ bufferevent_openssl_socket_new(struct event_base *base,
 
 	return bufferevent_openssl_new_impl(
 		base, NULL, fd, ssl, state, options);
+
+err:
+	if (options & BEV_OPT_CLOSE_ON_FREE)
+		SSL_free(ssl);
+	return NULL;
 }
 
 int
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent_pair.c b/ipc/chromium/src/third_party/libevent/bufferevent_pair.c
index 1e93f57293d2..f88cd751de1b 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent_pair.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent_pair.c
@@ -56,10 +56,10 @@ static inline struct bufferevent_pair *
 upcast(struct bufferevent *bev)
 {
 	struct bufferevent_pair *bev_p;
-	if (bev->be_ops != &bufferevent_ops_pair)
+	if (!BEV_IS_PAIR(bev))
 		return NULL;
 	bev_p = EVUTIL_UPCAST(bev, struct bufferevent_pair, bev.bev);
-	EVUTIL_ASSERT(bev_p->bev.bev.be_ops == &bufferevent_ops_pair);
+	EVUTIL_ASSERT(BEV_IS_PAIR(&bev_p->bev.bev));
 	return bev_p;
 }
 
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent_ratelim.c b/ipc/chromium/src/third_party/libevent/bufferevent_ratelim.c
index bde192021be1..258749685353 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent_ratelim.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent_ratelim.c
@@ -560,8 +560,7 @@ int
 bufferevent_set_rate_limit(struct bufferevent *bev,
     struct ev_token_bucket_cfg *cfg)
 {
-	struct bufferevent_private *bevp =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bevp = BEV_UPCAST(bev);
 	int r = -1;
 	struct bufferevent_rate_limit *rlim;
 	struct timeval now;
@@ -737,8 +736,7 @@ bufferevent_add_to_rate_limit_group(struct bufferevent *bev,
     struct bufferevent_rate_limit_group *g)
 {
 	int wsuspend, rsuspend;
-	struct bufferevent_private *bevp =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bevp = BEV_UPCAST(bev);
 	BEV_LOCK(bev);
 
 	if (!bevp->rate_limiting) {
@@ -789,8 +787,7 @@ int
 bufferevent_remove_from_rate_limit_group_internal_(struct bufferevent *bev,
     int unsuspend)
 {
-	struct bufferevent_private *bevp =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bevp = BEV_UPCAST(bev);
 	BEV_LOCK(bev);
 	if (bevp->rate_limiting && bevp->rate_limiting->group) {
 		struct bufferevent_rate_limit_group *g =
diff --git a/ipc/chromium/src/third_party/libevent/bufferevent_sock.c b/ipc/chromium/src/third_party/libevent/bufferevent_sock.c
index 93aedb33fa21..f40a8d9c57d8 100644
--- a/ipc/chromium/src/third_party/libevent/bufferevent_sock.c
+++ b/ipc/chromium/src/third_party/libevent/bufferevent_sock.c
@@ -99,24 +99,28 @@ const struct bufferevent_ops bufferevent_ops_socket = {
 const struct sockaddr*
 bufferevent_socket_get_conn_address_(struct bufferevent *bev)
 {
-	struct bufferevent_private *bev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
-
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 	return (struct sockaddr *)&bev_p->conn_address;
 }
-static void
-bufferevent_socket_set_conn_address_fd(struct bufferevent_private *bev_p, int fd)
+
+void
+bufferevent_socket_set_conn_address_fd_(struct bufferevent *bev,
+	evutil_socket_t fd)
 {
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
+
 	socklen_t len = sizeof(bev_p->conn_address);
 
 	struct sockaddr *addr = (struct sockaddr *)&bev_p->conn_address;
 	if (addr->sa_family != AF_UNSPEC)
 		getpeername(fd, addr, &len);
 }
-static void
-bufferevent_socket_set_conn_address(struct bufferevent_private *bev_p,
+
+void
+bufferevent_socket_set_conn_address_(struct bufferevent *bev,
 	struct sockaddr *addr, size_t addrlen)
 {
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 	EVUTIL_ASSERT(addrlen <= sizeof(bev_p->conn_address));
 	memcpy(&bev_p->conn_address, addr, addrlen);
 }
@@ -127,8 +131,7 @@ bufferevent_socket_outbuf_cb(struct evbuffer *buf,
     void *arg)
 {
 	struct bufferevent *bufev = arg;
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 
 	if (cbinfo->n_added &&
 	    (bufev->enabled & EV_WRITE) &&
@@ -146,8 +149,7 @@ static void
 bufferevent_readcb(evutil_socket_t fd, short event, void *arg)
 {
 	struct bufferevent *bufev = arg;
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 	struct evbuffer *input;
 	int res = 0;
 	short what = BEV_EVENT_READING;
@@ -228,8 +230,7 @@ static void
 bufferevent_writecb(evutil_socket_t fd, short event, void *arg)
 {
 	struct bufferevent *bufev = arg;
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 	int res = 0;
 	short what = BEV_EVENT_WRITING;
 	int connected = 0;
@@ -264,7 +265,7 @@ bufferevent_writecb(evutil_socket_t fd, short event, void *arg)
 			goto done;
 		} else {
 			connected = 1;
-			bufferevent_socket_set_conn_address_fd(bufev_p, fd);
+			bufferevent_socket_set_conn_address_fd_(bufev, fd);
 #ifdef _WIN32
 			if (BEV_IS_ASYNC(bufev)) {
 				event_del(&bufev->ev_write);
@@ -379,8 +380,7 @@ int
 bufferevent_socket_connect(struct bufferevent *bev,
     const struct sockaddr *sa, int socklen)
 {
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bev);
 
 	evutil_socket_t fd;
 	int r = 0;
@@ -389,9 +389,6 @@ bufferevent_socket_connect(struct bufferevent *bev,
 
 	bufferevent_incref_and_lock_(bev);
 
-	if (!bufev_p)
-		goto done;
-
 	fd = bufferevent_getfd(bev);
 	if (fd < 0) {
 		if (!sa)
@@ -399,7 +396,7 @@ bufferevent_socket_connect(struct bufferevent *bev,
 		fd = evutil_socket_(sa->sa_family,
 		    SOCK_STREAM|EVUTIL_SOCK_NONBLOCK, 0);
 		if (fd < 0)
-			goto done;
+			goto freesock;
 		ownfd = 1;
 	}
 	if (sa) {
@@ -449,10 +446,8 @@ bufferevent_socket_connect(struct bufferevent *bev,
 	goto done;
 
 freesock:
-	bufferevent_run_eventcb_(bev, BEV_EVENT_ERROR, 0);
 	if (ownfd)
 		evutil_closesocket(fd);
-	/* do something about the error? */
 done:
 	bufferevent_decref_and_unlock_(bev);
 	return result;
@@ -463,8 +458,7 @@ bufferevent_connect_getaddrinfo_cb(int result, struct evutil_addrinfo *ai,
     void *arg)
 {
 	struct bufferevent *bev = arg;
-	struct bufferevent_private *bev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 	int r;
 	BEV_LOCK(bev);
 
@@ -488,10 +482,10 @@ bufferevent_connect_getaddrinfo_cb(int result, struct evutil_addrinfo *ai,
 	}
 
 	/* XXX use the other addrinfos? */
-	/* XXX use this return value */
-	bufferevent_socket_set_conn_address(bev_p, ai->ai_addr, (int)ai->ai_addrlen);
+	bufferevent_socket_set_conn_address_(bev, ai->ai_addr, (int)ai->ai_addrlen);
 	r = bufferevent_socket_connect(bev, ai->ai_addr, (int)ai->ai_addrlen);
-	(void)r;
+	if (r < 0)
+		bufferevent_run_eventcb_(bev, BEV_EVENT_ERROR, 0);
 	bufferevent_decref_and_unlock_(bev);
 	evutil_freeaddrinfo(ai);
 }
@@ -502,8 +496,7 @@ bufferevent_socket_connect_hostname(struct bufferevent *bev,
 {
 	char portbuf[10];
 	struct evutil_addrinfo hint;
-	struct bufferevent_private *bev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 
 	if (family != AF_INET && family != AF_INET6 && family != AF_UNSPEC)
 		return -1;
@@ -535,8 +528,7 @@ int
 bufferevent_socket_get_dns_error(struct bufferevent *bev)
 {
 	int rv;
-	struct bufferevent_private *bev_p =
-	    EVUTIL_UPCAST(bev, struct bufferevent_private, bev);
+	struct bufferevent_private *bev_p = BEV_UPCAST(bev);
 
 	BEV_LOCK(bev);
 	rv = bev_p->dns_error;
@@ -587,8 +579,7 @@ be_socket_enable(struct bufferevent *bufev, short event)
 static int
 be_socket_disable(struct bufferevent *bufev, short event)
 {
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 	if (event & EV_READ) {
 		if (event_del(&bufev->ev_read) == -1)
 			return -1;
@@ -604,10 +595,9 @@ be_socket_disable(struct bufferevent *bufev, short event)
 static void
 be_socket_destruct(struct bufferevent *bufev)
 {
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 	evutil_socket_t fd;
-	EVUTIL_ASSERT(bufev->be_ops == &bufferevent_ops_socket);
+	EVUTIL_ASSERT(BEV_IS_SOCKET(bufev));
 
 	fd = event_get_fd(&bufev->ev_read);
 
@@ -628,11 +618,10 @@ be_socket_flush(struct bufferevent *bev, short iotype,
 static void
 be_socket_setfd(struct bufferevent *bufev, evutil_socket_t fd)
 {
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 
 	BEV_LOCK(bufev);
-	EVUTIL_ASSERT(bufev->be_ops == &bufferevent_ops_socket);
+	EVUTIL_ASSERT(BEV_IS_SOCKET(bufev));
 
 	event_del(&bufev->ev_read);
 	event_del(&bufev->ev_write);
@@ -658,11 +647,10 @@ int
 bufferevent_priority_set(struct bufferevent *bufev, int priority)
 {
 	int r = -1;
-	struct bufferevent_private *bufev_p =
-	    EVUTIL_UPCAST(bufev, struct bufferevent_private, bev);
+	struct bufferevent_private *bufev_p = BEV_UPCAST(bufev);
 
 	BEV_LOCK(bufev);
-	if (bufev->be_ops != &bufferevent_ops_socket)
+	if (BEV_IS_ASYNC(bufev) || BEV_IS_FILTER(bufev) || BEV_IS_PAIR(bufev))
 		goto done;
 
 	if (event_priority_set(&bufev->ev_read, priority) == -1)
@@ -685,7 +673,7 @@ bufferevent_base_set(struct event_base *base, struct bufferevent *bufev)
 	int res = -1;
 
 	BEV_LOCK(bufev);
-	if (bufev->be_ops != &bufferevent_ops_socket)
+	if (!BEV_IS_SOCKET(bufev))
 		goto done;
 
 	bufev->ev_base = base;
diff --git a/ipc/chromium/src/third_party/libevent/checkpatch.sh b/ipc/chromium/src/third_party/libevent/checkpatch.sh
index 6eaa19c46e92..5393799dcdf6 100755
--- a/ipc/chromium/src/third_party/libevent/checkpatch.sh
+++ b/ipc/chromium/src/third_party/libevent/checkpatch.sh
@@ -35,7 +35,7 @@ Example:
 OPTS:
   -p   - treat as patch
   -f   - treat as regular file
-  -f   - treat as regular file and print diff
+  -d   - treat as regular file and print diff
   -r   - treat as git revision (default)
   -C   - check using clang-format (default)
   -U   - check with uncrustify
@@ -164,8 +164,8 @@ function clang_style()
     local c="${options[cfg]}"
     echo "{ $(sed -e 's/#.*//' -e '/---/d' -e '/\.\.\./d' "$c" | tr $'\n' ,) }"
 }
-function clang_format() { clang-format --style="$(clang_style)" "$@"; }
-function clang_format_diff() { clang-format-diff --style="$(clang_style)" "$@"; }
+function clang_format() { clang-format -style="$(clang_style)" "$@"; }
+function clang_format_diff() { cat "$@" | clang-format-diff -p1 -style="$(clang_style)"; }
 # for non-bare repo will work
 function clang_format_git()
 { git format-patch --stdout "$@" -1 | clang_format_diff; }
diff --git a/ipc/chromium/src/third_party/libevent/cmake/AddEventLibrary.cmake b/ipc/chromium/src/third_party/libevent/cmake/AddEventLibrary.cmake
new file mode 100644
index 000000000000..04f5837e9860
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/cmake/AddEventLibrary.cmake
@@ -0,0 +1,193 @@
+include(CMakeParseArguments)
+
+set(LIBEVENT_SHARED_LIBRARIES "")
+set(LIBEVENT_STATIC_LIBRARIES "")
+
+macro(set_event_shared_lib_flags LIB_NAME)
+    set_target_properties("${LIB_NAME}_shared" PROPERTIES
+        COMPILE_FLAGS ${ARGN})
+    set_target_properties("${LIB_NAME}_shared" PROPERTIES
+        LINK_FLAGS ${ARGN})
+endmacro()
+
+macro(generate_pkgconfig LIB_NAME)
+    set(prefix      ${CMAKE_INSTALL_PREFIX})
+    set(exec_prefix ${CMAKE_INSTALL_PREFIX})
+    set(libdir      ${CMAKE_INSTALL_PREFIX}/lib)
+    set(includedir  ${CMAKE_INSTALL_PREFIX}/include)
+
+    set(VERSION ${EVENT_ABI_LIBVERSION})
+
+    set(LIBS         "")
+    foreach (LIB ${LIB_PLATFORM})
+        set(LIBS "${LIBS} -L${LIB}")
+    endforeach()
+
+    set(OPENSSL_LIBS "")
+    foreach(LIB ${OPENSSL_LIBRARIES})
+        set(OPENSSL_LIBS "${OPENSSL_LIBS} -L${LIB}")
+    endforeach()
+
+    configure_file("lib${LIB_NAME}.pc.in" "lib${LIB_NAME}.pc" @ONLY)
+    install(
+        FILES "${CMAKE_CURRENT_BINARY_DIR}/lib${LIB_NAME}.pc"
+        DESTINATION "${CMAKE_INSTALL_PREFIX}/lib/pkgconfig"
+    )
+endmacro()
+
+# LIB_NAME maybe event_core, event_extra, event_openssl, event_pthreads or event.
+# Targets whose LIB_NAME is not 'event' should be exported and installed.
+macro(export_install_target TYPE LIB_NAME OUTER_INCLUDES)
+    if("${LIB_NAME}" STREQUAL "event")
+        install(TARGETS "${LIB_NAME}_${TYPE}"
+            LIBRARY DESTINATION "lib" COMPONENT lib
+            ARCHIVE DESTINATION "lib" COMPONENT lib
+            RUNTIME DESTINATION "lib" COMPONENT lib
+            COMPONENT dev
+        )
+    else()
+        string(REPLACE "event_" "" PURE_NAME ${LIB_NAME})
+        string(TOUPPER ${TYPE} UPPER_TYPE)
+        list(APPEND LIBEVENT_${UPPER_TYPE}_LIBRARIES "${PURE_NAME}")
+        set(OUTER_INCS)
+        if (NOT "${OUTER_INCLUDES}" STREQUAL "NONE")
+            set(OUTER_INCS ${OUTER_INCLUDES})
+        endif()
+        target_include_directories("${LIB_NAME}_${TYPE}"
+            PUBLIC  "$<INSTALL_INTERFACE:include>"
+                    "$<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}/include>"
+                    "$<BUILD_INTERFACE:${PROJECT_BINARY_DIR}/include>"
+                    ${OUTER_INCS}
+        )
+        set_target_properties("${LIB_NAME}_${TYPE}" PROPERTIES EXPORT_NAME ${PURE_NAME})
+        export(TARGETS "${LIB_NAME}_${TYPE}"
+            NAMESPACE ${PROJECT_NAME}::
+            FILE "${PROJECT_BINARY_DIR}/LibeventTargets-${TYPE}.cmake"
+            APPEND
+        )
+        install(TARGETS "${LIB_NAME}_${TYPE}"
+            EXPORT LibeventTargets-${TYPE}
+            LIBRARY DESTINATION "lib" COMPONENT lib
+            ARCHIVE DESTINATION "lib" COMPONENT lib
+            RUNTIME DESTINATION "lib" COMPONENT lib
+            COMPONENT dev
+        )
+    endif()
+endmacro()
+
+# Global variables that it uses:
+# - EVENT_ABI_LIBVERSION
+# - EVENT_ABI_LIBVERSION_CURRENT
+# - EVENT_ABI_LIBVERSION_REVISION
+# - EVENT_ABI_LIBVERSION_AGE
+# - EVENT_PACKAGE_RELEASE
+# - CMAKE_THREAD_LIBS_INIT LIB_PLATFORM
+# - OPENSSL_LIBRARIES
+# - EVENT_SHARED_FLAGS
+# - EVENT_LIBRARY_STATIC
+# - EVENT_LIBRARY_SHARED
+#
+# Exported variables:
+# - LIBEVENT_SHARED_LIBRARIES
+# - LIBEVENT_STATIC_LIBRARIES
+macro(add_event_library LIB_NAME)
+    cmake_parse_arguments(LIB
+        "" # Options
+        "VERSION" # One val
+        "SOURCES;LIBRARIES;INNER_LIBRARIES;OUTER_INCLUDES" # Multi val
+        ${ARGN}
+    )
+
+    if ("${LIB_OUTER_INCLUDES}" STREQUAL "")
+        set(LIB_OUTER_INCLUDES NONE)
+    endif()
+    set(ADD_EVENT_LIBRARY_INTERFACE)
+
+    if (${EVENT_LIBRARY_STATIC})
+        add_library("${LIB_NAME}_static" STATIC ${LIB_SOURCES})
+        set_target_properties("${LIB_NAME}_static" PROPERTIES
+            OUTPUT_NAME "${LIB_NAME}"
+            CLEAN_DIRECT_OUTPUT 1)
+
+        if(LIB_INNER_LIBRARIES)
+            set(INNER_LIBRARIES "${LIB_INNER_LIBRARIES}_static")
+        endif()
+        target_link_libraries("${LIB_NAME}_static"
+            ${CMAKE_THREAD_LIBS_INIT}
+            ${LIB_PLATFORM}
+            ${INNER_LIBRARIES}
+            ${LIB_LIBRARIES})
+
+        export_install_target(static "${LIB_NAME}" "${LIB_OUTER_INCLUDES}")
+
+        set(ADD_EVENT_LIBRARY_INTERFACE "${LIB_NAME}_static")
+    endif()
+
+    if (${EVENT_LIBRARY_SHARED})
+        add_library("${LIB_NAME}_shared" SHARED ${LIB_SOURCES})
+
+        if(LIB_INNER_LIBRARIES)
+            set(INNER_LIBRARIES "${LIB_INNER_LIBRARIES}_shared")
+        endif()
+        target_link_libraries("${LIB_NAME}_shared"
+            ${CMAKE_THREAD_LIBS_INIT}
+            ${LIB_PLATFORM}
+            ${INNER_LIBRARIES}
+            ${LIB_LIBRARIES})
+
+        if (EVENT_SHARED_FLAGS)
+            set_event_shared_lib_flags("${LIB_NAME}" "${EVENT_SHARED_FLAGS}")
+        endif()
+
+        if (WIN32)
+            set_target_properties(
+                "${LIB_NAME}_shared" PROPERTIES
+                OUTPUT_NAME "${LIB_NAME}"
+                SOVERSION ${EVENT_ABI_LIBVERSION})
+        elseif (APPLE)
+            math(EXPR COMPATIBILITY_VERSION "${EVENT_ABI_LIBVERSION_CURRENT}+1")
+            math(EXPR CURRENT_MINUS_AGE "${EVENT_ABI_LIBVERSION_CURRENT}-${EVENT_ABI_LIBVERSION_AGE}")
+            set_target_properties(
+                "${LIB_NAME}_shared" PROPERTIES
+                OUTPUT_NAME "${LIB_NAME}-${EVENT_PACKAGE_RELEASE}.${CURRENT_MINUS_AGE}"
+                INSTALL_NAME_DIR "${CMAKE_INSTALL_PREFIX}/lib"
+                LINK_FLAGS "-compatibility_version ${COMPATIBILITY_VERSION} -current_version ${COMPATIBILITY_VERSION}.${EVENT_ABI_LIBVERSION_REVISION}")
+        else()
+            math(EXPR CURRENT_MINUS_AGE "${EVENT_ABI_LIBVERSION_CURRENT}-${EVENT_ABI_LIBVERSION_AGE}")
+            set_target_properties(
+                "${LIB_NAME}_shared" PROPERTIES
+                OUTPUT_NAME "${LIB_NAME}-${EVENT_PACKAGE_RELEASE}"
+                VERSION "${CURRENT_MINUS_AGE}.${EVENT_ABI_LIBVERSION_AGE}.${EVENT_ABI_LIBVERSION_REVISION}"
+                SOVERSION "${CURRENT_MINUS_AGE}"
+                INSTALL_RPATH "${CMAKE_INSTALL_PREFIX}/lib")
+        endif()
+
+        if (NOT WIN32)
+            set(LIB_LINK_NAME
+                "${CMAKE_SHARED_LIBRARY_PREFIX}${LIB_NAME}${CMAKE_SHARED_LIBRARY_SUFFIX}")
+
+            add_custom_command(TARGET ${LIB_NAME}_shared
+                POST_BUILD
+                COMMAND ${CMAKE_COMMAND} -E create_symlink
+                    "$<TARGET_FILE_NAME:${LIB_NAME}_shared>"
+                    "${LIB_LINK_NAME}"
+                WORKING_DIRECTORY "${CMAKE_LIBRARY_OUTPUT_DIRECTORY}")
+        endif()
+
+        export_install_target(shared "${LIB_NAME}" "${LIB_OUTER_INCLUDES}")
+
+        set(ADD_EVENT_LIBRARY_INTERFACE "${LIB_NAME}_shared")
+
+        if (NOT WIN32)
+            install(FILES
+                "$<TARGET_FILE_DIR:${LIB_NAME}_shared>/${LIB_LINK_NAME}"
+                DESTINATION "lib"
+                COMPONENT lib)
+        endif()
+    endif()
+
+    add_library(${LIB_NAME} INTERFACE)
+    target_link_libraries(${LIB_NAME} INTERFACE ${ADD_EVENT_LIBRARY_INTERFACE})
+
+    generate_pkgconfig("${LIB_NAME}")
+endmacro()
diff --git a/ipc/chromium/src/third_party/libevent/cmake/CheckConstExists.cmake b/ipc/chromium/src/third_party/libevent/cmake/CheckConstExists.cmake
new file mode 100644
index 000000000000..de074581df4c
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/cmake/CheckConstExists.cmake
@@ -0,0 +1,25 @@
+include(CheckCSourceCompiles)
+
+macro(check_const_exists CONST FILES VARIABLE)
+  if (NOT DEFINED ${VARIABLE})
+    set(check_const_exists_source "")
+    foreach(file ${FILES})
+      set(check_const_exists_source
+          "${check_const_exists_source}
+          #include <${file}>")
+    endforeach()
+    set(check_const_exists_source
+        "${check_const_exists_source}
+        int main() { (void)${CONST}; return 0; }")
+
+    check_c_source_compiles("${check_const_exists_source}" ${VARIABLE})
+
+    if (${${VARIABLE}})
+      set(${VARIABLE} 1 CACHE INTERNAL "Have const ${CONST}")
+      message(STATUS "Looking for ${CONST} - found")
+    else()
+      set(${VARIABLE} 0 CACHE INTERNAL "Have const ${CONST}")
+      message(STATUS "Looking for ${CONST} - not found")
+    endif()
+  endif()
+endmacro(check_const_exists)
diff --git a/ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.c b/ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.c
deleted file mode 100644
index 5ee3e5913a00..000000000000
--- a/ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.c
+++ /dev/null
@@ -1,30 +0,0 @@
-#ifdef CHECK_FUNCTION_EXISTS
-
-#ifndef _WIN32
-char CHECK_FUNCTION_EXISTS();
-#endif
-
-#ifdef __CLASSIC_C__
-int main(){
-  int ac;
-  char*av[];
-#else
-int main(int ac, char*av[]){
-#endif
-#ifdef _WIN32
-  void * p = &CHECK_FUNCTION_EXISTS;
-#else
-  CHECK_FUNCTION_EXISTS();
-#endif
-  if(ac > 1000)
-    {
-    return *av[0];
-    }
-  return 0;
-}
-
-#else  /* CHECK_FUNCTION_EXISTS */
-
-#  error "CHECK_FUNCTION_EXISTS has to specify the function"
-
-#endif /* CHECK_FUNCTION_EXISTS */
diff --git a/ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.cmake b/ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.cmake
deleted file mode 100644
index 78bc2ecc1b9c..000000000000
--- a/ipc/chromium/src/third_party/libevent/cmake/CheckFunctionExistsEx.cmake
+++ /dev/null
@@ -1,69 +0,0 @@
-# - Check if a C function can be linked
-# CHECK_FUNCTION_EXISTS(<function> <variable>)
-#
-# Check that the <function> is provided by libraries on the system and
-# store the result in a <variable>.  This does not verify that any
-# system header file declares the function, only that it can be found
-# at link time (considure using CheckSymbolExists).
-#
-# The following variables may be set before calling this macro to
-# modify the way the check is run:
-#
-#  CMAKE_REQUIRED_FLAGS = string of compile command line flags
-#  CMAKE_REQUIRED_DEFINITIONS = list of macros to define (-DFOO=bar)
-#  CMAKE_REQUIRED_INCLUDES = list of include directories
-#  CMAKE_REQUIRED_LIBRARIES = list of libraries to link
-
-#=============================================================================
-# Copyright 2002-2011 Kitware, Inc.
-#
-# Distributed under the OSI-approved BSD License (the "License");
-# see accompanying file Copyright.txt for details.
-#
-# This software is distributed WITHOUT ANY WARRANTY; without even the
-# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-# See the License for more information.
-#=============================================================================
-# (To distribute this file outside of CMake, substitute the full
-#  License text for the above reference.)
-
-MACRO(CHECK_FUNCTION_EXISTS_EX FUNCTION VARIABLE)
-  IF(${VARIABLE} MATCHES "^${VARIABLE}$")
-    SET(MACRO_CHECK_FUNCTION_DEFINITIONS 
-      "-DCHECK_FUNCTION_EXISTS=${FUNCTION} ${CMAKE_REQUIRED_FLAGS}")
-    MESSAGE(STATUS "Looking for ${FUNCTION}")
-    IF(CMAKE_REQUIRED_LIBRARIES)
-      SET(CHECK_FUNCTION_EXISTS_ADD_LIBRARIES
-        "-DLINK_LIBRARIES:STRING=${CMAKE_REQUIRED_LIBRARIES}")
-    ELSE(CMAKE_REQUIRED_LIBRARIES)
-      SET(CHECK_FUNCTION_EXISTS_ADD_LIBRARIES)
-    ENDIF(CMAKE_REQUIRED_LIBRARIES)
-    IF(CMAKE_REQUIRED_INCLUDES)
-      SET(CHECK_FUNCTION_EXISTS_ADD_INCLUDES
-        "-DINCLUDE_DIRECTORIES:STRING=${CMAKE_REQUIRED_INCLUDES}")
-    ELSE(CMAKE_REQUIRED_INCLUDES)
-      SET(CHECK_FUNCTION_EXISTS_ADD_INCLUDES)
-    ENDIF(CMAKE_REQUIRED_INCLUDES)
-    TRY_COMPILE(${VARIABLE}
-      ${CMAKE_BINARY_DIR}
-	  ${PROJECT_SOURCE_DIR}/cmake/CheckFunctionExistsEx.c
-      COMPILE_DEFINITIONS ${CMAKE_REQUIRED_DEFINITIONS}
-      CMAKE_FLAGS -DCOMPILE_DEFINITIONS:STRING=${MACRO_CHECK_FUNCTION_DEFINITIONS}
-      "${CHECK_FUNCTION_EXISTS_ADD_LIBRARIES}"
-      "${CHECK_FUNCTION_EXISTS_ADD_INCLUDES}"
-      OUTPUT_VARIABLE OUTPUT)
-    IF(${VARIABLE})
-      SET(${VARIABLE} 1 CACHE INTERNAL "Have function ${FUNCTION}")
-      MESSAGE(STATUS "Looking for ${FUNCTION} - found")
-      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeOutput.log 
-        "Determining if the function ${FUNCTION} exists passed with the following output:\n"
-        "${OUTPUT}\n\n")
-    ELSE(${VARIABLE})
-      MESSAGE(STATUS "Looking for ${FUNCTION} - not found")
-      SET(${VARIABLE} "" CACHE INTERNAL "Have function ${FUNCTION}")
-      FILE(APPEND ${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/CMakeError.log 
-        "Determining if the function ${FUNCTION} exists failed with the following output:\n"
-        "${OUTPUT}\n\n")
-    ENDIF(${VARIABLE})
-  ENDIF()
-ENDMACRO(CHECK_FUNCTION_EXISTS_EX)
diff --git a/ipc/chromium/src/third_party/libevent/cmake/CheckWaitpidSupportWNOWAIT.cmake b/ipc/chromium/src/third_party/libevent/cmake/CheckWaitpidSupportWNOWAIT.cmake
deleted file mode 100644
index 1a73db37b939..000000000000
--- a/ipc/chromium/src/third_party/libevent/cmake/CheckWaitpidSupportWNOWAIT.cmake
+++ /dev/null
@@ -1,18 +0,0 @@
-include(CheckCSourceRuns)
-
-check_c_source_runs(
-"
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <stdlib.h>
-
-int
-main(int argc, char** argv)
-{
-    pid_t pid;
-    int status;
-    if ((pid = fork()) == 0) _exit(0);
-    _exit(waitpid(pid, &status, WNOWAIT) == -1);
-}"
-EVENT__HAVE_WAITPID_WITH_WNOWAIT)
diff --git a/ipc/chromium/src/third_party/libevent/cmake/CheckWorkingKqueue.cmake b/ipc/chromium/src/third_party/libevent/cmake/CheckWorkingKqueue.cmake
index 47bf4e838a91..f22f011b5875 100644
--- a/ipc/chromium/src/third_party/libevent/cmake/CheckWorkingKqueue.cmake
+++ b/ipc/chromium/src/third_party/libevent/cmake/CheckWorkingKqueue.cmake
@@ -17,7 +17,7 @@ main(int argc, char **argv)
     int fd[2];
     struct kevent ev;
     struct timespec ts;
-    char buf[8000];
+    char buf[80000];
 
     if (pipe(fd) == -1)
         exit(1);
@@ -27,7 +27,7 @@ main(int argc, char **argv)
     while ((n = write(fd[1], buf, sizeof(buf))) == sizeof(buf))
         ;
 
-        if ((kq = kqueue()) == -1)
+    if ((kq = kqueue()) == -1)
         exit(1);
 
     memset(&ev, 0, sizeof(ev));
@@ -49,4 +49,4 @@ main(int argc, char **argv)
     exit(0);
 }
 
-" EVENT__HAVE_WORKING_KQUEUE)
\ No newline at end of file
+" EVENT__HAVE_WORKING_KQUEUE)
diff --git a/ipc/chromium/src/third_party/libevent/cmake/FindGit.cmake b/ipc/chromium/src/third_party/libevent/cmake/FindGit.cmake
deleted file mode 100644
index 2abbfe4e9df6..000000000000
--- a/ipc/chromium/src/third_party/libevent/cmake/FindGit.cmake
+++ /dev/null
@@ -1,45 +0,0 @@
-# The module defines the following variables:
-#   GIT_EXECUTABLE - path to git command line client
-#   GIT_FOUND - true if the command line client was found
-# Example usage:
-#   find_package(Git)
-#   if(GIT_FOUND)
-#     message("git found: ${GIT_EXECUTABLE}")
-#   endif()
-
-#=============================================================================
-# Copyright 2010 Kitware, Inc.
-#
-# Distributed under the OSI-approved BSD License (the "License");
-# see accompanying file Copyright.txt for details.
-#
-# This software is distributed WITHOUT ANY WARRANTY; without even the
-# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
-# See the License for more information.
-#=============================================================================
-# (To distributed this file outside of CMake, substitute the full
-#  License text for the above reference.)
-
-# Look for 'git' or 'eg' (easy git)
-set(git_names git eg)
-
-# Prefer .cmd variants on Windows unless running in a Makefile
-# in the MSYS shell.
-if(WIN32)
-  if(NOT CMAKE_GENERATOR MATCHES "MSYS")
-    set(git_names git.cmd git eg.cmd eg)
-  endif()
-endif()
-
-find_program(GIT_EXECUTABLE
-  NAMES ${git_names}
-  DOC "git command line client")
-
-mark_as_advanced(GIT_EXECUTABLE)
-
-# Handle the QUIETLY and REQUIRED arguments and set GIT_FOUND to TRUE if
-# all listed variables are TRUE
-
-include(FindPackageHandleStandardArgs)
-find_package_handle_standard_args(Git DEFAULT_MSG GIT_EXECUTABLE)
-
diff --git a/ipc/chromium/src/third_party/libevent/cmake/LibeventConfig.cmake.in b/ipc/chromium/src/third_party/libevent/cmake/LibeventConfig.cmake.in
index b28cacb5fb24..7b808c324543 100644
--- a/ipc/chromium/src/third_party/libevent/cmake/LibeventConfig.cmake.in
+++ b/ipc/chromium/src/third_party/libevent/cmake/LibeventConfig.cmake.in
@@ -1,17 +1,183 @@
 # - Config file for the Libevent package
 # It defines the following variables
-#  LIBEVENT_INCLUDE_DIRS - include directories for FooBar
-#  LIBEVENT_LIBRARIES    - libraries to link against
+#  LIBEVENT_FOUND            - true if libevent and all required components found on the system
+#  LIBEVENT_xxx_FOUND        - true if component xxx(see available components) found on the system
+#  LIBEVENT_VERSION          - libevent version in format Major.Minor.Patch
+#  LIBEVENT_INCLUDE_DIRS     - directories where libevent header is located.
+#  LIBEVENT_INCLUDE_DIR      - same as DIRS
+#  LIBEVENT_LIBRARIES        - libevent library to link against.
+#  LIBEVENT_LIBRARY          - same as LIBRARIES
+#
+# These variables are deprecated, don't use them.
+#  LIBEVENT_STATIC_LIBRARIES - libraries to link against (archive/static)
+#  LIBEVENT_SHARED_LIBRARIES - libraries to link against (shared)
+#
+# When you try to locate the libevent libraries, you should specify which components you want to use.
+# The following table lists all available components. If none is given, all imported targets will used.
+#  core        - the core functons of libevent
+#  extra       - extra functions, contains http, dns and rpc
+#  pthreads    - multiple threads for libevent, not exists on Windows
+#  openssl     - openssl support for libevent
+#
+# By default, the shared libraries of libevent will be found. To find the static ones instead,
+# you must set the LIBEVENT_STATIC_LINK variable to TRUE before calling find_package(Libevent ...).
+# If no component provided, all components will be used.
+# example:
+#  set(LIBEVENT_STATIC_LINK TRUE)
+#  find_package(Libevent 2.2 REQUIRED COMPONENTS core)
+#  include_directories(${LIBEVENT_INCLUDE_DIRS})  # Can be omitted
+#  target_link_libraries(myapp ${LIBEVENT_LIBRARIES})
+#    or target_link_libraries(myapp libevent::core)
+#
+# find_package() can handle dependencies automatically. For example, given the 'openssl' component,
+# all dependencies (libevent_core, libssl, libcrypto and openssl include directories) will be found.
+
+set(CONFIG_FOR_INSTALL_TREE @CONFIG_FOR_INSTALL_TREE@)
+
+set(LIBEVENT_VERSION @EVENT_PACKAGE_VERSION@)
+
+# IMPORTED targets from LibeventTargets.cmake
+set(LIBEVENT_STATIC_LIBRARIES "@LIBEVENT_STATIC_LIBRARIES@")
+set(LIBEVENT_SHARED_LIBRARIES "@LIBEVENT_SHARED_LIBRARIES@")
+
+# Default to the same type as libevent was built:
+if(NOT DEFINED LIBEVENT_STATIC_LINK)
+    set(LIBEVENT_STATIC_LINK NOT @EVENT_LIBRARY_SHARED@)
+endif()
+
+set(CMAKE_FIND_LIBRARY_SUFFIXES_SAVE "${CMAKE_FIND_LIBRARY_SUFFIXES}")
+if(${LIBEVENT_STATIC_LINK})
+    set(_LIB_TYPE static)
+    set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_STATIC_LIBRARY_SUFFIX})
+    set(_AVAILABLE_LIBS "${LIBEVENT_STATIC_LIBRARIES}")
+else()
+    set(_LIB_TYPE shared)
+    set(CMAKE_FIND_LIBRARY_SUFFIXES ${CMAKE_SHARED_LIBRARY_SUFFIX})
+    set(_AVAILABLE_LIBS "${LIBEVENT_SHARED_LIBRARIES}")
+endif()
 
 # Get the path of the current file.
 get_filename_component(LIBEVENT_CMAKE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)
+get_filename_component(_INSTALL_PREFIX "${LIBEVENT_CMAKE_DIR}/../../.." ABSOLUTE)
 
-# Set the include directories.
-set(LIBEVENT_INCLUDE_DIRS "@EVENT_INSTALL_INCLUDE_DIR@")
+macro(message_if_needed _flag _msg)
+    if (NOT ${CMAKE_FIND_PACKAGE_NAME}_FIND_QUIETLY)
+        message(${_flag} "${_msg}")
+    endif()
+endmacro()
 
-# Include the project Targets file, this contains definitions for IMPORTED targets.
-include(${LIBEVENT_CMAKE_DIR}/LibeventTargets.cmake)
+macro(no_component_msg _comp)
+    if(${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED_${_comp})
+        set(pthreadlib)
+        if(NOT WIN32)
+            set(pthreadlib ", pthreads")
+        endif()
+        message(FATAL_ERROR "Your libevent library does not contain a ${_comp} component!\n"
+                "The valid components are core, extra${pthreadlib} and openssl.")
+    else()
+        message_if_needed(WARNING "Your libevent library does not contain a ${_comp} component!")
+    endif()
+endmacro()
 
-# IMPORTED targets from LibeventTargets.cmake
-set(LIBEVENT_LIBRARIES event event_core event_extra)
+set(_EVENT_COMPONENTS)
+if(${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS)
+    list(REMOVE_DUPLICATES ${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS)
+    foreach(_comp ${${CMAKE_FIND_PACKAGE_NAME}_FIND_COMPONENTS})
+        list(FIND _AVAILABLE_LIBS ${_comp} _INDEX)
+        if(_INDEX GREATER -1)
+            list(APPEND _EVENT_COMPONENTS ${_comp})
+        else()
+            no_component_msg(${_comp})
+        endif()
+    endforeach()
+else()
+    set(_EVENT_COMPONENTS ${_AVAILABLE_LIBS})
+endif()
+
+set(_POSSIBLE_PKG_NAMES)
+list(APPEND _POSSIBLE_PKG_NAMES ${CMAKE_FIND_PACKAGE_NAME} LIBEVENT Libevent libevent)
+list(REMOVE_DUPLICATES _POSSIBLE_PKG_NAMES)
+
+macro(set_case_insensitive_found _comp)
+    foreach(name ${_POSSIBLE_PKG_NAMES})
+        if("${_comp}" STREQUAL "")
+            set(${name}_FOUND TRUE)
+            set(${name}_NOTFOUND FALSE)
+        else()
+            set(${name}_${_comp}_FOUND TRUE)
+            set(${name}_${_comp}_NOTFOUND FALSE)
+        endif()
+    endforeach()
+endmacro()
+
+if(CONFIG_FOR_INSTALL_TREE)
+    ## Config for install tree ----------------------------------------
+    # Find includes
+    unset(_event_h CACHE)
+    find_path(_event_h
+              NAMES event2/event.h
+              PATHS "${_INSTALL_PREFIX}/include"
+              NO_DEFAULT_PATH)
+    if(_event_h)
+        set(LIBEVENT_INCLUDE_DIRS "${_event_h}")
+        message_if_needed(STATUS "Found libevent include directory: ${_event_h}")
+    else()
+        message_if_needed(WARNING "Your libevent library does not contain header files!")
+    endif()
+
+    # Find libraries
+    macro(find_event_lib _comp)
+        unset(_event_lib CACHE)
+        find_library(_event_lib
+                    NAMES "event_${_comp}"
+                    PATHS "${_INSTALL_PREFIX}/lib"
+                    NO_DEFAULT_PATH)
+        if(_event_lib)
+            list(APPEND LIBEVENT_LIBRARIES "libevent::${_comp}")
+            set_case_insensitive_found(${_comp})
+            message_if_needed(STATUS "Found libevent component: ${_event_lib}")
+        else()
+            no_component_msg(${_comp})
+        endif()
+    endmacro()
+
+    foreach(comp ${_EVENT_COMPONENTS})
+        find_event_lib(${comp})
+    endforeach()
+else()
+    ## Config for build tree ----------------------------------------
+    set(LIBEVENT_INCLUDE_DIRS "@EVENT__INCLUDE_DIRS@")
+    foreach(_comp ${_EVENT_COMPONENTS})
+        list(APPEND LIBEVENT_LIBRARIES "libevent::${_comp}")
+        set_case_insensitive_found(${_comp})
+    endforeach()
+endif()
+
+set(LIBEVENT_INCLUDE_DIR ${LIBEVENT_INCLUDE_DIRS})
+if(LIBEVENT_LIBRARIES)
+    set(LIBEVENT_LIBRARY ${LIBEVENT_LIBRARIES})
+    if(CONFIG_FOR_INSTALL_TREE)
+        message_if_needed(STATUS "Found libevent ${LIBEVENT_VERSION} in ${_INSTALL_PREFIX}")
+    else()
+        message_if_needed(STATUS "Found libevent ${LIBEVENT_VERSION} in ${LIBEVENT_CMAKE_DIR}")
+    endif()
+
+    # Avoid including targets more than one times
+    if(NOT TARGET event_core_${_LIB_TYPE})
+        # Include the project Targets file, this contains definitions for IMPORTED targets.
+        include(${LIBEVENT_CMAKE_DIR}/LibeventTargets-${_LIB_TYPE}.cmake)
+    endif()
+else()
+    if(${CMAKE_FIND_PACKAGE_NAME}_FIND_REQUIRED)
+        message(FATAL_ERROR "Can not find any libraries for libevent.")
+    else()
+        message_if_needed(WARNING "Can not find any libraries for libevent.")
+    endif()
+endif()
 
+set(CMAKE_FIND_LIBRARY_SUFFIXES "${CMAKE_FIND_LIBRARY_SUFFIXES_SAVE}")
+unset(_LIB_TYPE)
+unset(_AVAILABLE_LIBS)
+unset(_EVENT_COMPONENTS)
+unset(_POSSIBLE_PKG_NAMES)
+unset(_INSTALL_PREFIX)
diff --git a/ipc/chromium/src/third_party/libevent/cmake/LibeventConfigBuildTree.cmake.in b/ipc/chromium/src/third_party/libevent/cmake/LibeventConfigBuildTree.cmake.in
deleted file mode 100644
index 02edef32fcd8..000000000000
--- a/ipc/chromium/src/third_party/libevent/cmake/LibeventConfigBuildTree.cmake.in
+++ /dev/null
@@ -1,17 +0,0 @@
-# - Config file for the Libevent package
-# It defines the following variables
-#  LIBEVENT_INCLUDE_DIRS - include directories for FooBar
-#  LIBEVENT_LIBRARIES    - libraries to link against
-
-# Get the path of the current file.
-get_filename_component(LIBEVENT_CMAKE_DIR "${CMAKE_CURRENT_LIST_FILE}" PATH)
-
-# Set the include directories.
-set(LIBEVENT_INCLUDE_DIRS "@EVENT__INCLUDE_DIRS@")
-
-# Include the project Targets file, this contains definitions for IMPORTED targets.
-include(${LIBEVENT_CMAKE_DIR}/LibeventTargets.cmake)
-
-# IMPORTED targets from LibeventTargets.cmake
-set(LIBEVENT_LIBRARIES event event_core event_extra)
-
diff --git a/ipc/chromium/src/third_party/libevent/cmake/Macros.cmake b/ipc/chromium/src/third_party/libevent/cmake/Macros.cmake
new file mode 100644
index 000000000000..e480bbfdca8a
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/cmake/Macros.cmake
@@ -0,0 +1,36 @@
+include(CheckSymbolExists)
+include(CheckIncludeFiles)
+
+# Check if each symbol in the symbol list exists,
+# and define PREFIX__HAVE_SYMNAME to 1 if yes.
+#
+# SYMLIST: list of symbols to check
+# HEADERS: header files to be included in check code
+# PREFIX: the prefix of definition
+macro(CHECK_SYMBOLS_EXIST SYMLIST HEADERS PREFIX)
+  foreach(SYMNAME ${SYMLIST})
+    string(TOUPPER "${SYMNAME}" SYMNAME_UPPER)
+    if ("${PREFIX}" STREQUAL "")
+      set(HAVE_SYM_DEF "HAVE_${SYMNAME_UPPER}")
+    else()
+      set(HAVE_SYM_DEF "${PREFIX}__HAVE_${SYMNAME_UPPER}")
+    endif()
+    CHECK_SYMBOL_EXISTS(${SYMNAME} "${HEADERS}" ${HAVE_SYM_DEF})
+  endforeach()
+endmacro()
+
+# Check if file exists, define PREFIX__HAVE_FILE to 1 if yes,
+# and collect file to EVENT_INCLUDES
+macro(CHECK_INCLUDE_FILE_CONCAT FILE PREFIX)
+  string(REGEX REPLACE "[./]" "_" FILE_UL ${FILE})
+  string(TOUPPER "${FILE_UL}" FILE_UL_UPPER)
+  if ("${PREFIX}" STREQUAL "")
+    set(HAVE_FILE_DEF "HAVE_${FILE_UL_UPPER}")
+  else()
+    set(HAVE_FILE_DEF "${PREFIX}__HAVE_${FILE_UL_UPPER}")
+  endif()
+  CHECK_INCLUDE_FILES("${EVENT_INCLUDES};${FILE}" ${HAVE_FILE_DEF})
+  if(${HAVE_FILE_DEF})
+    set(EVENT_INCLUDES ${EVENT_INCLUDES} ${FILE})
+  endif()
+endmacro()
diff --git a/ipc/chromium/src/third_party/libevent/cmake/Uninstall.cmake.in b/ipc/chromium/src/third_party/libevent/cmake/Uninstall.cmake.in
new file mode 100644
index 000000000000..c6dc09efe109
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/cmake/Uninstall.cmake.in
@@ -0,0 +1,23 @@
+# https://gitlab.kitware.com/cmake/community/wikis/FAQ#can-i-do-make-uninstall-with-cmake
+
+if(NOT EXISTS "@CMAKE_BINARY_DIR@/install_manifest.txt")
+  message(FATAL_ERROR "Cannot find install manifest: @CMAKE_BINARY_DIR@/install_manifest.txt")
+endif(NOT EXISTS "@CMAKE_BINARY_DIR@/install_manifest.txt")
+
+file(READ "@CMAKE_BINARY_DIR@/install_manifest.txt" files)
+string(REGEX REPLACE "\n" ";" files "${files}")
+foreach(file ${files})
+  message(STATUS "Uninstalling $ENV{DESTDIR}${file}")
+  if(IS_SYMLINK "$ENV{DESTDIR}${file}" OR EXISTS "$ENV{DESTDIR}${file}")
+    exec_program(
+      "@CMAKE_COMMAND@" ARGS "-E remove \"$ENV{DESTDIR}${file}\""
+      OUTPUT_VARIABLE rm_out
+      RETURN_VALUE rm_retval
+      )
+    if(NOT "${rm_retval}" STREQUAL 0)
+      message(FATAL_ERROR "Problem when removing $ENV{DESTDIR}${file}")
+    endif(NOT "${rm_retval}" STREQUAL 0)
+  else(IS_SYMLINK "$ENV{DESTDIR}${file}" OR EXISTS "$ENV{DESTDIR}${file}")
+    message(STATUS "File $ENV{DESTDIR}${file} does not exist.")
+  endif(IS_SYMLINK "$ENV{DESTDIR}${file}" OR EXISTS "$ENV{DESTDIR}${file}")
+endforeach(file)
diff --git a/ipc/chromium/src/third_party/libevent/cmake/UseDoxygen.cmake b/ipc/chromium/src/third_party/libevent/cmake/UseDoxygen.cmake
new file mode 100644
index 000000000000..3b60d5a0f58b
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/cmake/UseDoxygen.cmake
@@ -0,0 +1,111 @@
+# Use FindDoxygen.cmake to generate documentation.
+
+option(DOXYGEN_GENERATE_HTML  "Generate HTML"      ON)
+option(DOXYGEN_GENERATE_MAN   "Generate man pages" OFF)
+option(DOXYGEN_MAN_LINKS      "Generate man links" ON)
+option(DOXYGEN_GENERATE_LATEX "Generate LaTeX"     OFF)
+
+# If the case-insensitive value of the cmake option is one of
+# "off, no, false" or 0, it is equal to false, otherwise true.
+# And the values of the doxygen config does not exactly match it.
+# So we need to convert the cmake option to a doxygen config.
+macro(_convert_to_dx_cfg CMK_OPTION)
+  if (${CMK_OPTION})
+    set(${CMK_OPTION} YES)
+  else()
+    set(${CMK_OPTION} NO)
+  endif()
+endmacro()
+
+macro(UseDoxygen)
+  if (${CMAKE_VERSION} VERSION_LESS "3.9")
+    # Old versions of cmake have poor support for Doxygen generation.
+    message(FATAL_ERROR "Doxygen generation only enabled for cmake 3.9 and higher")
+  else()
+    find_package(Doxygen)
+    if (DOXYGEN_FOUND)
+      set(DOXYGEN_PROJECT_NAME ${PROJECT_NAME})
+      set(DOXYGEN_PROJECT_NUMBER ${EVENT_PACKAGE_VERSION})
+      set(DOXYGEN_PROJECT_BRIEF "Event notification library")
+      set(DOXYGEN_OUTPUT_DIRECTORY doxygen)
+      set(DOXYGEN_STRIP_FROM_PATH include)
+      set(DOXYGEN_JAVADOC_AUTOBRIEF YES)
+      set(DOXYGEN_OPTIMIZE_OUTPUT_FOR_C YES)
+      set(DOXYGEN_SORT_BRIEF_DOCS YES)
+      set(DOXYGEN_RECURSIVE NO)
+
+      _convert_to_dx_cfg(DOXYGEN_GENERATE_HTML)
+      _convert_to_dx_cfg(DOXYGEN_GENERATE_MAN)
+      _convert_to_dx_cfg(DOXYGEN_MAN_LINKS)
+      _convert_to_dx_cfg(DOXYGEN_GENERATE_LATEX)
+
+      set(DOXYGEN_LATEX_CMD_NAME latex)
+      set(DOXYGEN_PAPER_TYPE a4wide)
+      set(DOXYGEN_PDF_HYPERLINKS NO)
+
+      set(DOXYGEN_GENERATE_RTF NO)
+      set(DOXYGEN_GENERATE_XML NO)
+      set(DOXYGEN_GENERATE_CHI NO)
+
+      set(DOXYGEN_PREDEFINED TAILQ_ENTRY
+        RB_ENTRY
+        EVENT_DEFINED_TQENTRY_
+        EVENT_IN_DOXYGEN_
+      )
+
+      set(DOX_INPUT include/event2/buffer.h
+        include/event2/buffer_compat.h
+        include/event2/bufferevent.h
+        include/event2/bufferevent_compat.h
+        include/event2/bufferevent_ssl.h
+        include/event2/dns.h
+        include/event2/dns_compat.h
+        include/event2/event.h
+        include/event2/event_compat.h
+        include/event2/http.h
+        include/event2/http_compat.h
+        include/event2/listener.h
+        include/event2/rpc.h
+        include/event2/rpc_compat.h
+        include/event2/tag.h
+        include/event2/tag_compat.h
+        include/event2/thread.h
+        include/event2/util.h
+      )
+      # Add 'doxygen' target
+      doxygen_add_docs(doxygen
+        ${DOX_INPUT}
+        ALL
+        WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
+        COMMENT "Generating doxygen documentation for ${PROJECT_NAME}..."
+      )
+
+      # Use 'make clean' to remove the generated directory
+      set_property(DIRECTORY
+        PROPERTY ADDITIONAL_MAKE_CLEAN_FILES
+        "${PROJECT_BINARY_DIR}/${DOXYGEN_OUTPUT_DIRECTORY}"
+      )
+
+      # Install html into <prefix>/share/doc/<project>
+      if ("${DOXYGEN_GENERATE_HTML}" STREQUAL "YES")
+        install(DIRECTORY
+          ${PROJECT_BINARY_DIR}/${DOXYGEN_OUTPUT_DIRECTORY}/html
+          DESTINATION ${CMAKE_INSTALL_PREFIX}/share/doc/${PROJECT_NAME}
+          COMPONENT doc
+        )
+      endif()
+
+      # Install manual into <prefix>/share/man/man3
+      if ("${DOXYGEN_GENERATE_MAN}" STREQUAL "YES")
+        install(DIRECTORY
+          ${PROJECT_BINARY_DIR}/${DOXYGEN_OUTPUT_DIRECTORY}/man/man3
+          DESTINATION ${CMAKE_INSTALL_PREFIX}/share/man
+          COMPONENT doc
+        )
+      endif()
+
+    else(DOXYGEN_FOUND)
+      message(FATAL_ERROR "Doxygen command not found, set EVENT__DOXYGEN to disable")
+    endif (DOXYGEN_FOUND)
+  endif()
+endmacro()
diff --git a/ipc/chromium/src/third_party/libevent/cmake/VersionViaGit.cmake b/ipc/chromium/src/third_party/libevent/cmake/VersionViaGit.cmake
index a9882d8a9639..24eb6af9b7de 100644
--- a/ipc/chromium/src/third_party/libevent/cmake/VersionViaGit.cmake
+++ b/ipc/chromium/src/third_party/libevent/cmake/VersionViaGit.cmake
@@ -2,9 +2,8 @@
 # git to determine the parent tag. And if found the macro
 # will attempt to parse them in the github tag fomat
 #
-# Usful for auto-versionin in ou CMakeLists
+# Useful for auto-versioning in our CMakeLists
 #
-#  EVENT_GIT___VERSION_FOUND - Version variables foud
 #  EVENT_GIT___VERSION_MAJOR - Major version.
 #  EVENT_GIT___VERSION_MINOR - Minor version
 #  EVENT_GIT___VERSION_STAGE - Stage version
@@ -12,7 +11,6 @@
 # Example usage:
 #
 # event_fuzzy_version_from_git()
-# if (EVENT_GIT___VERSION_FOUND)
 #    message("Libvent major=${EVENT_GIT___VERSION_MAJOR}")
 #    message("        minor=${EVENT_GIT___VERSION_MINOR}")
 #    message("        patch=${EVENT_GIT___VERSION_PATCH}")
@@ -22,32 +20,47 @@
 include(FindGit)
 
 macro(event_fuzzy_version_from_git)
-	set(EVENT_GIT___VERSION_FOUND FALSE)
-
 	# set our defaults.
 	set(EVENT_GIT___VERSION_MAJOR 2)
 	set(EVENT_GIT___VERSION_MINOR 1)
-	set(EVENT_GIT___VERSION_PATCH 8)
-	set(EVENT_GIT___VERSION_STAGE "beta")
+	set(EVENT_GIT___VERSION_PATCH 12)
+	set(EVENT_GIT___VERSION_STAGE "stable")
 
 	find_package(Git)
 
 	if (GIT_FOUND)
 		execute_process(
 			COMMAND
-				${GIT_EXECUTABLE} describe --abbrev=0
+				${GIT_EXECUTABLE} describe --abbrev=0 --always
 			WORKING_DIRECTORY
 				${PROJECT_SOURCE_DIR}
 			RESULT_VARIABLE
 				GITRET
 			OUTPUT_VARIABLE
-				GITVERSION)
+				GITVERSION
+			OUTPUT_STRIP_TRAILING_WHITESPACE
+		)
+
+		string(REGEX REPLACE "[\\._-]" ";" VERSION_LIST "${GITVERSION}")
+		if(VERSION_LIST)
+			list(LENGTH VERSION_LIST VERSION_LIST_LENGTH)
+		endif()
+
+		if ((GITRET EQUAL 0) AND (VERSION_LIST_LENGTH EQUAL 5))
+			list(GET VERSION_LIST 1 _MAJOR)
+			list(GET VERSION_LIST 2 _MINOR)
+			list(GET VERSION_LIST 3 _PATCH)
+			list(GET VERSION_LIST 4 _STAGE)
+
+			set(_DEFAULT_VERSION "${EVENT_GIT___VERSION_MAJOR}.${EVENT_GIT___VERSION_MINOR}.${EVENT_GIT___VERSION_PATCH}-${EVENT_GIT___VERSION_STAGE}")
+			set(_GIT_VERSION     "${_MAJOR}.${_MINOR}.${_PATCH}-${_STAGE}")
 
-			if (GITRET EQUAL 0)
-				string(REGEX REPLACE "^release-([0-9]+)\\.([0-9]+)\\.([0-9]+)-(.*)"       "\\1" EVENT_GIT___VERSION_MAJOR ${GITVERSION})
-				string(REGEX REPLACE "^release-([0-9]+)\\.([0-9]+)\\.([0-9]+)-(.*)"       "\\2" EVENT_GIT___VERSION_MINOR ${GITVERSION})
-				string(REGEX REPLACE "^release-([0-9]+)\\.([0-9]+)\\.([0-9]+)-(.*)"       "\\3" EVENT_GIT___VERSION_PATCH ${GITVERSION})
-				string(REGEX REPLACE "^release-([0-9]+)\\.([0-9]+)\\.([0-9]+)-([aA-zZ]+)" "\\4" EVENT_GIT___VERSION_STAGE ${GITVERSION})
+			if (${_DEFAULT_VERSION} VERSION_LESS ${_GIT_VERSION})
+				set(EVENT_GIT___VERSION_MAJOR ${_MAJOR})
+				set(EVENT_GIT___VERSION_MINOR ${_MINOR})
+				set(EVENT_GIT___VERSION_PATCH ${_PATCH})
+				set(EVENT_GIT___VERSION_STAGE ${_STAGE})
 			endif()
 		endif()
+	endif()
 endmacro()
diff --git a/ipc/chromium/src/third_party/libevent/configure.ac b/ipc/chromium/src/third_party/libevent/configure.ac
index 7528d37ee03f..d00e063a1474 100644
--- a/ipc/chromium/src/third_party/libevent/configure.ac
+++ b/ipc/chromium/src/third_party/libevent/configure.ac
@@ -5,30 +5,23 @@ dnl See LICENSE for copying information.
 dnl
 dnl Original version Dug Song <dugsong@monkey.org>
 
-AC_INIT(libevent,2.1.8-stable)
-AC_PREREQ(2.59)
+AC_INIT(libevent,2.1.12-stable)
+AC_PREREQ(2.67)
 AC_CONFIG_SRCDIR(event.c)
 
 AC_CONFIG_MACRO_DIR([m4])
+AC_CONFIG_AUX_DIR([build-aux])
 AM_INIT_AUTOMAKE
 dnl AM_SILENT_RULES req. automake 1.11.  [no] defaults V=1
-m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])
+AM_SILENT_RULES([yes])
 AC_CONFIG_HEADERS(config.h  evconfig-private.h:evconfig-private.h.in)
-AC_DEFINE(NUMERIC_VERSION, 0x02010800, [Numeric representation of the version])
+AC_DEFINE(NUMERIC_VERSION, 0x02010c00, [Numeric representation of the version])
 
 dnl Initialize prefix.
-if test "$prefix" = "NONE"; then
-   prefix="/usr/local"
-fi
+AC_PREFIX_DEFAULT([/usr/local])
 
 dnl Try and get a full POSIX environment on obscure systems
-ifdef([AC_USE_SYSTEM_EXTENSIONS], [
 AC_USE_SYSTEM_EXTENSIONS
-], [
-AC_AIX
-AC_GNU_SOURCE
-AC_MINIX
-])
 
 AC_CANONICAL_BUILD
 AC_CANONICAL_HOST
@@ -48,11 +41,7 @@ AC_PROG_INSTALL
 AC_PROG_LN_S
 # AC_PROG_MKDIR_P - $(MKDIR_P) should be defined by AM_INIT_AUTOMAKE
 
-# AC_PROG_SED is only available in Autoconf >= 2.59b; workaround for older
-# versions
-ifdef([AC_PROG_SED], [AC_PROG_SED], [
-AC_CHECK_PROGS(SED, [gsed sed])
-])
+AC_PROG_SED
 
 AC_PROG_GCC_TRADITIONAL
 
@@ -126,7 +115,8 @@ AC_ARG_ENABLE([clock-gettime],
   [], [enable_clock_gettime=yes])
 
 
-AC_PROG_LIBTOOL
+LT_PREREQ([2.4.2])
+LT_INIT
 
 dnl   Uncomment "AC_DISABLE_SHARED" to make shared libraries not get
 dnl   built by default.  You can also turn shared libs on and off from
@@ -150,27 +140,46 @@ AC_SEARCH_LIBS([sendfile], [sendfile])
 dnl - check if the macro _WIN32 is defined on this compiler.
 dnl - (this is how we check for a windows compiler)
 AC_MSG_CHECKING(for WIN32)
-AC_TRY_COMPILE(,
-	[
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([],
+    [
 #ifndef _WIN32
 die horribly
 #endif
-	],
-	bwin32=true; AC_MSG_RESULT(yes),
-	bwin32=false; AC_MSG_RESULT(no),
+    ]
+  )],
+	[bwin32=true; AC_MSG_RESULT(yes)],
+	[bwin32=false; AC_MSG_RESULT(no)]
+)
+
+dnl - check if the macro __midipix__ is defined on this compiler.
+dnl - (this is how we check for a midipix version of GCC)
+AC_MSG_CHECKING(for MIDIPIX)
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([],
+    [
+#ifndef __midipix__
+die horribly
+#endif
+    ]
+  )],
+	[midipix=true; AC_MSG_RESULT(yes)],
+	[midipix=false; AC_MSG_RESULT(no)]
 )
 
 dnl - check if the macro __CYGWIN__ is defined on this compiler.
 dnl - (this is how we check for a cygwin version of GCC)
 AC_MSG_CHECKING(for CYGWIN)
-AC_TRY_COMPILE(,
-	[
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([],
+    [
 #ifndef __CYGWIN__
 die horribly
 #endif
-	],
-	cygwin=true; AC_MSG_RESULT(yes),
-	cygwin=false; AC_MSG_RESULT(no),
+    ]
+  )],
+	[cygwin=true; AC_MSG_RESULT(yes)],
+	[cygwin=false; AC_MSG_RESULT(no)]
 )
 
 AC_CHECK_HEADERS([zlib.h])
@@ -213,10 +222,12 @@ AC_CHECK_HEADERS([ \
   fcntl.h \
   ifaddrs.h \
   mach/mach_time.h \
+  mach/mach.h \
   netdb.h \
   netinet/in.h \
   netinet/in6.h \
   netinet/tcp.h \
+  sys/un.h \
   poll.h \
   port.h \
   stdarg.h \
@@ -238,14 +249,21 @@ AC_CHECK_HEADERS([ \
   sys/timerfd.h \
   sys/uio.h \
   sys/wait.h \
+  sys/random.h \
   errno.h \
+  afunix.h \
 ])
 
-AC_CHECK_HEADERS(sys/sysctl.h, [], [], [
-#ifdef HAVE_SYS_PARAM_H
-#include <sys/param.h>
-#endif
-])
+case "${host_os}" in
+    linux*) ;;
+    *)
+        AC_CHECK_HEADERS(sys/sysctl.h, [], [], [
+        #ifdef HAVE_SYS_PARAM_H
+        #include <sys/param.h>
+        #endif
+        ])
+esac
+
 if test "x$ac_cv_header_sys_queue_h" = "xyes"; then
 	AC_MSG_CHECKING(for TAILQ_FOREACH in sys/queue.h)
 	AC_EGREP_CPP(yes,
@@ -318,7 +336,7 @@ if test "x$ac_cv_header_sys_time_h" = "xyes"; then
 fi
 
 if test "x$ac_cv_header_sys_sysctl_h" = "xyes"; then
-	AC_CHECK_DECLS([CTL_KERN, KERN_RANDOM, RANDOM_UUID, KERN_ARND], [], [],
+	AC_CHECK_DECLS([CTL_KERN, KERN_ARND], [], [],
 	   [[#include <sys/types.h>
 	     #include <sys/sysctl.h>]]
 	)
@@ -326,10 +344,11 @@ fi
 
 AM_CONDITIONAL(BUILD_WIN32, test x$bwin32 = xtrue)
 AM_CONDITIONAL(BUILD_CYGWIN, test x$cygwin = xtrue)
-AM_CONDITIONAL(BUILD_WITH_NO_UNDEFINED, test x$bwin32 = xtrue || test x$cygwin = xtrue)
+AM_CONDITIONAL(BUILD_MIDIPIX, test x$midipix = xtrue)
+AM_CONDITIONAL(BUILD_WITH_NO_UNDEFINED, test x$bwin32 = xtrue || test x$cygwin = xtrue || test x$midipix = xtrue)
 
 if test x$bwin32 = xtrue; then
-   AC_SEARCH_LIBS([getservbyname],[ws2_32])
+  AC_HAVE_LIBRARY([ws2_32])
 fi
 
 dnl Checks for typedefs, structures, and compiler characteristics.
@@ -342,17 +361,14 @@ AC_CHECK_FUNCS([ \
   accept4 \
   arc4random \
   arc4random_buf \
+  arc4random_addrandom \
   eventfd \
   epoll_create1 \
   fcntl \
   getegid \
   geteuid \
   getifaddrs \
-  getnameinfo \
-  getprotobynumber \
   gettimeofday \
-  inet_ntop \
-  inet_pton \
   issetugid \
   mach_absolute_time \
   mmap \
@@ -376,10 +392,36 @@ AC_CHECK_FUNCS([ \
   unsetenv \
   usleep \
   vasprintf \
-  getservbyname \
+  getrandom \
 ])
+
+AS_IF([test x$bwin32 = xtrue],
+  AC_CHECK_FUNCS(_gmtime64_s, , [AC_CHECK_FUNCS(_gmtime64)])
+)
+
 AM_CONDITIONAL(STRLCPY_IMPL, [test x"$ac_cv_func_strlcpy" = xno])
 
+m4_define([funcstochk],
+  [getnameinfo
+  getprotobynumber
+  getservbyname
+  inet_ntop
+  inet_pton]
+)
+
+AS_IF([test x$bwin32 = xtrue],
+  [AX_CHECK_DECLS_EX([funcstochk getaddrinfo],
+    [#ifdef _WIN32
+    #include <winsock2.h>
+    #include <ws2tcpip.h>
+    #endif])],
+  [AC_CHECK_FUNCS(m4_normalize(funcstochk))]
+)
+
+m4_undefine([funcstochk])
+
+dnl check getaddrinfo and gethostbyname_r for non-windows
+AS_IF([test x$bwin32 = xfalse], [
 AC_CACHE_CHECK(
     [for getaddrinfo],
     [libevent_cv_getaddrinfo],
@@ -425,27 +467,27 @@ AC_CHECK_FUNC(gethostbyname_r, [
      [Define this if gethostbyname_r takes 6 arguments])
     AC_MSG_RESULT(6)
   ], [
-    AC_TRY_COMPILE([
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
 #include <netdb.h>
     ], [
       char *cp1, *cp2;
       struct hostent *h1;
       int i1, i2;
       (void)gethostbyname_r(cp1,h1,cp2,i1,&i2);
-    ], [
+    ])], [
       AC_DEFINE(HAVE_GETHOSTBYNAME_R)
       AC_DEFINE(HAVE_GETHOSTBYNAME_R_5_ARG, 1,
         [Define this if gethostbyname_r takes 5 arguments])
       AC_MSG_RESULT(5)
-   ], [
-      AC_TRY_COMPILE([
+    ], [
+      AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
 #include <netdb.h>
      ], [
        char *cp1;
        struct hostent *h1;
        struct hostent_data hd;
        (void) gethostbyname_r(cp1,h1,&hd);
-     ], [
+     ])], [
        AC_DEFINE(HAVE_GETHOSTBYNAME_R)
        AC_DEFINE(HAVE_GETHOSTBYNAME_R_3_ARG, 1,
          [Define this if gethostbyname_r takes 3 arguments])
@@ -459,11 +501,12 @@ AC_CHECK_FUNC(gethostbyname_r, [
 ])
 
 fi
+]) dnl end of checking getaddrinfo and gethostbyname_r
 
 AC_MSG_CHECKING(for F_SETFD in fcntl.h)
 AC_EGREP_CPP(yes,
 [
-#define _GNU_SOURCE
+#define _GNU_SOURCE 1
 #include <fcntl.h>
 #ifdef F_SETFD
 yes
@@ -501,57 +544,64 @@ if test "x$ac_cv_header_sys_event_h" = "xyes"; then
 	AC_CHECK_FUNCS(kqueue, [havekqueue=yes], )
 	if test "x$havekqueue" = "xyes" ; then
 		AC_MSG_CHECKING(for working kqueue)
-		AC_TRY_RUN(
+		AC_RUN_IFELSE(
+      [AC_LANG_PROGRAM([
+#ifdef HAVE_STDLIB_H
+#include <stdlib.h>
+#endif
+#ifdef HAVE_STRING_H
+#include <string.h>
+#endif
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/event.h>
 #include <stdio.h>
 #include <unistd.h>
 #include <fcntl.h>
-
-int
-main(int argc, char **argv)
-{
+        ], [[
 	int kq;
 	int n;
-	int fd[[2]];
+	int fd[2];
 	struct kevent ev;
 	struct timespec ts;
-	char buf[[8000]];
+	char buf[80000];
 
 	if (pipe(fd) == -1)
-		exit(1);
-	if (fcntl(fd[[1]], F_SETFL, O_NONBLOCK) == -1)
-		exit(1);
+  		return 1;
+	if (fcntl(fd[1], F_SETFL, O_NONBLOCK) == -1)
+		return 1;
 
-	while ((n = write(fd[[1]], buf, sizeof(buf))) == sizeof(buf))
+	while ((n = write(fd[1], buf, sizeof(buf))) == sizeof(buf))
 		;
 
-        if ((kq = kqueue()) == -1)
-		exit(1);
+	if ((kq = kqueue()) == -1)
+		return 1;
 
 	memset(&ev, 0, sizeof(ev));
-	ev.ident = fd[[1]];
+	ev.ident = fd[1];
 	ev.filter = EVFILT_WRITE;
 	ev.flags = EV_ADD | EV_ENABLE;
 	n = kevent(kq, &ev, 1, NULL, 0, NULL);
 	if (n == -1)
-		exit(1);
+		return 1;
 
-	read(fd[[0]], buf, sizeof(buf));
+	read(fd[0], buf, sizeof(buf));
 
 	ts.tv_sec = 0;
 	ts.tv_nsec = 0;
 	n = kevent(kq, NULL, 0, &ev, 1, &ts);
 	if (n == -1 || n == 0)
-		exit(1);
-
-	exit(0);
-}, [AC_MSG_RESULT(yes)
-    AC_DEFINE(HAVE_WORKING_KQUEUE, 1,
-		[Define if kqueue works correctly with pipes])
-    havekqueue=yes
-    ], AC_MSG_RESULT(no), AC_MSG_RESULT(no))
+		return 1;
+
+	return 0;
+        ]]
+      )],
+      [AC_MSG_RESULT(yes)
+      AC_DEFINE(HAVE_WORKING_KQUEUE, 1,
+        [Define if kqueue works correctly with pipes])
+      havekqueue=yes
+      ], [AC_MSG_RESULT(no)], [AC_MSG_RESULT(no)]
+    )
 	fi
 fi
 AM_CONDITIONAL(KQUEUE_BACKEND, [test "x$havekqueue" = "xyes"])
@@ -567,7 +617,8 @@ fi
 if test "x$ac_cv_header_sys_epoll_h" = "xyes"; then
 	if test "x$haveepoll" = "xno" ; then
 		AC_MSG_CHECKING(for epoll system call)
-		AC_TRY_RUN(
+		AC_RUN_IFELSE(
+      [AC_LANG_PROGRAM([[
 #include <stdint.h>
 #include <sys/param.h>
 #include <sys/types.h>
@@ -580,45 +631,25 @@ epoll_create(int size)
 {
 	return (syscall(__NR_epoll_create, size));
 }
-
-int
-main(int argc, char **argv)
-{
+        ]],[[
 	int epfd;
 
 	epfd = epoll_create(256);
-	exit (epfd == -1 ? 1 : 0);
-}, [AC_MSG_RESULT(yes)
-    AC_DEFINE(HAVE_EPOLL, 1,
-	[Define if your system supports the epoll system calls])
-    needsignal=yes
-    have_epoll=yes
-    AC_LIBOBJ(epoll_sub)
-    ], AC_MSG_RESULT(no), AC_MSG_RESULT(no))
+	return (epfd == -1 ? 1 : 0);
+        ]]
+      )], 
+      [AC_MSG_RESULT(yes)
+      AC_DEFINE(HAVE_EPOLL, 1,
+	      [Define if your system supports the epoll system calls])
+      needsignal=yes
+      have_epoll=yes
+      AC_LIBOBJ(epoll_sub)
+      ], [AC_MSG_RESULT(no)], [AC_MSG_RESULT(no)]
+    )
 	fi
 fi
 AM_CONDITIONAL(EPOLL_BACKEND, [test "x$haveepoll" = "xyes"])
 
-AC_MSG_CHECKING(waitpid support WNOWAIT)
-AC_TRY_RUN(
-#include <unistd.h>
-#include <sys/types.h>
-#include <sys/wait.h>
-#include <stdlib.h>
-
-int
-main(int argc, char** argv)
-{
-    pid_t pid;
-    int status;
-    if ((pid = fork()) == 0) _exit(0);
-    _exit(waitpid(pid, &status, WNOWAIT) == -1);
-}, [AC_MSG_RESULT(yes)
-AC_DEFINE(HAVE_WAITPID_WITH_WNOWAIT, 1,
-[Define if waitpid() supports WNOWAIT])
-], AC_MSG_RESULT(no), AC_MSG_RESULT(no))
-
-
 haveeventports=no
 AC_CHECK_FUNCS(port_create, [haveeventports=yes], )
 if test "x$haveeventports" = "xyes" ; then
@@ -663,9 +694,10 @@ AC_CHECK_SIZEOF(short)
 AC_CHECK_SIZEOF(size_t)
 AC_CHECK_SIZEOF(void *)
 AC_CHECK_SIZEOF(off_t)
+AC_CHECK_SIZEOF(time_t)
 
-AC_CHECK_TYPES([struct in6_addr, struct sockaddr_in6, sa_family_t, struct addrinfo, struct sockaddr_storage], , ,
-[#define _GNU_SOURCE
+AC_CHECK_TYPES([struct in6_addr, struct sockaddr_in6, struct sockaddr_un, sa_family_t, struct addrinfo, struct sockaddr_storage], , ,
+[#define _GNU_SOURCE 1
 #include <sys/types.h>
 #ifdef HAVE_NETINET_IN_H
 #include <netinet/in.h>
@@ -673,6 +705,9 @@ AC_CHECK_TYPES([struct in6_addr, struct sockaddr_in6, sa_family_t, struct addrin
 #ifdef HAVE_NETINET_IN6_H
 #include <netinet/in6.h>
 #endif
+#ifdef HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
@@ -715,40 +750,54 @@ AC_CHECK_MEMBERS([struct in6_addr.s6_addr32, struct in6_addr.s6_addr16, struct s
 #endif
 ])
 
-AC_CHECK_TYPES([struct so_linger],
-[#define HAVE_SO_LINGER], ,
+AC_CHECK_TYPES([struct linger],,,
 [
 #ifdef HAVE_SYS_SOCKET_H
 #include <sys/socket.h>
 #endif
+#ifdef _WIN32
+#include <winsock2.h>
+#endif
 ])
 
 AC_MSG_CHECKING([for socklen_t])
-AC_TRY_COMPILE([
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([
  #include <sys/types.h>
- #include <sys/socket.h>],
-  [socklen_t x;],
-  AC_MSG_RESULT([yes]),
+ #ifdef _WIN32
+ #include <ws2tcpip.h>
+ #else
+ #include <sys/socket.h>
+ #endif
+    ],[socklen_t x;]
+  )],
+	[AC_MSG_RESULT([yes])],
   [AC_MSG_RESULT([no])
   AC_DEFINE(socklen_t, unsigned int,
-	[Define to unsigned int if you dont have it])]
+	  [Define to unsigned int if you dont have it])]
 )
 
+# __func__/__FUNCTION__ is not a macros in general
 AC_MSG_CHECKING([whether our compiler supports __func__])
-AC_TRY_COMPILE([],
- [ const char *cp = __func__; ],
- AC_MSG_RESULT([yes]),
- AC_MSG_RESULT([no])
- AC_MSG_CHECKING([whether our compiler supports __FUNCTION__])
- AC_TRY_COMPILE([],
-   [ const char *cp = __FUNCTION__; ],
-   AC_MSG_RESULT([yes])
-   AC_DEFINE(__func__, __FUNCTION__,
-         [Define to appropriate substitue if compiler doesnt have __func__]),
-   AC_MSG_RESULT([no])
-   AC_DEFINE(__func__, __FILE__,
-         [Define to appropriate substitue if compiler doesnt have __func__])))
-
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([],
+    [ const char *cp = __func__; ]
+  )],
+	[ AC_DEFINE(HAVE___func__, 1, [Define to 1 if compiler have __func__])
+    AC_MSG_RESULT([yes])
+  ],
+  [AC_MSG_RESULT([no])]
+)
+AC_MSG_CHECKING([whether our compiler supports __FUNCTION__])
+AC_COMPILE_IFELSE(
+  [AC_LANG_PROGRAM([],
+    [ const char *cp = __FUNCTION__; ]
+  )],
+	[ AC_DEFINE(HAVE___FUNCTION__, 1, [Define to 1 if compiler have __FUNCTION__])
+    AC_MSG_RESULT([yes])
+  ],
+  [AC_MSG_RESULT([no])]
+)
 
 # check if we can compile with pthreads
 have_pthreads=no
@@ -791,10 +840,6 @@ fi
 
 # check if we have and should use openssl
 AM_CONDITIONAL(OPENSSL, [test "$enable_openssl" != "no" && test "$have_openssl" = "yes"])
-if test "x$enable_openssl" = "xyes"; then
-	AC_SEARCH_LIBS([ERR_remove_thread_state], [crypto eay32],
-		[AC_DEFINE(HAVE_ERR_REMOVE_THREAD_STATE, 1, [Define to 1 if you have ERR_remove_thread_stat().])])
-fi
 
 # Add some more warnings which we use in development but not in the
 # released versions.  (Some relevant gcc versions can't handle these.)
@@ -820,7 +865,8 @@ if test x$enable_gcc_warnings != xno && test "$GCC" = "yes"; then
 #error
 #endif])], have_clang=yes, have_clang=no)
 
-  CFLAGS="$CFLAGS -W -Wfloat-equal -Wundef -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes -Wwrite-strings -Wredundant-decls -Wchar-subscripts -Wcomment -Wformat -Wwrite-strings -Wmissing-declarations -Wredundant-decls -Wnested-externs -Wbad-function-cast -Wswitch"
+  # -W is the same as -Wextra
+  CFLAGS="$CFLAGS -W -Wfloat-equal -Wundef -Wpointer-arith -Wstrict-prototypes -Wmissing-prototypes -Wwrite-strings -Wredundant-decls -Wmissing-declarations -Wnested-externs -Wbad-function-cast"
   if test x$enable_gcc_warnings = xyes; then
     CFLAGS="$CFLAGS -Werror"
   fi
@@ -853,7 +899,7 @@ if test x$enable_gcc_warnings != xno && test "$GCC" = "yes"; then
     # for minheap-internal.h related code.
     CFLAGS="$CFLAGS -Wno-unused-function"
 
-    # clang on macosx emits warnigns for each directory specified which
+    # clang on macosx emits warnings for each directory specified which
     # isn't "used" generating a lot of build noise (typically 3 warnings
     # per file
     case "$host_os" in
@@ -943,5 +989,19 @@ AC_SUBST([LIBEVENT_GC_SECTIONS])
 
 AM_CONDITIONAL([INSTALL_LIBEVENT], [test "$enable_libevent_install" = "yes"])
 
+# Doxygen support
+DX_HTML_FEATURE(ON)
+DX_MAN_FEATURE(OFF)
+DX_RTF_FEATURE(OFF)
+DX_XML_FEATURE(OFF)
+DX_PDF_FEATURE(OFF)
+DX_PS_FEATURE(OFF)
+DX_CHM_FEATURE(OFF)
+DX_CHI_FEATURE(OFF)
+DX_INIT_DOXYGEN([libevent], [${top_srcdir}/Doxyfile], [doxygen])
+
+AM_CONDITIONAL([ENABLE_DOXYGEN], [test "$DX_FLAG_doc" = "1"])
+AM_CONDITIONAL([ENABLE_DOXYGEN_MAN], [test "$DX_FLAG_man" = "1"])
+
 AC_CONFIG_FILES( [libevent.pc libevent_openssl.pc libevent_pthreads.pc libevent_core.pc libevent_extra.pc] )
 AC_OUTPUT(Makefile)
diff --git a/ipc/chromium/src/third_party/libevent/defer-internal.h b/ipc/chromium/src/third_party/libevent/defer-internal.h
index e3c7d7da5b39..d6f80a1180aa 100644
--- a/ipc/chromium/src/third_party/libevent/defer-internal.h
+++ b/ipc/chromium/src/third_party/libevent/defer-internal.h
@@ -46,6 +46,7 @@ typedef void (*deferred_cb_fn)(struct event_callback *, void *);
    @param cb The function to run when the struct event_callback executes.
    @param arg The function's second argument.
  */
+EVENT2_EXPORT_SYMBOL
 void event_deferred_cb_init_(struct event_callback *, ev_uint8_t, deferred_cb_fn, void *);
 /**
    Change the priority of a non-pending event_callback.
@@ -54,12 +55,14 @@ void event_deferred_cb_set_priority_(struct event_callback *, ev_uint8_t);
 /**
    Cancel a struct event_callback if it is currently scheduled in an event_base.
  */
+EVENT2_EXPORT_SYMBOL
 void event_deferred_cb_cancel_(struct event_base *, struct event_callback *);
 /**
    Activate a struct event_callback if it is not currently scheduled in an event_base.
 
    Return true if it was not previously scheduled.
  */
+EVENT2_EXPORT_SYMBOL
 int event_deferred_cb_schedule_(struct event_base *, struct event_callback *);
 
 #ifdef __cplusplus
diff --git a/ipc/chromium/src/third_party/libevent/doxygen.am b/ipc/chromium/src/third_party/libevent/doxygen.am
new file mode 100644
index 000000000000..916d7c4079b2
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/doxygen.am
@@ -0,0 +1,55 @@
+# Doxygen documentation will not be generated with default configuration,
+# unless '--enable-doxygen-doc' is configured.
+# The following targets are all about doxygen:
+# make                # 'make doxygen' would be auto executed
+# make doxygen        # generating doxygen documentation
+# make doxygen-doc    # same as 'make doxygen'
+# make clean          # clean docs generated by doxygen
+# make install        # install doxygen documentation
+# make uninstall      # uninstall doxygen documentation
+
+if ENABLE_DOXYGEN
+
+# Add all needed rules defined in ax_prog_doxygen.m4
+@DX_RULES@
+
+# Use 'make clean' to clean docs generated by doxygen.
+clean-local:
+	-rm -rf $(DX_CLEANFILES)
+
+# integrate doxygen with automake targets
+man3_MANS = @DX_DOCDIR@/man/man3/*
+$(man3_MANS): doxygen-doc
+
+# Docs will be installed. It may be one or more docs supported
+# by doxygen, but does not include 'man'.
+docdirs = $(DX_INSTALL_DOCS)
+
+# Rules for installing docs generated by doxygen into $(htmldir),
+# The typical value of $(htmldir) is '/usr/local/share/doc/$(PACKAGE)'
+install-data-local:
+	@if ! test -d "$(DESTDIR)$(htmldir)"; then \
+	  echo "$(mkinstalldirs) '$(DESTDIR)$(htmldir)'"; \
+	  $(mkinstalldirs) '$(DESTDIR)$(htmldir)'; \
+	fi
+	@for d in $(docdirs); do \
+	  echo "cp -pR $$d '$(DESTDIR)$(htmldir)/'"; \
+	  cp -pR $$d '$(DESTDIR)$(htmldir)/'; \
+	done
+
+# Rules for uninstalling docs generated by doxygen from $(htmldir)
+uninstall-local:
+	@for d in $(docdirs); do \
+	  d=`basename $$d`; \
+	  echo "test ! -d '$(DESTDIR)$(htmldir)/'$$d || \
+	  { find '$(DESTDIR)$(htmldir)/'$$d -type d ! -perm -200 -exec chmod u+w '{}' ';' && \
+	  rm -rf '$(DESTDIR)$(htmldir)/'$$d; }"; \
+	  test ! -d '$(DESTDIR)$(htmldir)/'$$d || \
+	  { find '$(DESTDIR)$(htmldir)/'$$d -type d ! -perm -200 -exec chmod u+w '{}' ';' && \
+	  rm -rf '$(DESTDIR)$(htmldir)/'$$d; }; \
+	done
+	rmdir "$(DESTDIR)$(htmldir)/" || true
+
+doxygen: doxygen-doc
+
+endif ENABLE_DOXYGEN
diff --git a/ipc/chromium/src/third_party/libevent/epoll.c b/ipc/chromium/src/third_party/libevent/epoll.c
index bf730b23db8f..bdec2e45695d 100644
--- a/ipc/chromium/src/third_party/libevent/epoll.c
+++ b/ipc/chromium/src/third_party/libevent/epoll.c
@@ -281,7 +281,7 @@ epoll_apply_one_change(struct event_base *base,
 		return 0;
 	}
 
-	if ((ch->read_change|ch->write_change) & EV_CHANGE_ET)
+	if ((ch->read_change|ch->write_change|ch->close_change) & EV_CHANGE_ET)
 		events |= EPOLLET;
 
 	memset(&epev, 0, sizeof(epev));
@@ -401,11 +401,14 @@ epoll_nochangelist_del(struct event_base *base, evutil_socket_t fd,
 	ch.old_events = old;
 	ch.read_change = ch.write_change = ch.close_change = 0;
 	if (events & EV_WRITE)
-		ch.write_change = EV_CHANGE_DEL;
+		ch.write_change = EV_CHANGE_DEL |
+		    (events & EV_ET);
 	if (events & EV_READ)
-		ch.read_change = EV_CHANGE_DEL;
+		ch.read_change = EV_CHANGE_DEL |
+		    (events & EV_ET);
 	if (events & EV_CLOSED)
-		ch.close_change = EV_CHANGE_DEL;
+		ch.close_change = EV_CHANGE_DEL |
+		    (events & EV_ET);
 
 	return epoll_apply_one_change(base, base->evbase, &ch);
 }
@@ -483,7 +486,9 @@ epoll_dispatch(struct event_base *base, struct timeval *tv)
 			continue;
 #endif
 
-		if (what & (EPOLLHUP|EPOLLERR)) {
+		if (what & EPOLLERR) {
+			ev = EV_READ | EV_WRITE;
+		} else if ((what & EPOLLHUP) && !(what & EPOLLRDHUP)) {
 			ev = EV_READ | EV_WRITE;
 		} else {
 			if (what & EPOLLIN)
diff --git a/ipc/chromium/src/third_party/libevent/epolltable-internal.h b/ipc/chromium/src/third_party/libevent/epolltable-internal.h
index da30e0973a27..73c2e3647e29 100644
--- a/ipc/chromium/src/third_party/libevent/epolltable-internal.h
+++ b/ipc/chromium/src/third_party/libevent/epolltable-internal.h
@@ -34,7 +34,7 @@
   Note also that this table is a little sparse, since ADD+DEL is
   nonsensical ("xxx" in the list below.)
 
-  Note also also that we are shifting old_events by only 5 bits, since
+  Note also that we are shifting old_events by only 5 bits, since
   EV_READ is 2 and EV_WRITE is 4.
 
   The table was auto-generated with a python script, according to this
diff --git a/ipc/chromium/src/third_party/libevent/evbuffer-internal.h b/ipc/chromium/src/third_party/libevent/evbuffer-internal.h
index cf4bddc80ea8..d09b4f1ddd58 100644
--- a/ipc/chromium/src/third_party/libevent/evbuffer-internal.h
+++ b/ipc/chromium/src/third_party/libevent/evbuffer-internal.h
@@ -92,7 +92,7 @@ struct evbuffer {
 	 * If the buffer has no chains, it is NULL.
 	 *
 	 * The last_with_datap pointer points at _whatever 'next' pointer_
-	 * points at the last_with_datap chain.  If the last_with_data chain
+	 * pointing at the last_with_data chain. If the last_with_data chain
 	 * is the first chain, or it is NULL, then the last_with_datap pointer
 	 * is &buf->first.
 	 */
diff --git a/ipc/chromium/src/third_party/libevent/evconfig-private.h b/ipc/chromium/src/third_party/libevent/evconfig-private.h
index f6b08e353e84..31e610040ece 100644
--- a/ipc/chromium/src/third_party/libevent/evconfig-private.h
+++ b/ipc/chromium/src/third_party/libevent/evconfig-private.h
@@ -46,4 +46,11 @@
 /* #undef _POSIX_SOURCE */
 #endif
 
+/* Enable POSIX.2 extensions on QNX for getopt */
+#ifdef __QNX__
+# ifndef __EXT_POSIX2
+#  define __EXT_POSIX2
+# endif
+#endif
+
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/evconfig-private.h.cmake b/ipc/chromium/src/third_party/libevent/evconfig-private.h.cmake
index 32f04794d28c..1adf9c03d1b4 100644
--- a/ipc/chromium/src/third_party/libevent/evconfig-private.h.cmake
+++ b/ipc/chromium/src/third_party/libevent/evconfig-private.h.cmake
@@ -32,4 +32,9 @@
 /* Define to 1 if you need to in order for `stat' and other things to work. */
 #cmakedefine _POSIX_SOURCE 1
 
+/* Enable POSIX.2 extensions on QNX for getopt */
+#ifdef __QNX__
+#cmakedefine __EXT_POSIX2 1
+#endif
+
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/evconfig-private.h.in b/ipc/chromium/src/third_party/libevent/evconfig-private.h.in
index 7b3dfdb10e90..8cd647874332 100644
--- a/ipc/chromium/src/third_party/libevent/evconfig-private.h.in
+++ b/ipc/chromium/src/third_party/libevent/evconfig-private.h.in
@@ -45,4 +45,11 @@
 #undef _POSIX_SOURCE
 #endif
 
+/* Enable POSIX.2 extensions on QNX for getopt */
+#ifdef __QNX__
+# ifndef __EXT_POSIX2
+#  define __EXT_POSIX2
+# endif
+#endif
+
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/evdns.c b/ipc/chromium/src/third_party/libevent/evdns.c
index e9dbc35c6066..a5b31a3c0017 100644
--- a/ipc/chromium/src/third_party/libevent/evdns.c
+++ b/ipc/chromium/src/third_party/libevent/evdns.c
@@ -77,6 +77,7 @@
 #include <stdarg.h>
 #ifdef _WIN32
 #include <winsock2.h>
+#include <winerror.h>
 #include <ws2tcpip.h>
 #ifndef _WIN32_IE
 #define _WIN32_IE 0x400
@@ -346,6 +347,9 @@ struct evdns_base {
 
 	struct timeval global_getaddrinfo_allow_skew;
 
+	int so_rcvbuf;
+	int so_sndbuf;
+
 	int getaddrinfo_ipv4_timeouts;
 	int getaddrinfo_ipv6_timeouts;
 	int getaddrinfo_ipv4_answered;
@@ -863,6 +867,19 @@ reply_schedule_callback(struct request *const req, u32 ttl, u32 err, struct repl
 		&d->deferred);
 }
 
+
+#define _QR_MASK    0x8000U
+#define _OP_MASK    0x7800U
+#define _AA_MASK    0x0400U
+#define _TC_MASK    0x0200U
+#define _RD_MASK    0x0100U
+#define _RA_MASK    0x0080U
+#define _Z_MASK     0x0040U
+#define _AD_MASK    0x0020U
+#define _CD_MASK    0x0010U
+#define _RCODE_MASK 0x000fU
+#define _Z_MASK_DEPRECATED 0x0070U
+
 /* this processes a parsed reply packet */
 static void
 reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply) {
@@ -876,12 +893,12 @@ reply_handle(struct request *const req, u16 flags, u32 ttl, struct reply *reply)
 	ASSERT_LOCKED(req->base);
 	ASSERT_VALID_REQUEST(req);
 
-	if (flags & 0x020f || !reply || !reply->have_answer) {
+	if (flags & (_RCODE_MASK | _TC_MASK) || !reply || !reply->have_answer) {
 		/* there was an error */
-		if (flags & 0x0200) {
+		if (flags & _TC_MASK) {
 			error = DNS_ERR_TRUNCATED;
-		} else if (flags & 0x000f) {
-			u16 error_code = (flags & 0x000f) - 1;
+		} else if (flags & _RCODE_MASK) {
+			u16 error_code = (flags & _RCODE_MASK) - 1;
 			if (error_code > 4) {
 				error = DNS_ERR_UNKNOWN;
 			} else {
@@ -1046,8 +1063,8 @@ reply_parse(struct evdns_base *base, u8 *packet, int length) {
 	memset(&reply, 0, sizeof(reply));
 
 	/* If it's not an answer, it doesn't correspond to any request. */
-	if (!(flags & 0x8000)) return -1;  /* must be an answer */
-	if ((flags & 0x020f) && (flags & 0x020f) != DNS_ERR_NOTEXIST) {
+	if (!(flags & _QR_MASK)) return -1;  /* must be an answer */
+	if ((flags & (_RCODE_MASK|_TC_MASK)) && (flags & (_RCODE_MASK|_TC_MASK)) != DNS_ERR_NOTEXIST) {
 		/* there was an error and it's not NXDOMAIN */
 		goto err;
 	}
@@ -1236,8 +1253,8 @@ request_parse(u8 *packet, int length, struct evdns_server_port *port, struct soc
 	(void)additional;
 	(void)authority;
 
-	if (flags & 0x8000) return -1; /* Must not be an answer. */
-	flags &= 0x0110; /* Only RD and CD get preserved. */
+	if (flags & _QR_MASK) return -1; /* Must not be an answer. */
+	flags &= (_RD_MASK|_CD_MASK); /* Only RD and CD get preserved. */
 
 	server_req = mm_malloc(sizeof(struct server_request));
 	if (server_req == NULL) return -1;
@@ -1277,7 +1294,7 @@ request_parse(u8 *packet, int length, struct evdns_server_port *port, struct soc
 	port->refcnt++;
 
 	/* Only standard queries are supported. */
-	if (flags & 0x7800) {
+	if (flags & _OP_MASK) {
 		evdns_server_request_respond(&(server_req->base), DNS_ERR_NOTIMPL);
 		return -1;
 	}
@@ -1286,14 +1303,12 @@ request_parse(u8 *packet, int length, struct evdns_server_port *port, struct soc
 
 	return 0;
 err:
-	if (server_req) {
-		if (server_req->base.questions) {
-			for (i = 0; i < server_req->base.nquestions; ++i)
-				mm_free(server_req->base.questions[i]);
-			mm_free(server_req->base.questions);
-		}
-		mm_free(server_req);
+	if (server_req->base.questions) {
+		for (i = 0; i < server_req->base.nquestions; ++i)
+			mm_free(server_req->base.questions[i]);
+		mm_free(server_req->base.questions);
 	}
+	mm_free(server_req);
 	return -1;
 
 #undef SKIP_NAME
@@ -1751,6 +1766,7 @@ evdns_close_server_port(struct evdns_server_port *port)
 		server_port_free(port);
 	} else {
 		port->closing = 1;
+		EVDNS_UNLOCK(port);
 	}
 }
 
@@ -1904,7 +1920,7 @@ evdns_server_request_format_response(struct server_request *req, int err)
 	/* Set response bit and error code; copy OPCODE and RD fields from
 	 * question; copy RA and AA if set by caller. */
 	flags = req->base.flags;
-	flags |= (0x8000 | err);
+	flags |= (_QR_MASK | err);
 
 	dnslabel_table_init(&table);
 	APPEND16(req->trans_id);
@@ -2265,10 +2281,11 @@ evdns_request_transmit(struct request *req) {
 		nameserver_write_waiting(req->ns, 1);
 		return 1;
 	case 2:
-		/* failed to transmit the request entirely. */
+		/* failed to transmit the request entirely. we can fallthrough since
+		 * we'll set a timeout, which will time out, and make us retransmit the
+		 * request anyway. */
 		retcode = 1;
-		/* fall through: we'll set a timeout, which will time out,
-		 * and make us retransmit the request anyway. */
+		EVUTIL_FALLTHROUGH;
 	default:
 		/* all ok */
 		log(EVDNS_LOG_DEBUG,
@@ -2525,6 +2542,23 @@ evdns_nameserver_add_impl_(struct evdns_base *base, const struct sockaddr *addre
 		}
 	}
 
+	if (base->so_rcvbuf) {
+		if (setsockopt(ns->socket, SOL_SOCKET, SO_RCVBUF,
+		    (void *)&base->so_rcvbuf, sizeof(base->so_rcvbuf))) {
+			log(EVDNS_LOG_WARN, "Couldn't set SO_RCVBUF to %i", base->so_rcvbuf);
+			err = -SO_RCVBUF;
+			goto out2;
+		}
+	}
+	if (base->so_sndbuf) {
+		if (setsockopt(ns->socket, SOL_SOCKET, SO_SNDBUF,
+		    (void *)&base->so_sndbuf, sizeof(base->so_sndbuf))) {
+			log(EVDNS_LOG_WARN, "Couldn't set SO_SNDBUF to %i", base->so_sndbuf);
+			err = -SO_SNDBUF;
+			goto out2;
+		}
+	}
+
 	memcpy(&ns->address, address, addrlen);
 	ns->addrlen = addrlen;
 	ns->state = 1;
@@ -3313,10 +3347,16 @@ search_request_finished(struct evdns_request *const handle) {
 
 static void
 evdns_resolv_set_defaults(struct evdns_base *base, int flags) {
+	int add_default = flags & DNS_OPTION_NAMESERVERS;
+	if (flags & DNS_OPTION_NAMESERVERS_NO_DEFAULT)
+		add_default = 0;
+
 	/* if the file isn't found then we assume a local resolver */
 	ASSERT_LOCKED(base);
-	if (flags & DNS_OPTION_SEARCH) search_set_from_hostname(base);
-	if (flags & DNS_OPTION_NAMESERVERS) evdns_base_nameserver_ip_add(base,"127.0.0.1");
+	if (flags & DNS_OPTION_SEARCH)
+		search_set_from_hostname(base);
+	if (add_default)
+		evdns_base_nameserver_ip_add(base, "127.0.0.1");
 }
 
 #ifndef EVENT__HAVE_STRTOK_R
@@ -3491,6 +3531,7 @@ evdns_base_set_option_impl(struct evdns_base *base,
 		base->global_max_retransmits = retries;
 	} else if (str_matches_option(option, "randomize-case:")) {
 		int randcase = strtoint(val);
+		if (randcase == -1) return -1;
 		if (!(flags & DNS_OPTION_MISC)) return 0;
 		base->global_randomize_case = randcase;
 	} else if (str_matches_option(option, "bind-to:")) {
@@ -3512,6 +3553,18 @@ evdns_base_set_option_impl(struct evdns_base *base,
 		    val);
 		memcpy(&base->global_nameserver_probe_initial_timeout, &tv,
 		    sizeof(tv));
+	} else if (str_matches_option(option, "so-rcvbuf:")) {
+		int buf = strtoint(val);
+		if (buf == -1) return -1;
+		if (!(flags & DNS_OPTION_MISC)) return 0;
+		log(EVDNS_LOG_DEBUG, "Setting SO_RCVBUF to %s", val);
+		base->so_rcvbuf = buf;
+	} else if (str_matches_option(option, "so-sndbuf:")) {
+		int buf = strtoint(val);
+		if (buf == -1) return -1;
+		if (!(flags & DNS_OPTION_MISC)) return 0;
+		log(EVDNS_LOG_DEBUG, "Setting SO_SNDBUF to %s", val);
+		base->so_sndbuf = buf;
 	}
 	return 0;
 }
@@ -3612,9 +3665,14 @@ evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char
 	char *resolv;
 	char *start;
 	int err = 0;
+	int add_default;
 
 	log(EVDNS_LOG_DEBUG, "Parsing resolv.conf file %s", filename);
 
+	add_default = flags & DNS_OPTION_NAMESERVERS;
+	if (flags & DNS_OPTION_NAMESERVERS_NO_DEFAULT)
+		add_default = 0;
+
 	if (flags & DNS_OPTION_HOSTSFILE) {
 		char *fname = evdns_get_default_hosts_filename();
 		evdns_base_load_hosts(base, fname);
@@ -3622,6 +3680,11 @@ evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char
 			mm_free(fname);
 	}
 
+	if (!filename) {
+		evdns_resolv_set_defaults(base, flags);
+		return 1;
+	}
+
 	if ((err = evutil_read_file_(filename, &resolv, &n, 0)) < 0) {
 		if (err == -1) {
 			/* No file. */
@@ -3645,7 +3708,7 @@ evdns_base_resolv_conf_parse_impl(struct evdns_base *base, int flags, const char
 		}
 	}
 
-	if (!base->server_head && (flags & DNS_OPTION_NAMESERVERS)) {
+	if (!base->server_head && add_default) {
 		/* no nameservers were configured. */
 		evdns_base_nameserver_ip_add(base, "127.0.0.1");
 		err = 6;
@@ -3946,7 +4009,12 @@ evdns_base_new(struct event_base *event_base, int flags)
 
 	TAILQ_INIT(&base->hostsdb);
 
-#define EVDNS_BASE_ALL_FLAGS (0x8001)
+#define EVDNS_BASE_ALL_FLAGS ( \
+	EVDNS_BASE_INITIALIZE_NAMESERVERS | \
+	EVDNS_BASE_DISABLE_WHEN_INACTIVE  | \
+	EVDNS_BASE_NAMESERVERS_NO_DEFAULT | \
+	0)
+
 	if (flags & ~EVDNS_BASE_ALL_FLAGS) {
 		flags = EVDNS_BASE_INITIALIZE_NAMESERVERS;
 		log(EVDNS_LOG_WARN,
@@ -3957,12 +4025,17 @@ evdns_base_new(struct event_base *event_base, int flags)
 
 	if (flags & EVDNS_BASE_INITIALIZE_NAMESERVERS) {
 		int r;
+		int opts = DNS_OPTIONS_ALL;
+		if (flags & EVDNS_BASE_NAMESERVERS_NO_DEFAULT) {
+			opts |= DNS_OPTION_NAMESERVERS_NO_DEFAULT;
+		}
+
 #ifdef _WIN32
 		r = evdns_base_config_windows_nameservers(base);
 #else
-		r = evdns_base_resolv_conf_parse(base, DNS_OPTIONS_ALL, "/etc/resolv.conf");
+		r = evdns_base_resolv_conf_parse(base, opts, "/etc/resolv.conf");
 #endif
-		if (r == -1) {
+		if (r) {
 			evdns_base_free_and_unlock(base, 0);
 			return NULL;
 		}
@@ -4036,6 +4109,11 @@ evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)
 
 	/* TODO(nickm) we might need to refcount here. */
 
+	while (base->req_waiting_head) {
+		if (fail_requests)
+			reply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);
+		request_finished(base->req_waiting_head, &base->req_waiting_head, 1);
+	}
 	for (i = 0; i < base->n_req_heads; ++i) {
 		while (base->req_heads[i]) {
 			if (fail_requests)
@@ -4043,11 +4121,6 @@ evdns_base_free_and_unlock(struct evdns_base *base, int fail_requests)
 			request_finished(base->req_heads[i], &REQ_HEAD(base, base->req_heads[i]->trans_id), 1);
 		}
 	}
-	while (base->req_waiting_head) {
-		if (fail_requests)
-			reply_schedule_callback(base->req_waiting_head, 0, DNS_ERR_SHUTDOWN, NULL);
-		request_finished(base->req_waiting_head, &base->req_waiting_head, 1);
-	}
 	base->global_requests_inflight = base->global_requests_waiting = 0;
 
 	for (server = base->server_head; server; server = server_next) {
@@ -4636,6 +4709,7 @@ evdns_getaddrinfo(struct evdns_base *dns_base,
 	int err;
 	int port = 0;
 	int want_cname = 0;
+	int started = 0;
 
 	if (!dns_base) {
 		dns_base = current_base;
@@ -4714,6 +4788,8 @@ evdns_getaddrinfo(struct evdns_base *dns_base,
 	 * launching those requests. (XXX we don't do that yet.)
 	 */
 
+	EVDNS_LOCK(dns_base);
+
 	if (hints.ai_family != PF_INET6) {
 		log(EVDNS_LOG_DEBUG, "Sending request for %s on ipv4 as %p",
 		    nodename, &data->ipv4_request);
@@ -4740,7 +4816,11 @@ evdns_getaddrinfo(struct evdns_base *dns_base,
 	evtimer_assign(&data->timeout, dns_base->event_base,
 	    evdns_getaddrinfo_timeout_cb, data);
 
-	if (data->ipv4_request.r || data->ipv6_request.r) {
+	started = (data->ipv4_request.r || data->ipv6_request.r);
+
+	EVDNS_UNLOCK(dns_base);
+
+	if (started) {
 		return data;
 	} else {
 		mm_free(data);
diff --git a/ipc/chromium/src/third_party/libevent/event-config.h.cmake b/ipc/chromium/src/third_party/libevent/event-config.h.cmake
index c1355be91485..fccf0cf05970 100644
--- a/ipc/chromium/src/third_party/libevent/event-config.h.cmake
+++ b/ipc/chromium/src/third_party/libevent/event-config.h.cmake
@@ -36,394 +36,412 @@
 #define EVENT__PACKAGE_TARNAME ""
 
 /* Define if libevent should build without support for a debug mode */
-#cmakedefine EVENT__DISABLE_DEBUG_MODE
+#cmakedefine EVENT__DISABLE_DEBUG_MODE 1
 
 /* Define if libevent should not allow replacing the mm functions */
-#cmakedefine EVENT__DISABLE_MM_REPLACEMENT
+#cmakedefine EVENT__DISABLE_MM_REPLACEMENT 1
 
 /* Define if libevent should not be compiled with thread support */
-#cmakedefine EVENT__DISABLE_THREAD_SUPPORT
+#cmakedefine EVENT__DISABLE_THREAD_SUPPORT 1
 
 /* Define to 1 if you have the `accept4' function. */
-#cmakedefine EVENT__HAVE_ACCEPT4
+#cmakedefine EVENT__HAVE_ACCEPT4 1
 
 /* Define to 1 if you have the `arc4random' function. */
-#cmakedefine EVENT__HAVE_ARC4RANDOM
+#cmakedefine EVENT__HAVE_ARC4RANDOM 1
 
 /* Define to 1 if you have the `arc4random_buf' function. */
-#cmakedefine EVENT__HAVE_ARC4RANDOM_BUF
+#cmakedefine EVENT__HAVE_ARC4RANDOM_BUF 1
+
+/* Define to 1 if you have the `arc4random_addrandom' function. */
+#cmakedefine EVENT__HAVE_ARC4RANDOM_ADDRANDOM 1
 
 /* Define if clock_gettime is available in libc */
-#cmakedefine EVENT__DNS_USE_CPU_CLOCK_FOR_ID
+#cmakedefine EVENT__DNS_USE_CPU_CLOCK_FOR_ID 1
 
 /* Define is no secure id variant is available */
-#cmakedefine EVENT__DNS_USE_GETTIMEOFDAY_FOR_ID
-#cmakedefine EVENT__DNS_USE_FTIME_FOR_ID
+#cmakedefine EVENT__DNS_USE_GETTIMEOFDAY_FOR_ID 1
+#cmakedefine EVENT__DNS_USE_FTIME_FOR_ID 1
 
 /* Define to 1 if you have the <arpa/inet.h> header file. */
-#cmakedefine EVENT__HAVE_ARPA_INET_H
+#cmakedefine EVENT__HAVE_ARPA_INET_H 1
 
 /* Define to 1 if you have the `clock_gettime' function. */
-#cmakedefine EVENT__HAVE_CLOCK_GETTIME
+#cmakedefine EVENT__HAVE_CLOCK_GETTIME 1
 
 /* Define to 1 if you have the declaration of `CTL_KERN'. */
-#cmakedefine EVENT__HAVE_DECL_CTL_KERN
+#define EVENT__HAVE_DECL_CTL_KERN @EVENT__HAVE_DECL_CTL_KERN@
 
 /* Define to 1 if you have the declaration of `KERN_ARND'. */
-#cmakedefine EVENT__HAVE_DECL_KERN_ARND
+#define EVENT__HAVE_DECL_KERN_ARND @EVENT__HAVE_DECL_KERN_ARND@
 
-/* Define to 1 if you have the declaration of `KERN_RANDOM'. */
-#cmakedefine EVENT__HAVE_DECL_KERN_RANDOM
+/* Define to 1 if you have `getrandom' function. */
+#cmakedefine EVENT__HAVE_GETRANDOM 1
 
 /* Define if /dev/poll is available */
-#cmakedefine EVENT__HAVE_DEVPOLL
+#cmakedefine EVENT__HAVE_DEVPOLL 1
 
 /* Define to 1 if you have the <netdb.h> header file. */
-#cmakedefine EVENT__HAVE_NETDB_H
+#cmakedefine EVENT__HAVE_NETDB_H 1
 
 /* Define to 1 if fd_mask type is defined */
-#cmakedefine EVENT__HAVE_FD_MASK
+#cmakedefine EVENT__HAVE_FD_MASK 1
 
 /* Define to 1 if the <sys/queue.h> header file defines TAILQ_FOREACH. */
-#cmakedefine EVENT__HAVE_TAILQFOREACH
+#cmakedefine EVENT__HAVE_TAILQFOREACH 1
 
 /* Define to 1 if you have the <dlfcn.h> header file. */
-#cmakedefine EVENT__HAVE_DLFCN_H
+#cmakedefine EVENT__HAVE_DLFCN_H 1
 
 /* Define if your system supports the epoll system calls */
-#cmakedefine EVENT__HAVE_EPOLL
+#cmakedefine EVENT__HAVE_EPOLL 1
 
 /* Define to 1 if you have the `epoll_create1' function. */
-#cmakedefine EVENT__HAVE_EPOLL_CREATE1
+#cmakedefine EVENT__HAVE_EPOLL_CREATE1 1
 
 /* Define to 1 if you have the `epoll_ctl' function. */
-#cmakedefine EVENT__HAVE_EPOLL_CTL
+#cmakedefine EVENT__HAVE_EPOLL_CTL 1
 
 /* Define to 1 if you have the `eventfd' function. */
-#cmakedefine EVENT__HAVE_EVENTFD
+#cmakedefine EVENT__HAVE_EVENTFD 1
 
 /* Define if your system supports event ports */
-#cmakedefine EVENT__HAVE_EVENT_PORTS
+#cmakedefine EVENT__HAVE_EVENT_PORTS 1
 
 /* Define to 1 if you have the `fcntl' function. */
-#cmakedefine EVENT__HAVE_FCNTL
+#cmakedefine EVENT__HAVE_FCNTL 1
 
 /* Define to 1 if you have the <fcntl.h> header file. */
-#cmakedefine EVENT__HAVE_FCNTL_H
+#cmakedefine EVENT__HAVE_FCNTL_H 1
 
 /* Define to 1 if you have the `getaddrinfo' function. */
-#cmakedefine EVENT__HAVE_GETADDRINFO
+#cmakedefine EVENT__HAVE_GETADDRINFO 1
 
 /* Define to 1 if you have the `getegid' function. */
-#cmakedefine EVENT__HAVE_GETEGID
+#cmakedefine EVENT__HAVE_GETEGID 1
 
 /* Define to 1 if you have the `geteuid' function. */
-#cmakedefine EVENT__HAVE_GETEUID
+#cmakedefine EVENT__HAVE_GETEUID 1
 
 /* TODO: Check for different gethostname argument counts. CheckPrototypeDefinition.cmake can be used. */
 /* Define this if you have any gethostbyname_r() */
-#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R
+#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R 1
 
 /* Define this if gethostbyname_r takes 3 arguments */
-#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R_3_ARG
+#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R_3_ARG 1
 
 /* Define this if gethostbyname_r takes 5 arguments */
-#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R_5_ARG
+#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R_5_ARG 1
 
 /* Define this if gethostbyname_r takes 6 arguments */
-#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R_6_ARG
+#cmakedefine EVENT__HAVE_GETHOSTBYNAME_R_6_ARG 1
 
 /* Define to 1 if you have the `getifaddrs' function. */
-#cmakedefine EVENT__HAVE_GETIFADDRS
+#cmakedefine EVENT__HAVE_GETIFADDRS 1
 
 /* Define to 1 if you have the `getnameinfo' function. */
-#cmakedefine EVENT__HAVE_GETNAMEINFO
+#cmakedefine EVENT__HAVE_GETNAMEINFO 1
 
 /* Define to 1 if you have the `getprotobynumber' function. */
-#cmakedefine EVENT__HAVE_GETPROTOBYNUMBER
+#cmakedefine EVENT__HAVE_GETPROTOBYNUMBER 1
 
 /* Define to 1 if you have the `getservbyname' function. */
-#cmakedefine EVENT__HAVE_GETSERVBYNAME
+#cmakedefine EVENT__HAVE_GETSERVBYNAME 1
 
 /* Define to 1 if you have the `gettimeofday' function. */
-#cmakedefine EVENT__HAVE_GETTIMEOFDAY
+#cmakedefine EVENT__HAVE_GETTIMEOFDAY 1
 
 /* Define to 1 if you have the <ifaddrs.h> header file. */
-#cmakedefine EVENT__HAVE_IFADDRS_H
+#cmakedefine EVENT__HAVE_IFADDRS_H 1
 
 /* Define to 1 if you have the `inet_ntop' function. */
-#cmakedefine EVENT__HAVE_INET_NTOP
+#cmakedefine EVENT__HAVE_INET_NTOP 1
 
 /* Define to 1 if you have the `inet_pton' function. */
-#cmakedefine EVENT__HAVE_INET_PTON
+#cmakedefine EVENT__HAVE_INET_PTON 1
 
 /* Define to 1 if you have the <inttypes.h> header file. */
-#cmakedefine EVENT__HAVE_INTTYPES_H
+#cmakedefine EVENT__HAVE_INTTYPES_H 1
 
 /* Define to 1 if you have the `issetugid' function. */
-#cmakedefine EVENT__HAVE_ISSETUGID
+#cmakedefine EVENT__HAVE_ISSETUGID 1
 
 /* Define to 1 if you have the `kqueue' function. */
-#cmakedefine EVENT__HAVE_KQUEUE
+#cmakedefine EVENT__HAVE_KQUEUE 1
 
 /* Define if the system has zlib */
-#cmakedefine EVENT__HAVE_LIBZ
+#cmakedefine EVENT__HAVE_LIBZ 1
 
 /* Define to 1 if you have the `mach_absolute_time' function. */
-#cmakedefine EVENT__HAVE_MACH_ABSOLUTE_TIME
+#cmakedefine EVENT__HAVE_MACH_ABSOLUTE_TIME 1
 
 /* Define to 1 if you have the <mach/mach_time.h> header file. */
-#cmakedefine EVENT__HAVE_MACH_MACH_TIME_H
+#cmakedefine EVENT__HAVE_MACH_MACH_TIME_H 1
+
+/* Define to 1 if you have the <mach/mach.h> header file. */
+#cmakedefine EVENT__HAVE_MACH_MACH_H 1
 
 /* Define to 1 if you have the <memory.h> header file. */
-#cmakedefine EVENT__HAVE_MEMORY_H
+#cmakedefine EVENT__HAVE_MEMORY_H 1
 
 /* Define to 1 if you have the `mmap' function. */
-#cmakedefine EVENT__HAVE_MMAP
+#cmakedefine EVENT__HAVE_MMAP 1
 
 /* Define to 1 if you have the `nanosleep' function. */
-#cmakedefine EVENT__HAVE_NANOSLEEP
+#cmakedefine EVENT__HAVE_NANOSLEEP 1
 
 /* Define to 1 if you have the `usleep' function. */
-#cmakedefine EVENT__HAVE_USLEEP
+#cmakedefine EVENT__HAVE_USLEEP 1
 
 /* Define to 1 if you have the <netinet/in6.h> header file. */
-#cmakedefine EVENT__HAVE_NETINET_IN6_H
+#cmakedefine EVENT__HAVE_NETINET_IN6_H 1
 
 /* Define to 1 if you have the <netinet/in.h> header file. */
-#cmakedefine EVENT__HAVE_NETINET_IN_H
+#cmakedefine EVENT__HAVE_NETINET_IN_H 1
 
 /* Define to 1 if you have the <netinet/tcp.h> header file. */
-#cmakedefine EVENT__HAVE_NETINET_TCP_H
+#cmakedefine EVENT__HAVE_NETINET_TCP_H 1
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#cmakedefine EVENT__HAVE_SYS_UN_H 1
+
+/* Define to 1 if you have the <afunix.h> header file. */
+#cmakedefine EVENT__HAVE_AFUNIX_H 1
 
 /* Define if the system has openssl */
-#cmakedefine EVENT__HAVE_OPENSSL
+#cmakedefine EVENT__HAVE_OPENSSL 1
 
 /* Define to 1 if you have the `pipe' function. */
-#cmakedefine EVENT__HAVE_PIPE
+#cmakedefine EVENT__HAVE_PIPE 1
 
 /* Define to 1 if you have the `pipe2' function. */
-#cmakedefine EVENT__HAVE_PIPE2
+#cmakedefine EVENT__HAVE_PIPE2 1
 
 /* Define to 1 if you have the `poll' function. */
-#cmakedefine EVENT__HAVE_POLL
+#cmakedefine EVENT__HAVE_POLL 1
 
 /* Define to 1 if you have the <poll.h> header file. */
-#cmakedefine EVENT__HAVE_POLL_H
+#cmakedefine EVENT__HAVE_POLL_H 1
 
 /* Define to 1 if you have the `port_create' function. */
-#cmakedefine EVENT__HAVE_PORT_CREATE
+#cmakedefine EVENT__HAVE_PORT_CREATE 1
 
 /* Define to 1 if you have the <port.h> header file. */
-#cmakedefine EVENT__HAVE_PORT_H
+#cmakedefine EVENT__HAVE_PORT_H 1
 
 /* Define if we have pthreads on this system */
-#cmakedefine EVENT__HAVE_PTHREADS
+#cmakedefine EVENT__HAVE_PTHREADS 1
 
 /* Define to 1 if you have the `putenv' function. */
-#cmakedefine EVENT__HAVE_PUTENV
+#cmakedefine EVENT__HAVE_PUTENV 1
 
 /* Define to 1 if the system has the type `sa_family_t'. */
-#cmakedefine EVENT__HAVE_SA_FAMILY_T
+#cmakedefine EVENT__HAVE_SA_FAMILY_T 1
 
 /* Define to 1 if you have the `select' function. */
-#cmakedefine EVENT__HAVE_SELECT
+#cmakedefine EVENT__HAVE_SELECT 1
 
 /* Define to 1 if you have the `setenv' function. */
-#cmakedefine EVENT__HAVE_SETENV
+#cmakedefine EVENT__HAVE_SETENV 1
 
 /* Define if F_SETFD is defined in <fcntl.h> */
-#cmakedefine EVENT__HAVE_SETFD
+#cmakedefine EVENT__HAVE_SETFD 1
 
 /* Define to 1 if you have the `setrlimit' function. */
-#cmakedefine EVENT__HAVE_SETRLIMIT
+#cmakedefine EVENT__HAVE_SETRLIMIT 1
 
 /* Define to 1 if you have the `sendfile' function. */
-#cmakedefine EVENT__HAVE_SENDFILE
-
-/* Define if F_SETFD is defined in <fcntl.h> */
-#cmakedefine EVENT__HAVE_SETFD
+#cmakedefine EVENT__HAVE_SENDFILE 1
 
 /* Define to 1 if you have the `sigaction' function. */
-#cmakedefine EVENT__HAVE_SIGACTION
+#cmakedefine EVENT__HAVE_SIGACTION 1
 
 /* Define to 1 if you have the `signal' function. */
-#cmakedefine EVENT__HAVE_SIGNAL
+#cmakedefine EVENT__HAVE_SIGNAL 1
 
 /* Define to 1 if you have the `splice' function. */
-#cmakedefine EVENT__HAVE_SPLICE
+#cmakedefine EVENT__HAVE_SPLICE 1
 
 /* Define to 1 if you have the <stdarg.h> header file. */
-#cmakedefine EVENT__HAVE_STDARG_H
+#cmakedefine EVENT__HAVE_STDARG_H 1
 
 /* Define to 1 if you have the <stddef.h> header file. */
-#cmakedefine EVENT__HAVE_STDDEF_H
+#cmakedefine EVENT__HAVE_STDDEF_H 1
 
 /* Define to 1 if you have the <stdint.h> header file. */
-#cmakedefine EVENT__HAVE_STDINT_H
+#cmakedefine EVENT__HAVE_STDINT_H 1
 
 /* Define to 1 if you have the <stdlib.h> header file. */
-#cmakedefine EVENT__HAVE_STDLIB_H
-
-/* Define to 1 if you have the <strings.h> header file. */
-#cmakedefine EVENT__HAVE_STRINGS_H
+#cmakedefine EVENT__HAVE_STDLIB_H 1
 
 /* Define to 1 if you have the <string.h> header file. */
-#cmakedefine EVENT__HAVE_STRING_H
+#cmakedefine EVENT__HAVE_STRING_H 1
 
 /* Define to 1 if you have the `strlcpy' function. */
-#cmakedefine EVENT__HAVE_STRLCPY
+#cmakedefine EVENT__HAVE_STRLCPY 1
 
 /* Define to 1 if you have the `strsep' function. */
-#cmakedefine EVENT__HAVE_STRSEP
+#cmakedefine EVENT__HAVE_STRSEP 1
 
 /* Define to 1 if you have the `strtok_r' function. */
-#cmakedefine EVENT__HAVE_STRTOK_R
+#cmakedefine EVENT__HAVE_STRTOK_R 1
 
 /* Define to 1 if you have the `strtoll' function. */
-#cmakedefine EVENT__HAVE_STRTOLL
+#cmakedefine EVENT__HAVE_STRTOLL 1
+
+/* Define to 1 if you have the `_gmtime64_s' function. */
+#cmakedefine EVENT__HAVE__GMTIME64_S 1
+
+/* Define to 1 if you have the `_gmtime64' function. */
+#cmakedefine EVENT__HAVE__GMTIME64 1
 
 /* Define to 1 if the system has the type `struct addrinfo'. */
-#cmakedefine EVENT__HAVE_STRUCT_ADDRINFO
+#cmakedefine EVENT__HAVE_STRUCT_ADDRINFO 1
 
 /* Define to 1 if the system has the type `struct in6_addr'. */
-#cmakedefine EVENT__HAVE_STRUCT_IN6_ADDR
+#cmakedefine EVENT__HAVE_STRUCT_IN6_ADDR 1
 
 /* Define to 1 if `s6_addr16' is member of `struct in6_addr'. */
-#cmakedefine EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR16
+#cmakedefine EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR16 1
 
 /* Define to 1 if `s6_addr32' is member of `struct in6_addr'. */
-#cmakedefine EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32
+#cmakedefine EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 1
 
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
-#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_IN6
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_IN6 1
 
 /* Define to 1 if `sin6_len' is member of `struct sockaddr_in6'. */
-#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_IN6_SIN6_LEN 1
 
 /* Define to 1 if `sin_len' is member of `struct sockaddr_in'. */
-#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_IN_SIN_LEN 1
+
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_UN 1
 
 /* Define to 1 if the system has the type `struct sockaddr_storage'. */
-#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_STORAGE
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_STORAGE 1
 
 /* Define to 1 if `ss_family' is a member of `struct sockaddr_storage'. */
-#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_STORAGE_SS_FAMILY 1
 
 /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
-#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY
+#cmakedefine EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY 1
 
-/* Define to 1 if you have the `sysctl' function. */
-#cmakedefine EVENT__HAVE_SYSCTL
+/* Define to 1 if the system has the type `struct linger'. */
+#cmakedefine EVENT__HAVE_STRUCT_LINGER 1
 
-/* Define to 1 if you have the <sys/devpoll.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_DEVPOLL_H
+/* Define to 1 if you have the `sysctl' function. */
+#cmakedefine EVENT__HAVE_SYSCTL 1
 
 /* Define to 1 if you have the <sys/epoll.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_EPOLL_H
+#cmakedefine EVENT__HAVE_SYS_EPOLL_H 1
 
 /* Define to 1 if you have the <sys/eventfd.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_EVENTFD_H
+#cmakedefine EVENT__HAVE_SYS_EVENTFD_H 1
 
 /* Define to 1 if you have the <sys/event.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_EVENT_H
+#cmakedefine EVENT__HAVE_SYS_EVENT_H 1
 
 /* Define to 1 if you have the <sys/ioctl.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_IOCTL_H
+#cmakedefine EVENT__HAVE_SYS_IOCTL_H 1
 
 /* Define to 1 if you have the <sys/mman.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_MMAN_H
+#cmakedefine EVENT__HAVE_SYS_MMAN_H 1
 
 /* Define to 1 if you have the <sys/param.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_PARAM_H
+#cmakedefine EVENT__HAVE_SYS_PARAM_H 1
 
 /* Define to 1 if you have the <sys/queue.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_QUEUE_H
+#cmakedefine EVENT__HAVE_SYS_QUEUE_H 1
 
 /* Define to 1 if you have the <sys/resource.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_RESOURCE_H
+#cmakedefine EVENT__HAVE_SYS_RESOURCE_H 1
 
 /* Define to 1 if you have the <sys/select.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_SELECT_H
+#cmakedefine EVENT__HAVE_SYS_SELECT_H 1
 
 /* Define to 1 if you have the <sys/sendfile.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_SENDFILE_H
+#cmakedefine EVENT__HAVE_SYS_SENDFILE_H 1
 
 /* Define to 1 if you have the <sys/socket.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_SOCKET_H
+#cmakedefine EVENT__HAVE_SYS_SOCKET_H 1
 
 /* Define to 1 if you have the <sys/stat.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_STAT_H
+#cmakedefine EVENT__HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/random.h> header file. */
+#cmakedefine EVENT__HAVE_SYS_RANDOM_H 1
 
 /* Define to 1 if you have the <sys/sysctl.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_SYSCTL_H
+#cmakedefine EVENT__HAVE_SYS_SYSCTL_H 1
 
 /* Define to 1 if you have the <sys/timerfd.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_TIMERFD_H */
+#cmakedefine EVENT__HAVE_SYS_TIMERFD_H 1
 
 /* Define to 1 if you have the <sys/time.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_TIME_H
+#cmakedefine EVENT__HAVE_SYS_TIME_H 1
 
 /* Define to 1 if you have the <sys/types.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_TYPES_H
+#cmakedefine EVENT__HAVE_SYS_TYPES_H 1
 
 /* Define to 1 if you have the <sys/uio.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_UIO_H
+#cmakedefine EVENT__HAVE_SYS_UIO_H 1
 
 /* Define to 1 if you have the <sys/wait.h> header file. */
-#cmakedefine EVENT__HAVE_SYS_WAIT_H
+#cmakedefine EVENT__HAVE_SYS_WAIT_H 1
 
 /* Define to 1 if you have the <errno.h> header file. */
-#cmakedefine EVENT__HAVE_ERRNO_H
+#cmakedefine EVENT__HAVE_ERRNO_H 1
 
 /* Define if TAILQ_FOREACH is defined in <sys/queue.h> */
-#cmakedefine EVENT__HAVE_TAILQFOREACH
+#cmakedefine EVENT__HAVE_TAILQFOREACH 1
 
 /* Define if timeradd is defined in <sys/time.h> */
-#cmakedefine EVENT__HAVE_TIMERADD
+#cmakedefine EVENT__HAVE_TIMERADD 1
 
 /* Define if timerclear is defined in <sys/time.h> */
-#cmakedefine EVENT__HAVE_TIMERCLEAR
+#cmakedefine EVENT__HAVE_TIMERCLEAR 1
 
 /* Define if timercmp is defined in <sys/time.h> */
-#cmakedefine EVENT__HAVE_TIMERCMP
+#cmakedefine EVENT__HAVE_TIMERCMP 1
 
 
 /* Define to 1 if you have the `timerfd_create' function. */
-#cmakedefine EVENT__HAVE_TIMERFD_CREATE
+#cmakedefine EVENT__HAVE_TIMERFD_CREATE 1
 
 /* Define if timerisset is defined in <sys/time.h> */
-#cmakedefine EVENT__HAVE_TIMERISSET
+#cmakedefine EVENT__HAVE_TIMERISSET 1
 
 /* Define to 1 if the system has the type `uint8_t'. */
-#cmakedefine EVENT__HAVE_UINT8_T
+#cmakedefine EVENT__HAVE_UINT8_T 1
 
 /* Define to 1 if the system has the type `uint16_t'. */
-#cmakedefine EVENT__HAVE_UINT16_T
+#cmakedefine EVENT__HAVE_UINT16_T 1
 
 /* Define to 1 if the system has the type `uint32_t'. */
-#cmakedefine EVENT__HAVE_UINT32_T
+#cmakedefine EVENT__HAVE_UINT32_T 1
 
 /* Define to 1 if the system has the type `uint64_t'. */
-#cmakedefine EVENT__HAVE_UINT64_T
+#cmakedefine EVENT__HAVE_UINT64_T 1
 
 /* Define to 1 if the system has the type `uintptr_t'. */
-#cmakedefine EVENT__HAVE_UINTPTR_T
+#cmakedefine EVENT__HAVE_UINTPTR_T 1
 
 /* Define to 1 if you have the `umask' function. */
-#cmakedefine EVENT__HAVE_UMASK
+#cmakedefine EVENT__HAVE_UMASK 1
 
 /* Define to 1 if you have the <unistd.h> header file. */
-#cmakedefine EVENT__HAVE_UNISTD_H
+#cmakedefine EVENT__HAVE_UNISTD_H 1
 
 /* Define to 1 if you have the `unsetenv' function. */
-#cmakedefine EVENT__HAVE_UNSETENV
+#cmakedefine EVENT__HAVE_UNSETENV 1
 
 /* Define to 1 if you have the `vasprintf' function. */
-#cmakedefine EVENT__HAVE_VASPRINTF
+#cmakedefine EVENT__HAVE_VASPRINTF 1
 
 /* Define if kqueue works correctly with pipes */
-#cmakedefine EVENT__HAVE_WORKING_KQUEUE
+#cmakedefine EVENT__HAVE_WORKING_KQUEUE 1
 
 #ifdef __USE_UNUSED_DEFINITIONS__
 /* Define to necessary symbol if this constant uses a non-standard name on your system. */
@@ -455,11 +473,8 @@
 /* The size of `size_t', as computed by sizeof. */
 #define EVENT__SIZEOF_SIZE_T @EVENT__SIZEOF_SIZE_T@
 
-/* Define to 1 if you have the ANSI C header files. */
-#cmakedefine EVENT__STDC_HEADERS
-
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#cmakedefine EVENT__TIME_WITH_SYS_TIME
+#cmakedefine EVENT__TIME_WITH_SYS_TIME 1
 
 /* The size of `socklen_t', as computed by sizeof. */
 #define EVENT__SIZEOF_SOCKLEN_T @EVENT__SIZEOF_SOCKLEN_T@
@@ -467,32 +482,6 @@
 /* The size of 'void *', as computer by sizeof */
 #define EVENT__SIZEOF_VOID_P @EVENT__SIZEOF_VOID_P@
 
-/* set an alias for whatever __func__ __FUNCTION__ is, what sillyness */
-#if defined (__func__)
-#define EVENT____func__ __func__
-#elif defined(__FUNCTION__)
-#define EVENT____func__  __FUNCTION__
-#else
-#define EVENT____func__ __FILE__
-#endif
-
-
-#ifdef __THESE_ARE_NOT_CONFIG_H_THINGS_THEY_ARE_DASH_D_THINGS__
-/* Number of bits in a file offset, on hosts where this is settable. */
-/* Ellzey is not satisfied */
-#define EVENT___FILE_OFFSET_BITS @EVENT___FILE_OFFSET_BITS@
-
-/* Define for large files, on AIX-style hosts. */
-#define @_LARGE_FILES@
-#endif
-
-#ifdef _WhAT_DOES_THIS_EVEN_DO_
-/* Define to empty if `const' does not conform to ANSI C. */
-/* lolwut? - ellzey */
-#undef EVENT__const
-#endif
-
-
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
 #ifndef __cplusplus
@@ -509,8 +498,8 @@
 #define EVENT__inline @EVENT__inline@
 #endif
 
-/* Define to `int' if <sys/tyes.h> does not define. */
-#define EVENT__pid_t @EVENT__pid_t@
+#cmakedefine EVENT__HAVE___func__ 1
+#cmakedefine EVENT__HAVE___FUNCTION__ 1
 
 /* Define to `unsigned' if <sys/types.h> does not define. */
 #define EVENT__size_t @EVENT__size_t@
@@ -521,12 +510,4 @@
 /* Define to `int' if <sys/types.h> does not define. */
 #define EVENT__ssize_t @EVENT__ssize_t@
 
-#cmakedefine EVENT__NEED_DLLIMPORT
-
-/* Define to 1 if you have ERR_remove_thread_stat(). */
-#cmakedefine EVENT__HAVE_ERR_REMOVE_THREAD_STATE
-
-/* Define if waitpid() supports WNOWAIT */
-#cmakedefine EVENT__HAVE_WAITPID_WITH_WNOWAIT
-
-#endif
+#endif /* \EVENT2_EVENT_CONFIG_H_INCLUDED_ */
diff --git a/ipc/chromium/src/third_party/libevent/event-internal.h b/ipc/chromium/src/third_party/libevent/event-internal.h
index 66dcfc329c75..9e5ff4244737 100644
--- a/ipc/chromium/src/third_party/libevent/event-internal.h
+++ b/ipc/chromium/src/third_party/libevent/event-internal.h
@@ -219,7 +219,7 @@ struct event_base {
 	/** Function pointers used to describe the backend that this event_base
 	 * uses for signals */
 	const struct eventop *evsigsel;
-	/** Data to implement the common signal handelr code. */
+	/** Data to implement the common signal handler code. */
 	struct evsig_info sig;
 
 	/** Number of virtual events */
@@ -368,6 +368,10 @@ struct event_config {
 };
 
 /* Internal use only: Functions that might be missing from <sys/queue.h> */
+#ifndef LIST_END
+#define LIST_END(head)			NULL
+#endif
+
 #ifndef TAILQ_FIRST
 #define	TAILQ_FIRST(head)		((head)->tqh_first)
 #endif
@@ -414,23 +418,26 @@ int event_add_nolock_(struct event *ev,
  * if it is running in another thread and it doesn't have EV_FINALIZE set.
  */
 #define EVENT_DEL_AUTOBLOCK 2
-/** Argument for event_del_nolock_. Tells event_del to procede even if the
+/** Argument for event_del_nolock_. Tells event_del to proceed even if the
  * event is set up for finalization rather for regular use.*/
 #define EVENT_DEL_EVEN_IF_FINALIZING 3
 int event_del_nolock_(struct event *ev, int blocking);
 int event_remove_timer_nolock_(struct event *ev);
 
 void event_active_nolock_(struct event *ev, int res, short count);
+EVENT2_EXPORT_SYMBOL
 int event_callback_activate_(struct event_base *, struct event_callback *);
 int event_callback_activate_nolock_(struct event_base *, struct event_callback *);
 int event_callback_cancel_(struct event_base *base,
     struct event_callback *evcb);
 
 void event_callback_finalize_nolock_(struct event_base *base, unsigned flags, struct event_callback *evcb, void (*cb)(struct event_callback *, void *));
+EVENT2_EXPORT_SYMBOL
 void event_callback_finalize_(struct event_base *base, unsigned flags, struct event_callback *evcb, void (*cb)(struct event_callback *, void *));
 int event_callback_finalize_many_(struct event_base *base, int n_cbs, struct event_callback **evcb, void (*cb)(struct event_callback *, void *));
 
 
+EVENT2_EXPORT_SYMBOL
 void event_active_later_(struct event *ev, int res);
 void event_active_later_nolock_(struct event *ev, int res);
 int event_callback_activate_later_nolock_(struct event_base *base,
@@ -441,6 +448,7 @@ void event_callback_init_(struct event_base *base,
     struct event_callback *cb);
 
 /* FIXME document. */
+EVENT2_EXPORT_SYMBOL
 void event_base_add_virtual_(struct event_base *base);
 void event_base_del_virtual_(struct event_base *base);
 
@@ -450,6 +458,7 @@ void event_base_del_virtual_(struct event_base *base);
 
     Returns on success; aborts on failure.
 */
+EVENT2_EXPORT_SYMBOL
 void event_base_assert_ok_(struct event_base *base);
 void event_base_assert_ok_nolock_(struct event_base *base);
 
diff --git a/ipc/chromium/src/third_party/libevent/event.c b/ipc/chromium/src/third_party/libevent/event.c
index 503003e249a2..7a42b7319147 100644
--- a/ipc/chromium/src/third_party/libevent/event.c
+++ b/ipc/chromium/src/third_party/libevent/event.c
@@ -52,6 +52,9 @@
 #include <string.h>
 #include <time.h>
 #include <limits.h>
+#ifdef EVENT__HAVE_FCNTL_H
+#include <fcntl.h>
+#endif
 
 #include "event2/event.h"
 #include "event2/event_struct.h"
@@ -123,6 +126,7 @@ static const struct eventop *eventops[] = {
 };
 
 /* Global state; deprecated */
+EVENT2_EXPORT_SYMBOL
 struct event_base *event_global_current_base_ = NULL;
 #define current_base event_global_current_base_
 
@@ -228,133 +232,169 @@ HT_PROTOTYPE(event_debug_map, event_debug_entry, node, hash_debug_entry,
 HT_GENERATE(event_debug_map, event_debug_entry, node, hash_debug_entry,
     eq_debug_entry, 0.5, mm_malloc, mm_realloc, mm_free)
 
-/* Macro: record that ev is now setup (that is, ready for an add) */
-#define event_debug_note_setup_(ev) do {				\
-	if (event_debug_mode_on_) {					\
-		struct event_debug_entry *dent,find;			\
-		find.ptr = (ev);					\
-		EVLOCK_LOCK(event_debug_map_lock_, 0);			\
-		dent = HT_FIND(event_debug_map, &global_debug_map, &find); \
-		if (dent) {						\
-			dent->added = 0;				\
-		} else {						\
-			dent = mm_malloc(sizeof(*dent));		\
-			if (!dent)					\
-				event_err(1,				\
-				    "Out of memory in debugging code");	\
-			dent->ptr = (ev);				\
-			dent->added = 0;				\
-			HT_INSERT(event_debug_map, &global_debug_map, dent); \
-		}							\
-		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\
-	}								\
-	event_debug_mode_too_late = 1;					\
-	} while (0)
-/* Macro: record that ev is no longer setup */
-#define event_debug_note_teardown_(ev) do {				\
-	if (event_debug_mode_on_) {					\
-		struct event_debug_entry *dent,find;			\
-		find.ptr = (ev);					\
-		EVLOCK_LOCK(event_debug_map_lock_, 0);			\
-		dent = HT_REMOVE(event_debug_map, &global_debug_map, &find); \
-		if (dent)						\
-			mm_free(dent);					\
-		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\
-	}								\
-	event_debug_mode_too_late = 1;					\
-	} while (0)
+/* record that ev is now setup (that is, ready for an add) */
+static void event_debug_note_setup_(const struct event *ev)
+{
+	struct event_debug_entry *dent, find;
+
+	if (!event_debug_mode_on_)
+		goto out;
+
+	find.ptr = ev;
+	EVLOCK_LOCK(event_debug_map_lock_, 0);
+	dent = HT_FIND(event_debug_map, &global_debug_map, &find);
+	if (dent) {
+		dent->added = 0;
+	} else {
+		dent = mm_malloc(sizeof(*dent));
+		if (!dent)
+			event_err(1,
+			    "Out of memory in debugging code");
+		dent->ptr = ev;
+		dent->added = 0;
+		HT_INSERT(event_debug_map, &global_debug_map, dent);
+	}
+	EVLOCK_UNLOCK(event_debug_map_lock_, 0);
+
+out:
+	event_debug_mode_too_late = 1;
+}
+/* record that ev is no longer setup */
+static void event_debug_note_teardown_(const struct event *ev)
+{
+	struct event_debug_entry *dent, find;
+
+	if (!event_debug_mode_on_)
+		goto out;
+
+	find.ptr = ev;
+	EVLOCK_LOCK(event_debug_map_lock_, 0);
+	dent = HT_REMOVE(event_debug_map, &global_debug_map, &find);
+	if (dent)
+		mm_free(dent);
+	EVLOCK_UNLOCK(event_debug_map_lock_, 0);
+
+out:
+	event_debug_mode_too_late = 1;
+}
 /* Macro: record that ev is now added */
-#define event_debug_note_add_(ev)	do {				\
-	if (event_debug_mode_on_) {					\
-		struct event_debug_entry *dent,find;			\
-		find.ptr = (ev);					\
-		EVLOCK_LOCK(event_debug_map_lock_, 0);			\
-		dent = HT_FIND(event_debug_map, &global_debug_map, &find); \
-		if (dent) {						\
-			dent->added = 1;				\
-		} else {						\
-			event_errx(EVENT_ERR_ABORT_,			\
-			    "%s: noting an add on a non-setup event %p" \
-			    " (events: 0x%x, fd: "EV_SOCK_FMT		\
-			    ", flags: 0x%x)",				\
-			    __func__, (ev), (ev)->ev_events,		\
-			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\
-		}							\
-		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\
-	}								\
-	event_debug_mode_too_late = 1;					\
-	} while (0)
-/* Macro: record that ev is no longer added */
-#define event_debug_note_del_(ev) do {					\
-	if (event_debug_mode_on_) {					\
-		struct event_debug_entry *dent,find;			\
-		find.ptr = (ev);					\
-		EVLOCK_LOCK(event_debug_map_lock_, 0);			\
-		dent = HT_FIND(event_debug_map, &global_debug_map, &find); \
-		if (dent) {						\
-			dent->added = 0;				\
-		} else {						\
-			event_errx(EVENT_ERR_ABORT_,			\
-			    "%s: noting a del on a non-setup event %p"	\
-			    " (events: 0x%x, fd: "EV_SOCK_FMT		\
-			    ", flags: 0x%x)",				\
-			    __func__, (ev), (ev)->ev_events,		\
-			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\
-		}							\
-		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\
-	}								\
-	event_debug_mode_too_late = 1;					\
-	} while (0)
-/* Macro: assert that ev is setup (i.e., okay to add or inspect) */
-#define event_debug_assert_is_setup_(ev) do {				\
-	if (event_debug_mode_on_) {					\
-		struct event_debug_entry *dent,find;			\
-		find.ptr = (ev);					\
-		EVLOCK_LOCK(event_debug_map_lock_, 0);			\
-		dent = HT_FIND(event_debug_map, &global_debug_map, &find); \
-		if (!dent) {						\
-			event_errx(EVENT_ERR_ABORT_,			\
-			    "%s called on a non-initialized event %p"	\
-			    " (events: 0x%x, fd: "EV_SOCK_FMT\
-			    ", flags: 0x%x)",				\
-			    __func__, (ev), (ev)->ev_events,		\
-			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\
-		}							\
-		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\
-	}								\
-	} while (0)
-/* Macro: assert that ev is not added (i.e., okay to tear down or set
- * up again) */
-#define event_debug_assert_not_added_(ev) do {				\
-	if (event_debug_mode_on_) {					\
-		struct event_debug_entry *dent,find;			\
-		find.ptr = (ev);					\
-		EVLOCK_LOCK(event_debug_map_lock_, 0);			\
-		dent = HT_FIND(event_debug_map, &global_debug_map, &find); \
-		if (dent && dent->added) {				\
-			event_errx(EVENT_ERR_ABORT_,			\
-			    "%s called on an already added event %p"	\
-			    " (events: 0x%x, fd: "EV_SOCK_FMT", "	\
-			    "flags: 0x%x)",				\
-			    __func__, (ev), (ev)->ev_events,		\
-			    EV_SOCK_ARG((ev)->ev_fd), (ev)->ev_flags);	\
-		}							\
-		EVLOCK_UNLOCK(event_debug_map_lock_, 0);		\
-	}								\
-	} while (0)
+static void event_debug_note_add_(const struct event *ev)
+{
+	struct event_debug_entry *dent,find;
+
+	if (!event_debug_mode_on_)
+		goto out;
+
+	find.ptr = ev;
+	EVLOCK_LOCK(event_debug_map_lock_, 0);
+	dent = HT_FIND(event_debug_map, &global_debug_map, &find);
+	if (dent) {
+		dent->added = 1;
+	} else {
+		event_errx(EVENT_ERR_ABORT_,
+		    "%s: noting an add on a non-setup event %p"
+		    " (events: 0x%x, fd: "EV_SOCK_FMT
+		    ", flags: 0x%x)",
+		    __func__, ev, ev->ev_events,
+		    EV_SOCK_ARG(ev->ev_fd), ev->ev_flags);
+	}
+	EVLOCK_UNLOCK(event_debug_map_lock_, 0);
+
+out:
+	event_debug_mode_too_late = 1;
+}
+/* record that ev is no longer added */
+static void event_debug_note_del_(const struct event *ev)
+{
+	struct event_debug_entry *dent, find;
+
+	if (!event_debug_mode_on_)
+		goto out;
+
+	find.ptr = ev;
+	EVLOCK_LOCK(event_debug_map_lock_, 0);
+	dent = HT_FIND(event_debug_map, &global_debug_map, &find);
+	if (dent) {
+		dent->added = 0;
+	} else {
+		event_errx(EVENT_ERR_ABORT_,
+		    "%s: noting a del on a non-setup event %p"
+		    " (events: 0x%x, fd: "EV_SOCK_FMT
+		    ", flags: 0x%x)",
+		    __func__, ev, ev->ev_events,
+		    EV_SOCK_ARG(ev->ev_fd), ev->ev_flags);
+	}
+	EVLOCK_UNLOCK(event_debug_map_lock_, 0);
+
+out:
+	event_debug_mode_too_late = 1;
+}
+/* assert that ev is setup (i.e., okay to add or inspect) */
+static void event_debug_assert_is_setup_(const struct event *ev)
+{
+	struct event_debug_entry *dent, find;
+
+	if (!event_debug_mode_on_)
+		return;
+
+	find.ptr = ev;
+	EVLOCK_LOCK(event_debug_map_lock_, 0);
+	dent = HT_FIND(event_debug_map, &global_debug_map, &find);
+	if (!dent) {
+		event_errx(EVENT_ERR_ABORT_,
+		    "%s called on a non-initialized event %p"
+		    " (events: 0x%x, fd: "EV_SOCK_FMT
+		    ", flags: 0x%x)",
+		    __func__, ev, ev->ev_events,
+		    EV_SOCK_ARG(ev->ev_fd), ev->ev_flags);
+	}
+	EVLOCK_UNLOCK(event_debug_map_lock_, 0);
+}
+/* assert that ev is not added (i.e., okay to tear down or set up again) */
+static void event_debug_assert_not_added_(const struct event *ev)
+{
+	struct event_debug_entry *dent, find;
+
+	if (!event_debug_mode_on_)
+		return;
+
+	find.ptr = ev;
+	EVLOCK_LOCK(event_debug_map_lock_, 0);
+	dent = HT_FIND(event_debug_map, &global_debug_map, &find);
+	if (dent && dent->added) {
+		event_errx(EVENT_ERR_ABORT_,
+		    "%s called on an already added event %p"
+		    " (events: 0x%x, fd: "EV_SOCK_FMT", "
+		    "flags: 0x%x)",
+		    __func__, ev, ev->ev_events,
+		    EV_SOCK_ARG(ev->ev_fd), ev->ev_flags);
+	}
+	EVLOCK_UNLOCK(event_debug_map_lock_, 0);
+}
+static void event_debug_assert_socket_nonblocking_(evutil_socket_t fd)
+{
+	if (!event_debug_mode_on_)
+		return;
+	if (fd < 0)
+		return;
+
+#ifndef _WIN32
+	{
+		int flags;
+		if ((flags = fcntl(fd, F_GETFL, NULL)) >= 0) {
+			EVUTIL_ASSERT(flags & O_NONBLOCK);
+		}
+	}
+#endif
+}
 #else
-#define event_debug_note_setup_(ev) \
-	((void)0)
-#define event_debug_note_teardown_(ev) \
-	((void)0)
-#define event_debug_note_add_(ev) \
-	((void)0)
-#define event_debug_note_del_(ev) \
-	((void)0)
-#define event_debug_assert_is_setup_(ev) \
-	((void)0)
-#define event_debug_assert_not_added_(ev) \
-	((void)0)
+static void event_debug_note_setup_(const struct event *ev) { (void)ev; }
+static void event_debug_note_teardown_(const struct event *ev) { (void)ev; }
+static void event_debug_note_add_(const struct event *ev) { (void)ev; }
+static void event_debug_note_del_(const struct event *ev) { (void)ev; }
+static void event_debug_assert_is_setup_(const struct event *ev) { (void)ev; }
+static void event_debug_assert_not_added_(const struct event *ev) { (void)ev; }
+static void event_debug_assert_socket_nonblocking_(evutil_socket_t fd) { (void)fd; }
 #endif
 
 #define EVENT_BASE_ASSERT_LOCKED(base)		\
@@ -590,7 +630,9 @@ event_base_new_with_config(const struct event_config *cfg)
 		int flags;
 		if (should_check_environment && !precise_time) {
 			precise_time = evutil_getenv_("EVENT_PRECISE_TIMER") != NULL;
-			base->flags |= EVENT_BASE_FLAG_PRECISE_TIMER;
+			if (precise_time) {
+				base->flags |= EVENT_BASE_FLAG_PRECISE_TIMER;
+			}
 		}
 		flags = precise_time ? EV_MONOT_PRECISE : 0;
 		evutil_configure_monotonic_time_(&base->monotonic_timer, flags);
@@ -862,6 +904,7 @@ event_base_free_(struct event_base *base, int run_finalizers)
 		 * A simple case is bufferevent with underlying (i.e. filters).
 		 */
 		int i = event_base_free_queues_(base, run_finalizers);
+		event_debug(("%s: %d events freed", __func__, i));
 		if (!i) {
 			break;
 		}
@@ -1640,10 +1683,12 @@ event_process_active_single_queue(struct event_base *base,
 			break;
 		case EV_CLOSURE_EVENT: {
 			void (*evcb_callback)(evutil_socket_t, short, void *);
+			short res;
 			EVUTIL_ASSERT(ev != NULL);
 			evcb_callback = *ev->ev_callback;
+			res = ev->ev_res;
 			EVBASE_RELEASE_LOCK(base, th_base_lock);
-			evcb_callback(ev->ev_fd, ev->ev_res, ev->ev_arg);
+			evcb_callback(ev->ev_fd, res, ev->ev_arg);
 		}
 		break;
 		case EV_CLOSURE_CB_SELF: {
@@ -1661,8 +1706,8 @@ event_process_active_single_queue(struct event_base *base,
 			evcb_evfinalize = ev->ev_evcallback.evcb_cb_union.evcb_evfinalize;
 			EVUTIL_ASSERT((evcb->evcb_flags & EVLIST_FINALIZING));
 			EVBASE_RELEASE_LOCK(base, th_base_lock);
-			evcb_evfinalize(ev, ev->ev_arg);
 			event_debug_note_teardown_(ev);
+			evcb_evfinalize(ev, ev->ev_arg);
 			if (evcb_closure == EV_CLOSURE_EVENT_FINALIZE_FREE)
 				mm_free(ev);
 		}
@@ -2011,6 +2056,9 @@ event_base_once(struct event_base *base, evutil_socket_t fd, short events,
 	int res = 0;
 	int activate = 0;
 
+	if (!base)
+		return (-1);
+
 	/* We cannot support signals that just fire once, or persistent
 	 * events. */
 	if (events & (EV_SIGNAL|EV_PERSIST))
@@ -2069,6 +2117,8 @@ event_assign(struct event *ev, struct event_base *base, evutil_socket_t fd, shor
 	if (arg == &event_self_cbarg_ptr_)
 		arg = ev;
 
+	if (!(events & EV_SIGNAL))
+		event_debug_assert_socket_nonblocking_(fd);
 	event_debug_assert_not_added_(ev);
 
 	ev->ev_base = base;
@@ -2719,17 +2769,16 @@ static int
 event_del_(struct event *ev, int blocking)
 {
 	int res;
+	struct event_base *base = ev->ev_base;
 
-	if (EVUTIL_FAILURE_CHECK(!ev->ev_base)) {
+	if (EVUTIL_FAILURE_CHECK(!base)) {
 		event_warnx("%s: event has no event_base set.", __func__);
 		return -1;
 	}
 
-	EVBASE_ACQUIRE_LOCK(ev->ev_base, th_base_lock);
-
+	EVBASE_ACQUIRE_LOCK(base, th_base_lock);
 	res = event_del_nolock_(ev, blocking);
-
-	EVBASE_RELEASE_LOCK(ev->ev_base, th_base_lock);
+	EVBASE_RELEASE_LOCK(base, th_base_lock);
 
 	return (res);
 }
@@ -2779,21 +2828,7 @@ event_del_nolock_(struct event *ev, int blocking)
 		}
 	}
 
-	/* If the main thread is currently executing this event's callback,
-	 * and we are not the main thread, then we want to wait until the
-	 * callback is done before we start removing the event.  That way,
-	 * when this function returns, it will be safe to free the
-	 * user-supplied argument. */
 	base = ev->ev_base;
-#ifndef EVENT__DISABLE_THREAD_SUPPORT
-	if (blocking != EVENT_DEL_NOBLOCK &&
-	    base->current_event == event_to_event_callback(ev) &&
-	    !EVBASE_IN_THREAD(base) &&
-	    (blocking == EVENT_DEL_BLOCK || !(ev->ev_events & EV_FINALIZE))) {
-		++base->current_event_waiters;
-		EVTHREAD_COND_WAIT(base->current_event_cond, base->th_base_lock);
-	}
-#endif
 
 	EVUTIL_ASSERT(!(ev->ev_flags & ~EVLIST_ALL));
 
@@ -2832,6 +2867,10 @@ event_del_nolock_(struct event *ev, int blocking)
 			notify = 1;
 			res = 0;
 		}
+		/* If we do not have events, let's notify event base so it can
+		 * exit without waiting */
+		if (!event_haveevents(base) && !N_ACTIVE_CALLBACKS(base))
+			notify = 1;
 	}
 
 	/* if we are not in the right thread, we need to wake up the loop */
@@ -2840,6 +2879,21 @@ event_del_nolock_(struct event *ev, int blocking)
 
 	event_debug_note_del_(ev);
 
+	/* If the main thread is currently executing this event's callback,
+	 * and we are not the main thread, then we want to wait until the
+	 * callback is done before returning. That way, when this function
+	 * returns, it will be safe to free the user-supplied argument.
+	 */
+#ifndef EVENT__DISABLE_THREAD_SUPPORT
+	if (blocking != EVENT_DEL_NOBLOCK &&
+	    base->current_event == event_to_event_callback(ev) &&
+	    !EVBASE_IN_THREAD(base) &&
+	    (blocking == EVENT_DEL_BLOCK || !(ev->ev_events & EV_FINALIZE))) {
+		++base->current_event_waiters;
+		EVTHREAD_COND_WAIT(base->current_event_cond, base->th_base_lock);
+	}
+#endif
+
 	return (res);
 }
 
@@ -2960,6 +3014,7 @@ event_callback_activate_nolock_(struct event_base *base,
 	switch (evcb->evcb_flags & (EVLIST_ACTIVE|EVLIST_ACTIVE_LATER)) {
 	default:
 		EVUTIL_ASSERT(0);
+		EVUTIL_FALLTHROUGH;
 	case EVLIST_ACTIVE_LATER:
 		event_queue_remove_active_later(base, evcb);
 		r = 0;
@@ -3148,10 +3203,6 @@ timeout_process(struct event_base *base)
 	}
 }
 
-#if (EVLIST_INTERNAL >> 4) != 1
-#error "Mismatch for value of EVLIST_INTERNAL"
-#endif
-
 #ifndef MAX
 #define MAX(a,b) (((a)>(b))?(a):(b))
 #endif
@@ -3159,13 +3210,13 @@ timeout_process(struct event_base *base)
 #define MAX_EVENT_COUNT(var, v) var = MAX(var, v)
 
 /* These are a fancy way to spell
-     if (flags & EVLIST_INTERNAL)
+     if (~flags & EVLIST_INTERNAL)
          base->event_count--/++;
 */
 #define DECR_EVENT_COUNT(base,flags) \
-	((base)->event_count -= (~((flags) >> 4) & 1))
+	((base)->event_count -= !((flags) & EVLIST_INTERNAL))
 #define INCR_EVENT_COUNT(base,flags) do {					\
-	((base)->event_count += (~((flags) >> 4) & 1));				\
+	((base)->event_count += !((flags) & EVLIST_INTERNAL));			\
 	MAX_EVENT_COUNT((base)->event_count_max, (base)->event_count);		\
 } while (0)
 
@@ -3697,13 +3748,14 @@ dump_inserted_event_fn(const struct event_base *base, const struct event *e, voi
 	if (! (e->ev_flags & (EVLIST_INSERTED|EVLIST_TIMEOUT)))
 		return 0;
 
-	fprintf(output, "  %p [%s "EV_SOCK_FMT"]%s%s%s%s%s%s",
+	fprintf(output, "  %p [%s "EV_SOCK_FMT"]%s%s%s%s%s%s%s",
 	    (void*)e, gloss, EV_SOCK_ARG(e->ev_fd),
 	    (e->ev_events&EV_READ)?" Read":"",
 	    (e->ev_events&EV_WRITE)?" Write":"",
 	    (e->ev_events&EV_CLOSED)?" EOF":"",
 	    (e->ev_events&EV_SIGNAL)?" Signal":"",
 	    (e->ev_events&EV_PERSIST)?" Persist":"",
+	    (e->ev_events&EV_ET)?" ET":"",
 	    (e->ev_flags&EVLIST_INTERNAL)?" Internal":"");
 	if (e->ev_flags & EVLIST_TIMEOUT) {
 		struct timeval tv;
@@ -3774,7 +3826,35 @@ void
 event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, short events)
 {
 	EVBASE_ACQUIRE_LOCK(base, th_base_lock);
-	evmap_io_active_(base, fd, events & (EV_READ|EV_WRITE|EV_CLOSED));
+
+	/* Activate any non timer events */
+	if (!(events & EV_TIMEOUT)) {
+		evmap_io_active_(base, fd, events & (EV_READ|EV_WRITE|EV_CLOSED));
+	} else {
+		/* If we want to activate timer events, loop and activate each event with
+		 * the same fd in both the timeheap and common timeouts list */
+		int i;
+		unsigned u;
+		struct event *ev;
+
+		for (u = 0; u < base->timeheap.n; ++u) {
+			ev = base->timeheap.p[u];
+			if (ev->ev_fd == fd) {
+				event_active_nolock_(ev, EV_TIMEOUT, 1);
+			}
+		}
+
+		for (i = 0; i < base->n_common_timeouts; ++i) {
+			struct common_timeout_list *ctl = base->common_timeout_queues[i];
+			TAILQ_FOREACH(ev, &ctl->events,
+				ev_timeout_pos.ev_next_with_common_timeout) {
+				if (ev->ev_fd == fd) {
+					event_active_nolock_(ev, EV_TIMEOUT, 1);
+				}
+			}
+		}
+	}
+
 	EVBASE_RELEASE_LOCK(base, th_base_lock);
 }
 
diff --git a/ipc/chromium/src/third_party/libevent/event_iocp.c b/ipc/chromium/src/third_party/libevent/event_iocp.c
index a9902fbc426e..6b2a2e15ef86 100644
--- a/ipc/chromium/src/third_party/libevent/event_iocp.c
+++ b/ipc/chromium/src/third_party/libevent/event_iocp.c
@@ -151,7 +151,7 @@ init_extension_functions(struct win32_extension_fns *ext)
 	const GUID connectex = WSAID_CONNECTEX;
 	const GUID getacceptexsockaddrs = WSAID_GETACCEPTEXSOCKADDRS;
 	SOCKET s = socket(AF_INET, SOCK_STREAM, 0);
-	if (s == INVALID_SOCKET)
+	if (s == EVUTIL_INVALID_SOCKET)
 		return;
 	ext->AcceptEx = get_extension_function(s, &acceptex);
 	ext->ConnectEx = get_extension_function(s, &connectex);
diff --git a/ipc/chromium/src/third_party/libevent/event_rpcgen.py b/ipc/chromium/src/third_party/libevent/event_rpcgen.py
index 9baf73026a00..0bae3b0fe662 100755
--- a/ipc/chromium/src/third_party/libevent/event_rpcgen.py
+++ b/ipc/chromium/src/third_party/libevent/event_rpcgen.py
@@ -1,4 +1,4 @@
-#!/usr/bin/env python2
+#!/usr/bin/env python
 #
 # Copyright (c) 2005-2007 Niels Provos <provos@citi.umich.edu>
 # Copyright (c) 2007-2012 Niels Provos and Nick Mathewson
@@ -6,65 +6,79 @@
 #
 # Generates marshaling code based on libevent.
 
+# pylint: disable=too-many-lines
+# pylint: disable=too-many-branches
+# pylint: disable=too-many-public-methods
+# pylint: disable=too-many-statements
+# pylint: disable=global-statement
+
 # TODO:
-# 1) use optparse to allow the strategy shell to parse options, and
-#    to allow the instantiated factory (for the specific output language)
-#    to parse remaining options
-# 2) move the globals into a class that manages execution (including the
-#    progress outputs that space stderr at the moment)
-# 3) emit other languages
+# 1) propagate the arguments/options parsed by argparse down to the
+#    instantiated factory objects.
+# 2) move the globals into a class that manages execution, including the
+#    progress outputs that go to stderr at the moment.
+# 3) emit other languages.
 
-import sys
+import argparse
 import re
+import sys
 
 _NAME = "event_rpcgen.py"
 _VERSION = "0.1"
 
 # Globals
-line_count = 0
+LINE_COUNT = 0
 
-white = re.compile(r'\s+')
-cppcomment = re.compile(r'\/\/.*$')
-nonident = re.compile(r'[^a-zA-Z0-9_]')
-structref = re.compile(r'^struct\[([a-zA-Z_][a-zA-Z0-9_]*)\]$')
-structdef = re.compile(r'^struct +[a-zA-Z_][a-zA-Z0-9_]* *{$')
+CPPCOMMENT_RE = re.compile(r"\/\/.*$")
+NONIDENT_RE = re.compile(r"\W")
+PREPROCESSOR_DEF_RE = re.compile(r"^#define")
+STRUCT_REF_RE = re.compile(r"^struct\[(?P<name>[a-zA-Z_][a-zA-Z0-9_]*)\]$")
+STRUCT_DEF_RE = re.compile(r"^struct +[a-zA-Z_][a-zA-Z0-9_]* *{$")
+WHITESPACE_RE = re.compile(r"\s+")
 
-headerdirect = []
-cppdirect = []
+HEADER_DIRECT = []
+CPP_DIRECT = []
+
+QUIETLY = False
 
-QUIETLY = 0
 
 def declare(s):
     if not QUIETLY:
-        print s
+        print(s)
+
 
 def TranslateList(mylist, mydict):
-    return map(lambda x: x % mydict, mylist)
+    return [x % mydict for x in mylist]
+
 
-# Exception class for parse errors
 class RpcGenError(Exception):
-        def __init__(self, why):
-                self.why = why
-        def __str__(self):
-                return str(self.why)
+    """An Exception class for parse errors."""
+
+    def __init__(self, why): # pylint: disable=super-init-not-called
+        self.why = why
+
+    def __str__(self):
+        return str(self.why)
+
 
 # Holds everything that makes a struct
-class Struct:
+class Struct(object):
     def __init__(self, name):
         self._name = name
         self._entries = []
         self._tags = {}
-        declare('  Created struct: %s' % name)
+        declare("  Created struct: %s" % name)
 
     def AddEntry(self, entry):
-        if self._tags.has_key(entry.Tag()):
+        if entry.Tag() in self._tags:
             raise RpcGenError(
                 'Entry "%s" duplicates tag number %d from "%s" '
-                'around line %d' % (entry.Name(), entry.Tag(),
-                                    self._tags[entry.Tag()], line_count))
+                "around line %d"
+                % (entry.Name(), entry.Tag(), self._tags[entry.Tag()], LINE_COUNT)
+            )
         self._entries.append(entry)
         self._tags[entry.Tag()] = entry.Name()
-        declare('    Added entry: %s' % entry.Name())
+        declare("    Added entry: %s" % entry.Name())
 
     def Name(self):
         return self._name
@@ -75,10 +89,12 @@ class Struct:
         name = "%s_%s" % (self._name, entry.Name())
         return name.upper()
 
-    def PrintIndented(self, file, ident, code):
+    @staticmethod
+    def PrintIndented(filep, ident, code):
         """Takes an array, add indentation to each entry and prints it."""
         for entry in code:
-            print >>file, '%s%s' % (ident, entry)
+            filep.write("%s%s\n" % (ident, entry))
+
 
 class StructCCode(Struct):
     """ Knows how to generate C code for a struct """
@@ -86,44 +102,41 @@ class StructCCode(Struct):
     def __init__(self, name):
         Struct.__init__(self, name)
 
-    def PrintTags(self, file):
+    def PrintTags(self, filep):
         """Prints the tag definitions for a structure."""
-        print >>file, '/* Tag definition for %s */' % self._name
-        print >>file, 'enum %s_ {' % self._name.lower()
+        filep.write("/* Tag definition for %s */\n" % self._name)
+        filep.write("enum %s_ {\n" % self._name.lower())
         for entry in self._entries:
-            print >>file, '  %s=%d,' % (self.EntryTagName(entry),
-                                        entry.Tag())
-        print >>file, '  %s_MAX_TAGS' % (self._name.upper())
-        print >>file, '};\n'
+            filep.write("  %s=%d,\n" % (self.EntryTagName(entry), entry.Tag()))
+        filep.write("  %s_MAX_TAGS\n" % (self._name.upper()))
+        filep.write("};\n\n")
 
-    def PrintForwardDeclaration(self, file):
-        print >>file, 'struct %s;' % self._name
+    def PrintForwardDeclaration(self, filep):
+        filep.write("struct %s;\n" % self._name)
 
-    def PrintDeclaration(self, file):
-        print >>file, '/* Structure declaration for %s */' % self._name
-        print >>file, 'struct %s_access_ {' % self._name
+    def PrintDeclaration(self, filep):
+        filep.write("/* Structure declaration for %s */\n" % self._name)
+        filep.write("struct %s_access_ {\n" % self._name)
         for entry in self._entries:
-            dcl = entry.AssignDeclaration('(*%s_assign)' % entry.Name())
-            dcl.extend(
-                entry.GetDeclaration('(*%s_get)' % entry.Name()))
+            dcl = entry.AssignDeclaration("(*%s_assign)" % entry.Name())
+            dcl.extend(entry.GetDeclaration("(*%s_get)" % entry.Name()))
             if entry.Array():
-                dcl.extend(
-                    entry.AddDeclaration('(*%s_add)' % entry.Name()))
-            self.PrintIndented(file, '  ', dcl)
-        print >>file, '};\n'
+                dcl.extend(entry.AddDeclaration("(*%s_add)" % entry.Name()))
+            self.PrintIndented(filep, "  ", dcl)
+        filep.write("};\n\n")
 
-        print >>file, 'struct %s {' % self._name
-        print >>file, '  struct %s_access_ *base;\n' % self._name
+        filep.write("struct %s {\n" % self._name)
+        filep.write("  struct %s_access_ *base;\n\n" % self._name)
         for entry in self._entries:
             dcl = entry.Declaration()
-            self.PrintIndented(file, '  ', dcl)
-        print >>file, ''
+            self.PrintIndented(filep, "  ", dcl)
+        filep.write("\n")
         for entry in self._entries:
-            print >>file, '  ev_uint8_t %s_set;' % entry.Name()
-        print >>file, '};\n'
+            filep.write("  ev_uint8_t %s_set;\n" % entry.Name())
+        filep.write("};\n\n")
 
-        print >>file, \
-"""struct %(name)s *%(name)s_new(void);
+        filep.write(
+            """struct %(name)s *%(name)s_new(void);
 struct %(name)s *%(name)s_new_with_arg(void *);
 void %(name)s_free(struct %(name)s *);
 void %(name)s_clear(struct %(name)s *);
@@ -133,227 +146,291 @@ int %(name)s_complete(struct %(name)s *);
 void evtag_marshal_%(name)s(struct evbuffer *, ev_uint32_t,
     const struct %(name)s *);
 int evtag_unmarshal_%(name)s(struct evbuffer *, ev_uint32_t,
-    struct %(name)s *);""" % { 'name' : self._name }
-
+    struct %(name)s *);\n"""
+            % {"name": self._name}
+        )
 
         # Write a setting function of every variable
         for entry in self._entries:
-            self.PrintIndented(file, '', entry.AssignDeclaration(
-                entry.AssignFuncName()))
-            self.PrintIndented(file, '', entry.GetDeclaration(
-                entry.GetFuncName()))
+            self.PrintIndented(
+                filep, "", entry.AssignDeclaration(entry.AssignFuncName())
+            )
+            self.PrintIndented(filep, "", entry.GetDeclaration(entry.GetFuncName()))
             if entry.Array():
-                self.PrintIndented(file, '', entry.AddDeclaration(
-                    entry.AddFuncName()))
+                self.PrintIndented(filep, "", entry.AddDeclaration(entry.AddFuncName()))
 
-        print >>file, '/* --- %s done --- */\n' % self._name
+        filep.write("/* --- %s done --- */\n\n" % self._name)
 
-    def PrintCode(self, file):
-        print >>file, ('/*\n'
-                       ' * Implementation of %s\n'
-                       ' */\n') % self._name
+    def PrintCode(self, filep):
+        filep.write(
+            """/*
+ * Implementation of %s
+ */
+"""
+            % (self._name)
+        )
 
-        print >>file, \
-              'static struct %(name)s_access_ %(name)s_base__ = {' % \
-              { 'name' : self._name }
+        filep.write(
+            """
+static struct %(name)s_access_ %(name)s_base__ = {
+"""
+            % {"name": self._name}
+        )
         for entry in self._entries:
-            self.PrintIndented(file, '  ', entry.CodeBase())
-        print >>file, '};\n'
+            self.PrintIndented(filep, "  ", entry.CodeBase())
+        filep.write("};\n\n")
 
         # Creation
-        print >>file, (
-            'struct %(name)s *\n'
-            '%(name)s_new(void)\n'
-            '{\n'
-            '  return %(name)s_new_with_arg(NULL);\n'
-            '}\n'
-            '\n'
-            'struct %(name)s *\n'
-            '%(name)s_new_with_arg(void *unused)\n'
-            '{\n'
-            '  struct %(name)s *tmp;\n'
-            '  if ((tmp = malloc(sizeof(struct %(name)s))) == NULL) {\n'
-            '    event_warn("%%s: malloc", __func__);\n'
-            '    return (NULL);\n'
-            '  }\n'
-            '  tmp->base = &%(name)s_base__;\n') % { 'name' : self._name }
+        filep.write(
+            """struct %(name)s *
+%(name)s_new(void)
+{
+  return %(name)s_new_with_arg(NULL);
+}
+
+struct %(name)s *
+%(name)s_new_with_arg(void *unused)
+{
+  struct %(name)s *tmp;
+  if ((tmp = malloc(sizeof(struct %(name)s))) == NULL) {
+    event_warn("%%s: malloc", __func__);
+    return (NULL);
+  }
+  tmp->base = &%(name)s_base__;
+
+"""
+            % {"name": self._name}
+        )
 
         for entry in self._entries:
-            self.PrintIndented(file, '  ', entry.CodeInitialize('tmp'))
-            print >>file, '  tmp->%s_set = 0;\n' % entry.Name()
+            self.PrintIndented(filep, "  ", entry.CodeInitialize("tmp"))
+            filep.write("  tmp->%s_set = 0;\n\n" % entry.Name())
+
+        filep.write(
+            """  return (tmp);
+}
 
-        print >>file, (
-            '  return (tmp);\n'
-            '}\n')
+"""
+        )
 
         # Adding
         for entry in self._entries:
             if entry.Array():
-                self.PrintIndented(file, '', entry.CodeAdd())
-            print >>file, ''
+                self.PrintIndented(filep, "", entry.CodeAdd())
+            filep.write("\n")
 
         # Assigning
         for entry in self._entries:
-            self.PrintIndented(file, '', entry.CodeAssign())
-            print >>file, ''
+            self.PrintIndented(filep, "", entry.CodeAssign())
+            filep.write("\n")
 
         # Getting
         for entry in self._entries:
-            self.PrintIndented(file, '', entry.CodeGet())
-            print >>file, ''
+            self.PrintIndented(filep, "", entry.CodeGet())
+            filep.write("\n")
 
         # Clearing
-        print >>file, ( 'void\n'
-                        '%(name)s_clear(struct %(name)s *tmp)\n'
-                        '{'
-                        ) % { 'name' : self._name }
+        filep.write(
+            """void
+%(name)s_clear(struct %(name)s *tmp)
+{
+"""
+            % {"name": self._name}
+        )
         for entry in self._entries:
-            self.PrintIndented(file, '  ', entry.CodeClear('tmp'))
+            self.PrintIndented(filep, "  ", entry.CodeClear("tmp"))
 
-        print >>file, '}\n'
+        filep.write("}\n\n")
 
         # Freeing
-        print >>file, ( 'void\n'
-                        '%(name)s_free(struct %(name)s *tmp)\n'
-                        '{'
-                        ) % { 'name' : self._name }
+        filep.write(
+            """void
+%(name)s_free(struct %(name)s *tmp)
+{
+"""
+            % {"name": self._name}
+        )
 
         for entry in self._entries:
-            self.PrintIndented(file, '  ', entry.CodeFree('tmp'))
+            self.PrintIndented(filep, "  ", entry.CodeFree("tmp"))
+
+        filep.write(
+            """  free(tmp);
+}
 
-        print >>file, ('  free(tmp);\n'
-                       '}\n')
+"""
+        )
 
         # Marshaling
-        print >>file, ('void\n'
-                       '%(name)s_marshal(struct evbuffer *evbuf, '
-                       'const struct %(name)s *tmp)'
-                       '{') % { 'name' : self._name }
+        filep.write(
+            """void
+%(name)s_marshal(struct evbuffer *evbuf, const struct %(name)s *tmp) {
+"""
+            % {"name": self._name}
+        )
         for entry in self._entries:
-            indent = '  '
+            indent = "  "
             # Optional entries do not have to be set
             if entry.Optional():
-                indent += '  '
-                print >>file, '  if (tmp->%s_set) {' % entry.Name()
+                indent += "  "
+                filep.write("  if (tmp->%s_set) {\n" % entry.Name())
             self.PrintIndented(
-                file, indent,
-                entry.CodeMarshal('evbuf', self.EntryTagName(entry),
-                                  entry.GetVarName('tmp'),
-                                  entry.GetVarLen('tmp')))
+                filep,
+                indent,
+                entry.CodeMarshal(
+                    "evbuf",
+                    self.EntryTagName(entry),
+                    entry.GetVarName("tmp"),
+                    entry.GetVarLen("tmp"),
+                ),
+            )
             if entry.Optional():
-                print >>file, '  }'
+                filep.write("  }\n")
 
-        print >>file, '}\n'
+        filep.write("}\n\n")
 
         # Unmarshaling
-        print >>file, ('int\n'
-                       '%(name)s_unmarshal(struct %(name)s *tmp, '
-                       ' struct evbuffer *evbuf)\n'
-                       '{\n'
-                       '  ev_uint32_t tag;\n'
-                       '  while (evbuffer_get_length(evbuf) > 0) {\n'
-                       '    if (evtag_peek(evbuf, &tag) == -1)\n'
-                       '      return (-1);\n'
-                       '    switch (tag) {\n'
-                       ) % { 'name' : self._name }
+        filep.write(
+            """int
+%(name)s_unmarshal(struct %(name)s *tmp, struct evbuffer *evbuf)
+{
+  ev_uint32_t tag;
+  while (evbuffer_get_length(evbuf) > 0) {
+    if (evtag_peek(evbuf, &tag) == -1)
+      return (-1);
+    switch (tag) {
+
+"""
+            % {"name": self._name}
+        )
         for entry in self._entries:
-            print >>file, '      case %s:\n' % self.EntryTagName(entry)
+            filep.write("      case %s:\n" % (self.EntryTagName(entry)))
             if not entry.Array():
-                print >>file, (
-                    '        if (tmp->%s_set)\n'
-                    '          return (-1);'
-                    ) % (entry.Name())
+                filep.write(
+                    """        if (tmp->%s_set)
+          return (-1);
+"""
+                    % (entry.Name())
+                )
 
             self.PrintIndented(
-                file, '        ',
-                entry.CodeUnmarshal('evbuf',
-                                    self.EntryTagName(entry),
-                                    entry.GetVarName('tmp'),
-                                    entry.GetVarLen('tmp')))
-
-            print >>file, ( '        tmp->%s_set = 1;\n' % entry.Name() +
-                            '        break;\n' )
-        print >>file, ( '      default:\n'
-                        '        return -1;\n'
-                        '    }\n'
-                        '  }\n' )
+                filep,
+                "        ",
+                entry.CodeUnmarshal(
+                    "evbuf",
+                    self.EntryTagName(entry),
+                    entry.GetVarName("tmp"),
+                    entry.GetVarLen("tmp"),
+                ),
+            )
+
+            filep.write(
+                """        tmp->%s_set = 1;
+        break;
+"""
+                % (entry.Name())
+            )
+        filep.write(
+            """      default:
+        return -1;
+    }
+  }
+
+"""
+        )
         # Check if it was decoded completely
-        print >>file, ( '  if (%(name)s_complete(tmp) == -1)\n'
-                        '    return (-1);'
-                        ) % { 'name' : self._name }
-
-        # Successfully decoded
-        print >>file, ( '  return (0);\n'
-                        '}\n')
+        filep.write(
+            """  if (%(name)s_complete(tmp) == -1)
+    return (-1);
+  return (0);
+}
+"""
+            % {"name": self._name}
+        )
 
         # Checking if a structure has all the required data
-        print >>file, (
-            'int\n'
-            '%(name)s_complete(struct %(name)s *msg)\n'
-            '{' ) % { 'name' : self._name }
+        filep.write(
+            """
+int
+%(name)s_complete(struct %(name)s *msg)
+{
+"""
+            % {"name": self._name}
+        )
         for entry in self._entries:
             if not entry.Optional():
                 code = [
-                    'if (!msg->%(name)s_set)',
-                    '  return (-1);' ]
+                    """if (!msg->%(name)s_set)
+    return (-1);"""
+                ]
                 code = TranslateList(code, entry.GetTranslation())
-                self.PrintIndented(
-                    file, '  ', code)
+                self.PrintIndented(filep, "  ", code)
 
             self.PrintIndented(
-                file, '  ',
-                entry.CodeComplete('msg', entry.GetVarName('msg')))
-        print >>file, (
-            '  return (0);\n'
-            '}\n' )
+                filep, "  ", entry.CodeComplete("msg", entry.GetVarName("msg"))
+            )
+        filep.write(
+            """  return (0);
+}
+"""
+        )
 
         # Complete message unmarshaling
-        print >>file, (
-            'int\n'
-            'evtag_unmarshal_%(name)s(struct evbuffer *evbuf, '
-            'ev_uint32_t need_tag, struct %(name)s *msg)\n'
-            '{\n'
-            '  ev_uint32_t tag;\n'
-            '  int res = -1;\n'
-            '\n'
-            '  struct evbuffer *tmp = evbuffer_new();\n'
-            '\n'
-            '  if (evtag_unmarshal(evbuf, &tag, tmp) == -1'
-            ' || tag != need_tag)\n'
-            '    goto error;\n'
-            '\n'
-            '  if (%(name)s_unmarshal(msg, tmp) == -1)\n'
-            '    goto error;\n'
-            '\n'
-            '  res = 0;\n'
-            '\n'
-            ' error:\n'
-            '  evbuffer_free(tmp);\n'
-            '  return (res);\n'
-            '}\n' ) % { 'name' : self._name }
+        filep.write(
+            """
+int
+evtag_unmarshal_%(name)s(struct evbuffer *evbuf, ev_uint32_t need_tag,
+  struct %(name)s *msg)
+{
+  ev_uint32_t tag;
+  int res = -1;
+
+  struct evbuffer *tmp = evbuffer_new();
+
+  if (evtag_unmarshal(evbuf, &tag, tmp) == -1 || tag != need_tag)
+    goto error;
+
+  if (%(name)s_unmarshal(msg, tmp) == -1)
+    goto error;
+
+  res = 0;
+
+ error:
+  evbuffer_free(tmp);
+  return (res);
+}
+"""
+            % {"name": self._name}
+        )
 
         # Complete message marshaling
-        print >>file, (
-            'void\n'
-            'evtag_marshal_%(name)s(struct evbuffer *evbuf, ev_uint32_t tag, '
-            'const struct %(name)s *msg)\n'
-            '{\n'
-            '  struct evbuffer *buf_ = evbuffer_new();\n'
-            '  assert(buf_ != NULL);\n'
-            '  %(name)s_marshal(buf_, msg);\n'
-            '  evtag_marshal_buffer(evbuf, tag, buf_);\n '
-            '  evbuffer_free(buf_);\n'
-            '}\n' ) % { 'name' : self._name }
-
-class Entry:
-    def __init__(self, type, name, tag):
-        self._type = type
+        filep.write(
+            """
+void
+evtag_marshal_%(name)s(struct evbuffer *evbuf, ev_uint32_t tag,
+    const struct %(name)s *msg)
+{
+  struct evbuffer *buf_ = evbuffer_new();
+  assert(buf_ != NULL);
+  %(name)s_marshal(buf_, msg);
+  evtag_marshal_buffer(evbuf, tag, buf_);
+  evbuffer_free(buf_);
+}
+
+"""
+            % {"name": self._name}
+        )
+
+
+class Entry(object):
+    def __init__(self, ent_type, name, tag):
+        self._type = ent_type
         self._name = name
         self._tag = int(tag)
-        self._ctype = type
-        self._optional = 0
-        self._can_be_array = 0
-        self._array = 0
+        self._ctype = ent_type
+        self._optional = False
+        self._can_be_array = False
+        self._array = False
         self._line_count = -1
         self._struct = None
         self._refname = None
@@ -361,8 +438,9 @@ class Entry:
         self._optpointer = True
         self._optaddarg = True
 
-    def GetInitializer(self):
-        assert 0, "Entry does not provide initializer"
+    @staticmethod
+    def GetInitializer():
+        raise NotImplementedError("Entry does not provide an initializer")
 
     def SetStruct(self, struct):
         self._struct = struct
@@ -389,326 +467,351 @@ class Entry:
     def Type(self):
         return self._type
 
-    def MakeArray(self, yes=1):
-        self._array = yes
+    def MakeArray(self):
+        self._array = True
 
     def MakeOptional(self):
-        self._optional = 1
+        self._optional = True
 
     def Verify(self):
         if self.Array() and not self._can_be_array:
             raise RpcGenError(
                 'Entry "%s" cannot be created as an array '
-                'around line %d' % (self._name, self.LineCount()))
+                "around line %d" % (self._name, self.LineCount())
+            )
         if not self._struct:
             raise RpcGenError(
                 'Entry "%s" does not know which struct it belongs to '
-                'around line %d' % (self._name, self.LineCount()))
+                "around line %d" % (self._name, self.LineCount())
+            )
         if self._optional and self._array:
             raise RpcGenError(
                 'Entry "%s" has illegal combination of optional and array '
-                'around line %d' % (self._name, self.LineCount()))
+                "around line %d" % (self._name, self.LineCount())
+            )
 
-    def GetTranslation(self, extradict = {}):
+    def GetTranslation(self, extradict=None):
+        if extradict is None:
+            extradict = {}
         mapping = {
-            "parent_name" : self._struct.Name(),
-            "name" : self._name,
-            "ctype" : self._ctype,
-            "refname" : self._refname,
-            "optpointer" : self._optpointer and "*" or "",
-            "optreference" : self._optpointer and "&" or "",
-            "optaddarg" :
-            self._optaddarg and ", const %s value" % self._ctype or ""
-            }
-        for (k, v) in extradict.items():
+            "parent_name": self._struct.Name(),
+            "name": self._name,
+            "ctype": self._ctype,
+            "refname": self._refname,
+            "optpointer": self._optpointer and "*" or "",
+            "optreference": self._optpointer and "&" or "",
+            "optaddarg": self._optaddarg and ", const %s value" % self._ctype or "",
+        }
+        for (k, v) in list(extradict.items()):
             mapping[k] = v
 
         return mapping
 
     def GetVarName(self, var):
-        return '%(var)s->%(name)s_data' % self.GetTranslation({ 'var' : var })
+        return "%(var)s->%(name)s_data" % self.GetTranslation({"var": var})
 
-    def GetVarLen(self, var):
-        return 'sizeof(%s)' % self._ctype
+    def GetVarLen(self, _var):
+        return "sizeof(%s)" % self._ctype
 
     def GetFuncName(self):
-        return '%s_%s_get' % (self._struct.Name(), self._name)
+        return "%s_%s_get" % (self._struct.Name(), self._name)
 
     def GetDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, %s *);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, %s *);" % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def CodeGet(self):
-        code = (
-            'int',
-            '%(parent_name)s_%(name)s_get(struct %(parent_name)s *msg, '
-            '%(ctype)s *value)',
-            '{',
-            '  if (msg->%(name)s_set != 1)',
-            '    return (-1);',
-            '  *value = msg->%(name)s_data;',
-            '  return (0);',
-            '}' )
-        code = '\n'.join(code)
+        code = """int
+%(parent_name)s_%(name)s_get(struct %(parent_name)s *msg, %(ctype)s *value)
+{
+  if (msg->%(name)s_set != 1)
+    return (-1);
+  *value = msg->%(name)s_data;
+  return (0);
+}"""
         code = code % self.GetTranslation()
-        return code.split('\n')
+        return code.split("\n")
 
     def AssignFuncName(self):
-        return '%s_%s_assign' % (self._struct.Name(), self._name)
+        return "%s_%s_assign" % (self._struct.Name(), self._name)
 
     def AddFuncName(self):
-        return '%s_%s_add' % (self._struct.Name(), self._name)
+        return "%s_%s_add" % (self._struct.Name(), self._name)
 
     def AssignDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, const %s);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, const %s);"
+            % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def CodeAssign(self):
-        code = [ 'int',
-                 '%(parent_name)s_%(name)s_assign(struct %(parent_name)s *msg,'
-                 ' const %(ctype)s value)',
-                 '{',
-                 '  msg->%(name)s_set = 1;',
-                 '  msg->%(name)s_data = value;',
-                 '  return (0);',
-                 '}' ]
-        code = '\n'.join(code)
+        code = [
+            "int",
+            "%(parent_name)s_%(name)s_assign(struct %(parent_name)s *msg,"
+            " const %(ctype)s value)",
+            "{",
+            "  msg->%(name)s_set = 1;",
+            "  msg->%(name)s_data = value;",
+            "  return (0);",
+            "}",
+        ]
+        code = "\n".join(code)
         code = code % self.GetTranslation()
-        return code.split('\n')
+        return code.split("\n")
 
     def CodeClear(self, structname):
-        code = [ '%s->%s_set = 0;' % (structname, self.Name()) ]
+        code = ["%s->%s_set = 0;" % (structname, self.Name())]
 
         return code
 
-    def CodeComplete(self, structname, var_name):
+    @staticmethod
+    def CodeComplete(_structname, _var_name):
         return []
 
-    def CodeFree(self, name):
+    @staticmethod
+    def CodeFree(_name):
         return []
 
     def CodeBase(self):
-        code = [
-            '%(parent_name)s_%(name)s_assign,',
-            '%(parent_name)s_%(name)s_get,'
-            ]
+        code = ["%(parent_name)s_%(name)s_assign,", "%(parent_name)s_%(name)s_get,"]
         if self.Array():
-            code.append('%(parent_name)s_%(name)s_add,')
+            code.append("%(parent_name)s_%(name)s_add,")
 
-        code = '\n'.join(code)
+        code = "\n".join(code)
         code = code % self.GetTranslation()
-        return code.split('\n')
+        return code.split("\n")
+
 
 class EntryBytes(Entry):
-    def __init__(self, type, name, tag, length):
+    def __init__(self, ent_type, name, tag, length):
         # Init base class
-        Entry.__init__(self, type, name, tag)
+        super(EntryBytes, self).__init__(ent_type, name, tag)
 
         self._length = length
-        self._ctype = 'ev_uint8_t'
+        self._ctype = "ev_uint8_t"
 
-    def GetInitializer(self):
+    @staticmethod
+    def GetInitializer():
         return "NULL"
 
-    def GetVarLen(self, var):
-        return '(%s)' % self._length
+    def GetVarLen(self, _var):
+        return "(%s)" % self._length
 
-    def CodeArrayAdd(self, varname, value):
+    @staticmethod
+    def CodeArrayAdd(varname, _value):
         # XXX: copy here
-        return [ '%(varname)s = NULL;' % { 'varname' : varname } ]
+        return ["%(varname)s = NULL;" % {"varname": varname}]
 
     def GetDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, %s **);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, %s **);" % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def AssignDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, const %s *);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, const %s *);"
+            % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def Declaration(self):
-        dcl  = ['ev_uint8_t %s_data[%s];' % (self._name, self._length)]
+        dcl = ["ev_uint8_t %s_data[%s];" % (self._name, self._length)]
 
         return dcl
 
     def CodeGet(self):
         name = self._name
-        code = [ 'int',
-                 '%s_%s_get(struct %s *msg, %s **value)' % (
-            self._struct.Name(), name,
-            self._struct.Name(), self._ctype),
-                 '{',
-                 '  if (msg->%s_set != 1)' % name,
-                 '    return (-1);',
-                 '  *value = msg->%s_data;' % name,
-                 '  return (0);',
-                 '}' ]
+        code = [
+            "int",
+            "%s_%s_get(struct %s *msg, %s **value)"
+            % (self._struct.Name(), name, self._struct.Name(), self._ctype),
+            "{",
+            "  if (msg->%s_set != 1)" % name,
+            "    return (-1);",
+            "  *value = msg->%s_data;" % name,
+            "  return (0);",
+            "}",
+        ]
         return code
 
     def CodeAssign(self):
         name = self._name
-        code = [ 'int',
-                 '%s_%s_assign(struct %s *msg, const %s *value)' % (
-            self._struct.Name(), name,
-            self._struct.Name(), self._ctype),
-                 '{',
-                 '  msg->%s_set = 1;' % name,
-                 '  memcpy(msg->%s_data, value, %s);' % (
-            name, self._length),
-                 '  return (0);',
-                 '}' ]
+        code = [
+            "int",
+            "%s_%s_assign(struct %s *msg, const %s *value)"
+            % (self._struct.Name(), name, self._struct.Name(), self._ctype),
+            "{",
+            "  msg->%s_set = 1;" % name,
+            "  memcpy(msg->%s_data, value, %s);" % (name, self._length),
+            "  return (0);",
+            "}",
+        ]
         return code
 
     def CodeUnmarshal(self, buf, tag_name, var_name, var_len):
-        code = [  'if (evtag_unmarshal_fixed(%(buf)s, %(tag)s, '
-                  '%(var)s, %(varlen)s) == -1) {',
-                  '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
-                  '  return (-1);',
-                  '}'
-                  ]
-        return TranslateList(code,
-                             self.GetTranslation({
-            'var' : var_name,
-            'varlen' : var_len,
-            'buf' : buf,
-            'tag' : tag_name }))
-
-    def CodeMarshal(self, buf, tag_name, var_name, var_len):
-        code = ['evtag_marshal(%s, %s, %s, %s);' % (
-            buf, tag_name, var_name, var_len)]
+        code = [
+            "if (evtag_unmarshal_fixed(%(buf)s, %(tag)s, "
+            "%(var)s, %(varlen)s) == -1) {",
+            '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
+            "  return (-1);",
+            "}",
+        ]
+        return TranslateList(
+            code,
+            self.GetTranslation(
+                {"var": var_name, "varlen": var_len, "buf": buf, "tag": tag_name}
+            ),
+        )
+
+    @staticmethod
+    def CodeMarshal(buf, tag_name, var_name, var_len):
+        code = ["evtag_marshal(%s, %s, %s, %s);" % (buf, tag_name, var_name, var_len)]
         return code
 
     def CodeClear(self, structname):
-        code = [ '%s->%s_set = 0;' % (structname, self.Name()),
-                 'memset(%s->%s_data, 0, sizeof(%s->%s_data));' % (
-            structname, self._name, structname, self._name)]
+        code = [
+            "%s->%s_set = 0;" % (structname, self.Name()),
+            "memset(%s->%s_data, 0, sizeof(%s->%s_data));"
+            % (structname, self._name, structname, self._name),
+        ]
 
         return code
 
     def CodeInitialize(self, name):
-        code  = ['memset(%s->%s_data, 0, sizeof(%s->%s_data));' % (
-            name, self._name, name, self._name)]
+        code = [
+            "memset(%s->%s_data, 0, sizeof(%s->%s_data));"
+            % (name, self._name, name, self._name)
+        ]
         return code
 
     def Verify(self):
         if not self._length:
             raise RpcGenError(
                 'Entry "%s" needs a length '
-                'around line %d' % (self._name, self.LineCount()))
+                "around line %d" % (self._name, self.LineCount())
+            )
+
+        super(EntryBytes, self).Verify()
 
-        Entry.Verify(self)
 
 class EntryInt(Entry):
-    def __init__(self, type, name, tag, bits=32):
+    def __init__(self, ent_type, name, tag, bits=32):
         # Init base class
-        Entry.__init__(self, type, name, tag)
+        super(EntryInt, self).__init__(ent_type, name, tag)
 
-        self._can_be_array = 1
+        self._can_be_array = True
         if bits == 32:
-            self._ctype = 'ev_uint32_t'
-            self._marshal_type = 'int'
+            self._ctype = "ev_uint32_t"
+            self._marshal_type = "int"
         if bits == 64:
-            self._ctype = 'ev_uint64_t'
-            self._marshal_type = 'int64'
+            self._ctype = "ev_uint64_t"
+            self._marshal_type = "int64"
 
-    def GetInitializer(self):
+    @staticmethod
+    def GetInitializer():
         return "0"
 
-    def CodeArrayFree(self, var):
+    @staticmethod
+    def CodeArrayFree(_var):
         return []
 
-    def CodeArrayAssign(self, varname, srcvar):
-        return [ '%(varname)s = %(srcvar)s;' % { 'varname' : varname,
-                                                'srcvar' : srcvar } ]
+    @staticmethod
+    def CodeArrayAssign(varname, srcvar):
+        return ["%(varname)s = %(srcvar)s;" % {"varname": varname, "srcvar": srcvar}]
 
-    def CodeArrayAdd(self, varname, value):
+    @staticmethod
+    def CodeArrayAdd(varname, value):
         """Returns a new entry of this type."""
-        return [ '%(varname)s = %(value)s;' % { 'varname' : varname,
-                                              'value' : value } ]
+        return ["%(varname)s = %(value)s;" % {"varname": varname, "value": value}]
 
-    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):
+    def CodeUnmarshal(self, buf, tag_name, var_name, _var_len):
         code = [
-            'if (evtag_unmarshal_%(ma)s(%(buf)s, %(tag)s, &%(var)s) == -1) {',
+            "if (evtag_unmarshal_%(ma)s(%(buf)s, %(tag)s, &%(var)s) == -1) {",
             '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
-            '  return (-1);',
-            '}' ]
-        code = '\n'.join(code) % self.GetTranslation({
-            'ma'  : self._marshal_type,
-            'buf' : buf,
-            'tag' : tag_name,
-            'var' : var_name })
-        return code.split('\n')
-
-    def CodeMarshal(self, buf, tag_name, var_name, var_len):
+            "  return (-1);",
+            "}",
+        ]
+        code = "\n".join(code) % self.GetTranslation(
+            {"ma": self._marshal_type, "buf": buf, "tag": tag_name, "var": var_name}
+        )
+        return code.split("\n")
+
+    def CodeMarshal(self, buf, tag_name, var_name, _var_len):
         code = [
-            'evtag_marshal_%s(%s, %s, %s);' % (
-            self._marshal_type, buf, tag_name, var_name)]
+            "evtag_marshal_%s(%s, %s, %s);"
+            % (self._marshal_type, buf, tag_name, var_name)
+        ]
         return code
 
     def Declaration(self):
-        dcl  = ['%s %s_data;' % (self._ctype, self._name)]
+        dcl = ["%s %s_data;" % (self._ctype, self._name)]
 
         return dcl
 
     def CodeInitialize(self, name):
-        code = ['%s->%s_data = 0;' % (name, self._name)]
+        code = ["%s->%s_data = 0;" % (name, self._name)]
         return code
 
+
 class EntryString(Entry):
-    def __init__(self, type, name, tag):
+    def __init__(self, ent_type, name, tag):
         # Init base class
-        Entry.__init__(self, type, name, tag)
+        super(EntryString, self).__init__(ent_type, name, tag)
 
-        self._can_be_array = 1
-        self._ctype = 'char *'
+        self._can_be_array = True
+        self._ctype = "char *"
 
-    def GetInitializer(self):
+    @staticmethod
+    def GetInitializer():
         return "NULL"
 
-    def CodeArrayFree(self, varname):
-        code = [
-            'if (%(var)s != NULL) free(%(var)s);' ]
+    @staticmethod
+    def CodeArrayFree(varname):
+        code = ["if (%(var)s != NULL) free(%(var)s);"]
 
-        return TranslateList(code, { 'var' : varname })
+        return TranslateList(code, {"var": varname})
 
-    def CodeArrayAssign(self, varname, srcvar):
+    @staticmethod
+    def CodeArrayAssign(varname, srcvar):
         code = [
-            'if (%(var)s != NULL)',
-            '  free(%(var)s);',
-            '%(var)s = strdup(%(srcvar)s);',
-            'if (%(var)s == NULL) {',
+            "if (%(var)s != NULL)",
+            "  free(%(var)s);",
+            "%(var)s = strdup(%(srcvar)s);",
+            "if (%(var)s == NULL) {",
             '  event_warnx("%%s: strdup", __func__);',
-            '  return (-1);',
-            '}' ]
+            "  return (-1);",
+            "}",
+        ]
 
-        return TranslateList(code, { 'var' : varname,
-                                     'srcvar' : srcvar })
+        return TranslateList(code, {"var": varname, "srcvar": srcvar})
 
-    def CodeArrayAdd(self, varname, value):
+    @staticmethod
+    def CodeArrayAdd(varname, value):
         code = [
-            'if (%(value)s != NULL) {',
-            '  %(var)s = strdup(%(value)s);',
-            '  if (%(var)s == NULL) {',
-            '    goto error;',
-            '  }',
-            '} else {',
-            '  %(var)s = NULL;',
-            '}' ]
-
-        return TranslateList(code, { 'var' : varname,
-                                     'value' : value })
+            "if (%(value)s != NULL) {",
+            "  %(var)s = strdup(%(value)s);",
+            "  if (%(var)s == NULL) {",
+            "    goto error;",
+            "  }",
+            "} else {",
+            "  %(var)s = NULL;",
+            "}",
+        ]
+
+        return TranslateList(code, {"var": varname, "value": value})
 
     def GetVarLen(self, var):
-        return 'strlen(%s)' % self.GetVarName(var)
+        return "strlen(%s)" % self.GetVarName(var)
 
-    def CodeMakeInitalize(self, varname):
-        return '%(varname)s = NULL;' % { 'varname' : varname }
+    @staticmethod
+    def CodeMakeInitalize(varname):
+        return "%(varname)s = NULL;" % {"varname": varname}
 
     def CodeAssign(self):
-        name = self._name
         code = """int
 %(parent_name)s_%(name)s_assign(struct %(parent_name)s *msg,
     const %(ctype)s value)
@@ -719,131 +822,137 @@ class EntryString(Entry):
     return (-1);
   msg->%(name)s_set = 1;
   return (0);
-}""" % self.GetTranslation()
+}""" % (
+            self.GetTranslation()
+        )
 
-        return code.split('\n')
+        return code.split("\n")
 
-    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):
-        code = ['if (evtag_unmarshal_string(%(buf)s, %(tag)s, &%(var)s) == -1) {',
-                '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
-                '  return (-1);',
-                '}'
-                ]
-        code = '\n'.join(code) % self.GetTranslation({
-            'buf' : buf,
-            'tag' : tag_name,
-            'var' : var_name })
-        return code.split('\n')
-
-    def CodeMarshal(self, buf, tag_name, var_name, var_len):
-        code = ['evtag_marshal_string(%s, %s, %s);' % (
-            buf, tag_name, var_name)]
+    def CodeUnmarshal(self, buf, tag_name, var_name, _var_len):
+        code = [
+            "if (evtag_unmarshal_string(%(buf)s, %(tag)s, &%(var)s) == -1) {",
+            '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
+            "  return (-1);",
+            "}",
+        ]
+        code = "\n".join(code) % self.GetTranslation(
+            {"buf": buf, "tag": tag_name, "var": var_name}
+        )
+        return code.split("\n")
+
+    @staticmethod
+    def CodeMarshal(buf, tag_name, var_name, _var_len):
+        code = ["evtag_marshal_string(%s, %s, %s);" % (buf, tag_name, var_name)]
         return code
 
     def CodeClear(self, structname):
-        code = [ 'if (%s->%s_set == 1) {' % (structname, self.Name()),
-                 '  free(%s->%s_data);' % (structname, self.Name()),
-                 '  %s->%s_data = NULL;' % (structname, self.Name()),
-                 '  %s->%s_set = 0;' % (structname, self.Name()),
-                 '}'
-                 ]
+        code = [
+            "if (%s->%s_set == 1) {" % (structname, self.Name()),
+            "  free(%s->%s_data);" % (structname, self.Name()),
+            "  %s->%s_data = NULL;" % (structname, self.Name()),
+            "  %s->%s_set = 0;" % (structname, self.Name()),
+            "}",
+        ]
 
         return code
 
     def CodeInitialize(self, name):
-        code  = ['%s->%s_data = NULL;' % (name, self._name)]
+        code = ["%s->%s_data = NULL;" % (name, self._name)]
         return code
 
     def CodeFree(self, name):
-        code  = ['if (%s->%s_data != NULL)' % (name, self._name),
-                 '    free (%s->%s_data);' % (name, self._name)]
+        code = [
+            "if (%s->%s_data != NULL)" % (name, self._name),
+            "    free (%s->%s_data);" % (name, self._name),
+        ]
 
         return code
 
     def Declaration(self):
-        dcl  = ['char *%s_data;' % self._name]
+        dcl = ["char *%s_data;" % self._name]
 
         return dcl
 
+
 class EntryStruct(Entry):
-    def __init__(self, type, name, tag, refname):
+    def __init__(self, ent_type, name, tag, refname):
         # Init base class
-        Entry.__init__(self, type, name, tag)
+        super(EntryStruct, self).__init__(ent_type, name, tag)
 
         self._optpointer = False
-        self._can_be_array = 1
+        self._can_be_array = True
         self._refname = refname
-        self._ctype = 'struct %s*' % refname
+        self._ctype = "struct %s*" % refname
         self._optaddarg = False
 
     def GetInitializer(self):
         return "NULL"
 
-    def GetVarLen(self, var):
-        return '-1'
+    def GetVarLen(self, _var):
+        return "-1"
 
-    def CodeArrayAdd(self, varname, value):
+    def CodeArrayAdd(self, varname, _value):
         code = [
-            '%(varname)s = %(refname)s_new();',
-            'if (%(varname)s == NULL)',
-            '  goto error;' ]
+            "%(varname)s = %(refname)s_new();",
+            "if (%(varname)s == NULL)",
+            "  goto error;",
+        ]
 
-        return TranslateList(code, self.GetTranslation({ 'varname' : varname }))
+        return TranslateList(code, self.GetTranslation({"varname": varname}))
 
     def CodeArrayFree(self, var):
-        code = [ '%(refname)s_free(%(var)s);' % self.GetTranslation(
-            { 'var' : var }) ]
+        code = ["%(refname)s_free(%(var)s);" % self.GetTranslation({"var": var})]
         return code
 
     def CodeArrayAssign(self, var, srcvar):
         code = [
-            'int had_error = 0;',
-            'struct evbuffer *tmp = NULL;',
-            '%(refname)s_clear(%(var)s);',
-            'if ((tmp = evbuffer_new()) == NULL) {',
+            "int had_error = 0;",
+            "struct evbuffer *tmp = NULL;",
+            "%(refname)s_clear(%(var)s);",
+            "if ((tmp = evbuffer_new()) == NULL) {",
             '  event_warn("%%s: evbuffer_new()", __func__);',
-            '  had_error = 1;',
-            '  goto done;',
-            '}',
-            '%(refname)s_marshal(tmp, %(srcvar)s);',
-            'if (%(refname)s_unmarshal(%(var)s, tmp) == -1) {',
+            "  had_error = 1;",
+            "  goto done;",
+            "}",
+            "%(refname)s_marshal(tmp, %(srcvar)s);",
+            "if (%(refname)s_unmarshal(%(var)s, tmp) == -1) {",
             '  event_warnx("%%s: %(refname)s_unmarshal", __func__);',
-            '  had_error = 1;',
-            '  goto done;',
-            '}',
-            'done:'
-            'if (tmp != NULL)',
-            '  evbuffer_free(tmp);',
-            'if (had_error) {',
-            '  %(refname)s_clear(%(var)s);',
-            '  return (-1);',
-            '}' ]
-
-        return TranslateList(code, self.GetTranslation({
-            'var' : var,
-            'srcvar' : srcvar}))
+            "  had_error = 1;",
+            "  goto done;",
+            "}",
+            "done:",
+            "if (tmp != NULL)",
+            "  evbuffer_free(tmp);",
+            "if (had_error) {",
+            "  %(refname)s_clear(%(var)s);",
+            "  return (-1);",
+            "}",
+        ]
+
+        return TranslateList(code, self.GetTranslation({"var": var, "srcvar": srcvar}))
 
     def CodeGet(self):
         name = self._name
-        code = [ 'int',
-                 '%s_%s_get(struct %s *msg, %s *value)' % (
-            self._struct.Name(), name,
-            self._struct.Name(), self._ctype),
-                 '{',
-                 '  if (msg->%s_set != 1) {' % name,
-                 '    msg->%s_data = %s_new();' % (name, self._refname),
-                 '    if (msg->%s_data == NULL)' % name,
-                 '      return (-1);',
-                 '    msg->%s_set = 1;' % name,
-                 '  }',
-                 '  *value = msg->%s_data;' % name,
-                 '  return (0);',
-                 '}' ]
+        code = [
+            "int",
+            "%s_%s_get(struct %s *msg, %s *value)"
+            % (self._struct.Name(), name, self._struct.Name(), self._ctype),
+            "{",
+            "  if (msg->%s_set != 1) {" % name,
+            "    msg->%s_data = %s_new();" % (name, self._refname),
+            "    if (msg->%s_data == NULL)" % name,
+            "      return (-1);",
+            "    msg->%s_set = 1;" % name,
+            "  }",
+            "  *value = msg->%s_data;" % name,
+            "  return (0);",
+            "}",
+        ]
         return code
 
     def CodeAssign(self):
-        name = self._name
-        code = """int
+        code = (
+            """int
 %(parent_name)s_%(name)s_assign(struct %(parent_name)s *msg,
     const %(ctype)s value)
 {
@@ -878,186 +987,210 @@ class EntryStruct(Entry):
      msg->%(name)s_data = NULL;
    }
    return (-1);
-}""" % self.GetTranslation()
-        return code.split('\n')
+}"""
+            % self.GetTranslation()
+        )
+        return code.split("\n")
 
     def CodeComplete(self, structname, var_name):
-        code = [ 'if (%(structname)s->%(name)s_set && '
-                 '%(refname)s_complete(%(var)s) == -1)',
-                 '  return (-1);' ]
+        code = [
+            "if (%(structname)s->%(name)s_set && "
+            "%(refname)s_complete(%(var)s) == -1)",
+            "  return (-1);",
+        ]
 
-        return TranslateList(code, self.GetTranslation({
-            'structname' : structname,
-            'var' : var_name }))
+        return TranslateList(
+            code, self.GetTranslation({"structname": structname, "var": var_name})
+        )
 
-    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):
-        code = ['%(var)s = %(refname)s_new();',
-                'if (%(var)s == NULL)',
-                '  return (-1);',
-                'if (evtag_unmarshal_%(refname)s(%(buf)s, %(tag)s, '
-                '%(var)s) == -1) {',
-                  '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
-                '  return (-1);',
-                '}'
-                ]
-        code = '\n'.join(code) % self.GetTranslation({
-            'buf' : buf,
-            'tag' : tag_name,
-            'var' : var_name })
-        return code.split('\n')
-
-    def CodeMarshal(self, buf, tag_name, var_name, var_len):
-        code = ['evtag_marshal_%s(%s, %s, %s);' % (
-            self._refname, buf, tag_name, var_name)]
+    def CodeUnmarshal(self, buf, tag_name, var_name, _var_len):
+        code = [
+            "%(var)s = %(refname)s_new();",
+            "if (%(var)s == NULL)",
+            "  return (-1);",
+            "if (evtag_unmarshal_%(refname)s(%(buf)s, %(tag)s, ",
+            "    %(var)s) == -1) {",
+            '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
+            "  return (-1);",
+            "}",
+        ]
+        code = "\n".join(code) % self.GetTranslation(
+            {"buf": buf, "tag": tag_name, "var": var_name}
+        )
+        return code.split("\n")
+
+    def CodeMarshal(self, buf, tag_name, var_name, _var_len):
+        code = [
+            "evtag_marshal_%s(%s, %s, %s);" % (self._refname, buf, tag_name, var_name)
+        ]
         return code
 
     def CodeClear(self, structname):
-        code = [ 'if (%s->%s_set == 1) {' % (structname, self.Name()),
-                 '  %s_free(%s->%s_data);' % (
-            self._refname, structname, self.Name()),
-                 '  %s->%s_data = NULL;' % (structname, self.Name()),
-                 '  %s->%s_set = 0;' % (structname, self.Name()),
-                 '}'
-                 ]
+        code = [
+            "if (%s->%s_set == 1) {" % (structname, self.Name()),
+            "  %s_free(%s->%s_data);" % (self._refname, structname, self.Name()),
+            "  %s->%s_data = NULL;" % (structname, self.Name()),
+            "  %s->%s_set = 0;" % (structname, self.Name()),
+            "}",
+        ]
 
         return code
 
     def CodeInitialize(self, name):
-        code  = ['%s->%s_data = NULL;' % (name, self._name)]
+        code = ["%s->%s_data = NULL;" % (name, self._name)]
         return code
 
     def CodeFree(self, name):
-        code  = ['if (%s->%s_data != NULL)' % (name, self._name),
-                 '    %s_free(%s->%s_data);' % (
-            self._refname, name, self._name)]
+        code = [
+            "if (%s->%s_data != NULL)" % (name, self._name),
+            "    %s_free(%s->%s_data);" % (self._refname, name, self._name),
+        ]
 
         return code
 
     def Declaration(self):
-        dcl  = ['%s %s_data;' % (self._ctype, self._name)]
+        dcl = ["%s %s_data;" % (self._ctype, self._name)]
 
         return dcl
 
+
 class EntryVarBytes(Entry):
-    def __init__(self, type, name, tag):
+    def __init__(self, ent_type, name, tag):
         # Init base class
-        Entry.__init__(self, type, name, tag)
+        super(EntryVarBytes, self).__init__(ent_type, name, tag)
 
-        self._ctype = 'ev_uint8_t *'
+        self._ctype = "ev_uint8_t *"
 
-    def GetInitializer(self):
+    @staticmethod
+    def GetInitializer():
         return "NULL"
 
     def GetVarLen(self, var):
-        return '%(var)s->%(name)s_length' % self.GetTranslation({ 'var' : var })
+        return "%(var)s->%(name)s_length" % self.GetTranslation({"var": var})
 
-    def CodeArrayAdd(self, varname, value):
+    @staticmethod
+    def CodeArrayAdd(varname, _value):
         # xxx: copy
-        return [ '%(varname)s = NULL;' % { 'varname' : varname } ]
+        return ["%(varname)s = NULL;" % {"varname": varname}]
 
     def GetDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, %s *, ev_uint32_t *);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, %s *, ev_uint32_t *);"
+            % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def AssignDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, const %s, ev_uint32_t);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, const %s, ev_uint32_t);"
+            % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def CodeAssign(self):
         name = self._name
-        code = [ 'int',
-                 '%s_%s_assign(struct %s *msg, '
-                 'const %s value, ev_uint32_t len)' % (
-            self._struct.Name(), name,
-            self._struct.Name(), self._ctype),
-                 '{',
-                 '  if (msg->%s_data != NULL)' % name,
-                 '    free (msg->%s_data);' % name,
-                 '  msg->%s_data = malloc(len);' % name,
-                 '  if (msg->%s_data == NULL)' % name,
-                 '    return (-1);',
-                 '  msg->%s_set = 1;' % name,
-                 '  msg->%s_length = len;' % name,
-                 '  memcpy(msg->%s_data, value, len);' % name,
-                 '  return (0);',
-                 '}' ]
+        code = [
+            "int",
+            "%s_%s_assign(struct %s *msg, "
+            "const %s value, ev_uint32_t len)"
+            % (self._struct.Name(), name, self._struct.Name(), self._ctype),
+            "{",
+            "  if (msg->%s_data != NULL)" % name,
+            "    free (msg->%s_data);" % name,
+            "  msg->%s_data = malloc(len);" % name,
+            "  if (msg->%s_data == NULL)" % name,
+            "    return (-1);",
+            "  msg->%s_set = 1;" % name,
+            "  msg->%s_length = len;" % name,
+            "  memcpy(msg->%s_data, value, len);" % name,
+            "  return (0);",
+            "}",
+        ]
         return code
 
     def CodeGet(self):
         name = self._name
-        code = [ 'int',
-                 '%s_%s_get(struct %s *msg, %s *value, ev_uint32_t *plen)' % (
-            self._struct.Name(), name,
-            self._struct.Name(), self._ctype),
-                 '{',
-                 '  if (msg->%s_set != 1)' % name,
-                 '    return (-1);',
-                 '  *value = msg->%s_data;' % name,
-                 '  *plen = msg->%s_length;' % name,
-                 '  return (0);',
-                 '}' ]
+        code = [
+            "int",
+            "%s_%s_get(struct %s *msg, %s *value, ev_uint32_t *plen)"
+            % (self._struct.Name(), name, self._struct.Name(), self._ctype),
+            "{",
+            "  if (msg->%s_set != 1)" % name,
+            "    return (-1);",
+            "  *value = msg->%s_data;" % name,
+            "  *plen = msg->%s_length;" % name,
+            "  return (0);",
+            "}",
+        ]
         return code
 
     def CodeUnmarshal(self, buf, tag_name, var_name, var_len):
-        code = ['if (evtag_payload_length(%(buf)s, &%(varlen)s) == -1)',
-                '  return (-1);',
-                # We do not want DoS opportunities
-                'if (%(varlen)s > evbuffer_get_length(%(buf)s))',
-                '  return (-1);',
-                'if ((%(var)s = malloc(%(varlen)s)) == NULL)',
-                '  return (-1);',
-                'if (evtag_unmarshal_fixed(%(buf)s, %(tag)s, %(var)s, '
-                '%(varlen)s) == -1) {',
-                '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
-                '  return (-1);',
-                '}'
-                ]
-        code = '\n'.join(code) % self.GetTranslation({
-            'buf' : buf,
-            'tag' : tag_name,
-            'var' : var_name,
-            'varlen' : var_len })
-        return code.split('\n')
-
-    def CodeMarshal(self, buf, tag_name, var_name, var_len):
-        code = ['evtag_marshal(%s, %s, %s, %s);' % (
-            buf, tag_name, var_name, var_len)]
+        code = [
+            "if (evtag_payload_length(%(buf)s, &%(varlen)s) == -1)",
+            "  return (-1);",
+            # We do not want DoS opportunities
+            "if (%(varlen)s > evbuffer_get_length(%(buf)s))",
+            "  return (-1);",
+            "if ((%(var)s = malloc(%(varlen)s)) == NULL)",
+            "  return (-1);",
+            "if (evtag_unmarshal_fixed(%(buf)s, %(tag)s, %(var)s, "
+            "%(varlen)s) == -1) {",
+            '  event_warnx("%%s: failed to unmarshal %(name)s", __func__);',
+            "  return (-1);",
+            "}",
+        ]
+        code = "\n".join(code) % self.GetTranslation(
+            {"buf": buf, "tag": tag_name, "var": var_name, "varlen": var_len}
+        )
+        return code.split("\n")
+
+    @staticmethod
+    def CodeMarshal(buf, tag_name, var_name, var_len):
+        code = ["evtag_marshal(%s, %s, %s, %s);" % (buf, tag_name, var_name, var_len)]
         return code
 
     def CodeClear(self, structname):
-        code = [ 'if (%s->%s_set == 1) {' % (structname, self.Name()),
-                 '  free (%s->%s_data);' % (structname, self.Name()),
-                 '  %s->%s_data = NULL;' % (structname, self.Name()),
-                 '  %s->%s_length = 0;' % (structname, self.Name()),
-                 '  %s->%s_set = 0;' % (structname, self.Name()),
-                 '}'
-                 ]
+        code = [
+            "if (%s->%s_set == 1) {" % (structname, self.Name()),
+            "  free (%s->%s_data);" % (structname, self.Name()),
+            "  %s->%s_data = NULL;" % (structname, self.Name()),
+            "  %s->%s_length = 0;" % (structname, self.Name()),
+            "  %s->%s_set = 0;" % (structname, self.Name()),
+            "}",
+        ]
 
         return code
 
     def CodeInitialize(self, name):
-        code  = ['%s->%s_data = NULL;' % (name, self._name),
-                 '%s->%s_length = 0;' % (name, self._name) ]
+        code = [
+            "%s->%s_data = NULL;" % (name, self._name),
+            "%s->%s_length = 0;" % (name, self._name),
+        ]
         return code
 
     def CodeFree(self, name):
-        code  = ['if (%s->%s_data != NULL)' % (name, self._name),
-                 '    free(%s->%s_data);' % (name, self._name)]
+        code = [
+            "if (%s->%s_data != NULL)" % (name, self._name),
+            "    free(%s->%s_data);" % (name, self._name),
+        ]
 
         return code
 
     def Declaration(self):
-        dcl  = ['ev_uint8_t *%s_data;' % self._name,
-                'ev_uint32_t %s_length;' % self._name]
+        dcl = [
+            "ev_uint8_t *%s_data;" % self._name,
+            "ev_uint32_t %s_length;" % self._name,
+        ]
 
         return dcl
 
+
 class EntryArray(Entry):
+    _index = None
+
     def __init__(self, entry):
         # Init base class
-        Entry.__init__(self, entry._type, entry._name, entry._tag)
+        super(EntryArray, self).__init__(entry._type, entry._name, entry._tag)
 
         self._entry = entry
         self._refname = entry._refname
@@ -1068,37 +1201,42 @@ class EntryArray(Entry):
 
         # provide a new function for accessing the variable name
         def GetVarName(var_name):
-            return '%(var)s->%(name)s_data[%(index)s]' % \
-                   self._entry.GetTranslation({'var' : var_name,
-                                               'index' : self._index})
+            return "%(var)s->%(name)s_data[%(index)s]" % self._entry.GetTranslation(
+                {"var": var_name, "index": self._index}
+            )
+
         self._entry.GetVarName = GetVarName
 
     def GetInitializer(self):
         return "NULL"
 
-    def GetVarName(self, var_name):
-        return var_name
+    def GetVarName(self, var):
+        return var
 
-    def GetVarLen(self, var_name):
-        return '-1'
+    def GetVarLen(self, _var_name):
+        return "-1"
 
     def GetDeclaration(self, funcname):
         """Allows direct access to elements of the array."""
         code = [
-            'int %(funcname)s(struct %(parent_name)s *, int, %(ctype)s *);' %
-            self.GetTranslation({ 'funcname' : funcname }) ]
+            "int %(funcname)s(struct %(parent_name)s *, int, %(ctype)s *);"
+            % self.GetTranslation({"funcname": funcname})
+        ]
         return code
 
     def AssignDeclaration(self, funcname):
-        code = [ 'int %s(struct %s *, int, const %s);' % (
-            funcname, self._struct.Name(), self._ctype ) ]
+        code = [
+            "int %s(struct %s *, int, const %s);"
+            % (funcname, self._struct.Name(), self._ctype)
+        ]
         return code
 
     def AddDeclaration(self, funcname):
         code = [
-            '%(ctype)s %(optpointer)s '
-            '%(funcname)s(struct %(parent_name)s *msg%(optaddarg)s);' % \
-            self.GetTranslation({ 'funcname' : funcname }) ]
+            "%(ctype)s %(optpointer)s "
+            "%(funcname)s(struct %(parent_name)s *msg%(optaddarg)s);"
+            % self.GetTranslation({"funcname": funcname})
+        ]
         return code
 
     def CodeGet(self):
@@ -1110,226 +1248,249 @@ class EntryArray(Entry):
     return (-1);
   *value = msg->%(name)s_data[offset];
   return (0);
-}""" % self.GetTranslation()
+}
+""" % (
+            self.GetTranslation()
+        )
 
-        return code.split('\n')
+        return code.splitlines()
 
     def CodeAssign(self):
         code = [
-            'int',
-            '%(parent_name)s_%(name)s_assign(struct %(parent_name)s *msg, int off,',
-            '    const %(ctype)s value)',
-            '{',
-            '  if (!msg->%(name)s_set || off < 0 || off >= msg->%(name)s_length)',
-            '    return (-1);\n',
-            '  {' ]
+            "int",
+            "%(parent_name)s_%(name)s_assign(struct %(parent_name)s *msg, int off,",
+            "  const %(ctype)s value)",
+            "{",
+            "  if (!msg->%(name)s_set || off < 0 || off >= msg->%(name)s_length)",
+            "    return (-1);",
+            "",
+            "  {",
+        ]
         code = TranslateList(code, self.GetTranslation())
 
         codearrayassign = self._entry.CodeArrayAssign(
-            'msg->%(name)s_data[off]' % self.GetTranslation(), 'value')
-        code += map(lambda x: '    ' + x, codearrayassign)
+            "msg->%(name)s_data[off]" % self.GetTranslation(), "value"
+        )
+        code += ["    " + x for x in codearrayassign]
 
-        code += TranslateList([
-            '  }',
-            '  return (0);',
-            '}' ], self.GetTranslation())
+        code += TranslateList(["  }", "  return (0);", "}"], self.GetTranslation())
 
         return code
 
     def CodeAdd(self):
         codearrayadd = self._entry.CodeArrayAdd(
-            'msg->%(name)s_data[msg->%(name)s_length - 1]' % self.GetTranslation(),
-            'value')
+            "msg->%(name)s_data[msg->%(name)s_length - 1]" % self.GetTranslation(),
+            "value",
+        )
         code = [
-            'static int',
-            '%(parent_name)s_%(name)s_expand_to_hold_more('
-            'struct %(parent_name)s *msg)',
-            '{',
-            '  int tobe_allocated = msg->%(name)s_num_allocated;',
-            '  %(ctype)s* new_data = NULL;',
-            '  tobe_allocated = !tobe_allocated ? 1 : tobe_allocated << 1;',
-            '  new_data = (%(ctype)s*) realloc(msg->%(name)s_data,',
-            '      tobe_allocated * sizeof(%(ctype)s));',
-            '  if (new_data == NULL)',
-            '    return -1;',
-            '  msg->%(name)s_data = new_data;',
-            '  msg->%(name)s_num_allocated = tobe_allocated;',
-            '  return 0;'
-            '}',
-            '',
-            '%(ctype)s %(optpointer)s',
-            '%(parent_name)s_%(name)s_add('
-            'struct %(parent_name)s *msg%(optaddarg)s)',
-            '{',
-            '  if (++msg->%(name)s_length >= msg->%(name)s_num_allocated) {',
-            '    if (%(parent_name)s_%(name)s_expand_to_hold_more(msg)<0)',
-            '      goto error;',
-            '  }' ]
+            "static int",
+            "%(parent_name)s_%(name)s_expand_to_hold_more("
+            "struct %(parent_name)s *msg)",
+            "{",
+            "  int tobe_allocated = msg->%(name)s_num_allocated;",
+            "  %(ctype)s* new_data = NULL;",
+            "  tobe_allocated = !tobe_allocated ? 1 : tobe_allocated << 1;",
+            "  new_data = (%(ctype)s*) realloc(msg->%(name)s_data,",
+            "      tobe_allocated * sizeof(%(ctype)s));",
+            "  if (new_data == NULL)",
+            "    return -1;",
+            "  msg->%(name)s_data = new_data;",
+            "  msg->%(name)s_num_allocated = tobe_allocated;",
+            "  return 0;",
+            "}",
+            "",
+            "%(ctype)s %(optpointer)s",
+            "%(parent_name)s_%(name)s_add(struct %(parent_name)s *msg%(optaddarg)s)",
+            "{",
+            "  if (++msg->%(name)s_length >= msg->%(name)s_num_allocated) {",
+            "    if (%(parent_name)s_%(name)s_expand_to_hold_more(msg)<0)",
+            "      goto error;",
+            "  }",
+        ]
 
         code = TranslateList(code, self.GetTranslation())
 
-        code += map(lambda x: '  ' + x, codearrayadd)
-
-        code += TranslateList([
-            '  msg->%(name)s_set = 1;',
-            '  return %(optreference)s(msg->%(name)s_data['
-            'msg->%(name)s_length - 1]);',
-            'error:',
-            '  --msg->%(name)s_length;',
-            '  return (NULL);',
-            '}' ], self.GetTranslation())
+        code += ["  " + x for x in codearrayadd]
+
+        code += TranslateList(
+            [
+                "  msg->%(name)s_set = 1;",
+                "  return %(optreference)s(msg->%(name)s_data["
+                "msg->%(name)s_length - 1]);",
+                "error:",
+                "  --msg->%(name)s_length;",
+                "  return (NULL);",
+                "}",
+            ],
+            self.GetTranslation(),
+        )
 
         return code
 
     def CodeComplete(self, structname, var_name):
-        self._index = 'i'
+        self._index = "i"
         tmp = self._entry.CodeComplete(structname, self._entry.GetVarName(var_name))
         # skip the whole loop if there is nothing to check
         if not tmp:
             return []
 
-        translate = self.GetTranslation({ 'structname' : structname })
+        translate = self.GetTranslation({"structname": structname})
         code = [
-            '{',
-            '  int i;',
-            '  for (i = 0; i < %(structname)s->%(name)s_length; ++i) {' ]
+            "{",
+            "  int i;",
+            "  for (i = 0; i < %(structname)s->%(name)s_length; ++i) {",
+        ]
 
         code = TranslateList(code, translate)
 
-        code += map(lambda x: '    ' + x, tmp)
+        code += ["    " + x for x in tmp]
 
-        code += [
-            '  }',
-            '}' ]
+        code += ["  }", "}"]
 
         return code
 
-    def CodeUnmarshal(self, buf, tag_name, var_name, var_len):
-        translate = self.GetTranslation({ 'var' : var_name,
-                                          'buf' : buf,
-                                          'tag' : tag_name,
-                                          'init' : self._entry.GetInitializer()})
+    def CodeUnmarshal(self, buf, tag_name, var_name, _var_len):
+        translate = self.GetTranslation(
+            {
+                "var": var_name,
+                "buf": buf,
+                "tag": tag_name,
+                "init": self._entry.GetInitializer(),
+            }
+        )
         code = [
-            'if (%(var)s->%(name)s_length >= %(var)s->%(name)s_num_allocated &&',
-            '    %(parent_name)s_%(name)s_expand_to_hold_more(%(var)s) < 0) {',
+            "if (%(var)s->%(name)s_length >= %(var)s->%(name)s_num_allocated &&",
+            "    %(parent_name)s_%(name)s_expand_to_hold_more(%(var)s) < 0) {",
             '  puts("HEY NOW");',
-            '  return (-1);',
-            '}']
+            "  return (-1);",
+            "}",
+        ]
 
         # the unmarshal code directly returns
         code = TranslateList(code, translate)
 
-        self._index = '%(var)s->%(name)s_length' % translate
-        code += self._entry.CodeUnmarshal(buf, tag_name,
-                                        self._entry.GetVarName(var_name),
-                                        self._entry.GetVarLen(var_name))
+        self._index = "%(var)s->%(name)s_length" % translate
+        code += self._entry.CodeUnmarshal(
+            buf,
+            tag_name,
+            self._entry.GetVarName(var_name),
+            self._entry.GetVarLen(var_name),
+        )
 
-        code += [ '++%(var)s->%(name)s_length;' % translate ]
+        code += ["++%(var)s->%(name)s_length;" % translate]
 
         return code
 
-    def CodeMarshal(self, buf, tag_name, var_name, var_len):
-        code = ['{',
-                '  int i;',
-                '  for (i = 0; i < %(var)s->%(name)s_length; ++i) {' ]
+    def CodeMarshal(self, buf, tag_name, var_name, _var_len):
+        code = ["{", "  int i;", "  for (i = 0; i < %(var)s->%(name)s_length; ++i) {"]
 
-        self._index = 'i'
-        code += self._entry.CodeMarshal(buf, tag_name,
-                                        self._entry.GetVarName(var_name),
-                                        self._entry.GetVarLen(var_name))
-        code += ['  }',
-                 '}'
-                 ]
+        self._index = "i"
+        code += self._entry.CodeMarshal(
+            buf,
+            tag_name,
+            self._entry.GetVarName(var_name),
+            self._entry.GetVarLen(var_name),
+        )
+        code += ["  }", "}"]
 
-        code = "\n".join(code) % self.GetTranslation({ 'var' : var_name })
+        code = "\n".join(code) % self.GetTranslation({"var": var_name})
 
-        return code.split('\n')
+        return code.split("\n")
 
     def CodeClear(self, structname):
-        translate = self.GetTranslation({ 'structname' : structname })
+        translate = self.GetTranslation({"structname": structname})
         codearrayfree = self._entry.CodeArrayFree(
-            '%(structname)s->%(name)s_data[i]' % self.GetTranslation(
-            { 'structname' : structname } ))
+            "%(structname)s->%(name)s_data[i]"
+            % self.GetTranslation({"structname": structname})
+        )
 
-        code = [ 'if (%(structname)s->%(name)s_set == 1) {' ]
+        code = ["if (%(structname)s->%(name)s_set == 1) {"]
 
         if codearrayfree:
             code += [
-                '  int i;',
-                '  for (i = 0; i < %(structname)s->%(name)s_length; ++i) {' ]
+                "  int i;",
+                "  for (i = 0; i < %(structname)s->%(name)s_length; ++i) {",
+            ]
 
         code = TranslateList(code, translate)
 
         if codearrayfree:
-            code += map(lambda x: '    ' + x, codearrayfree)
-            code += [
-                '  }' ]
-
-        code += TranslateList([
-                 '  free(%(structname)s->%(name)s_data);',
-                 '  %(structname)s->%(name)s_data = NULL;',
-                 '  %(structname)s->%(name)s_set = 0;',
-                 '  %(structname)s->%(name)s_length = 0;',
-                 '  %(structname)s->%(name)s_num_allocated = 0;',
-                 '}'
-                 ], translate)
+            code += ["    " + x for x in codearrayfree]
+            code += ["  }"]
+
+        code += TranslateList(
+            [
+                "  free(%(structname)s->%(name)s_data);",
+                "  %(structname)s->%(name)s_data = NULL;",
+                "  %(structname)s->%(name)s_set = 0;",
+                "  %(structname)s->%(name)s_length = 0;",
+                "  %(structname)s->%(name)s_num_allocated = 0;",
+                "}",
+            ],
+            translate,
+        )
 
         return code
 
     def CodeInitialize(self, name):
-        code  = ['%s->%s_data = NULL;' % (name, self._name),
-                 '%s->%s_length = 0;' % (name, self._name),
-                 '%s->%s_num_allocated = 0;' % (name, self._name)]
+        code = [
+            "%s->%s_data = NULL;" % (name, self._name),
+            "%s->%s_length = 0;" % (name, self._name),
+            "%s->%s_num_allocated = 0;" % (name, self._name),
+        ]
         return code
 
     def CodeFree(self, structname):
-        code = self.CodeClear(structname);
+        code = self.CodeClear(structname)
 
-        code += TranslateList([
-            'free(%(structname)s->%(name)s_data);' ],
-                              self.GetTranslation({'structname' : structname }))
+        code += TranslateList(
+            ["free(%(structname)s->%(name)s_data);"],
+            self.GetTranslation({"structname": structname}),
+        )
 
         return code
 
     def Declaration(self):
-        dcl  = ['%s *%s_data;' % (self._ctype, self._name),
-                'int %s_length;' % self._name,
-                'int %s_num_allocated;' % self._name ]
+        dcl = [
+            "%s *%s_data;" % (self._ctype, self._name),
+            "int %s_length;" % self._name,
+            "int %s_num_allocated;" % self._name,
+        ]
 
         return dcl
 
+
 def NormalizeLine(line):
-    global white
-    global cppcomment
 
-    line = cppcomment.sub('', line)
+    line = CPPCOMMENT_RE.sub("", line)
     line = line.strip()
-    line = white.sub(' ', line)
+    line = WHITESPACE_RE.sub(" ", line)
 
     return line
 
+
+ENTRY_NAME_RE = re.compile(r"(?P<name>[^\[\]]+)(\[(?P<fixed_length>.*)\])?")
+ENTRY_TAG_NUMBER_RE = re.compile(r"(0x)?\d+", re.I)
+
+
 def ProcessOneEntry(factory, newstruct, entry):
-    optional = 0
-    array = 0
-    entry_type = ''
-    name = ''
-    tag = ''
+    optional = False
+    array = False
+    entry_type = ""
+    name = ""
+    tag = ""
     tag_set = None
-    separator = ''
-    fixed_length = ''
-
-    tokens = entry.split(' ')
-    while tokens:
-        token = tokens[0]
-        tokens = tokens[1:]
+    separator = ""
+    fixed_length = ""
 
+    for token in entry.split(" "):
         if not entry_type:
-            if not optional and token == 'optional':
-                optional = 1
+            if not optional and token == "optional":
+                optional = True
                 continue
 
-            if not array and token == 'array':
-                array = 1
+            if not array and token == "array":
+                array = True
                 continue
 
         if not entry_type:
@@ -1337,53 +1498,52 @@ def ProcessOneEntry(factory, newstruct, entry):
             continue
 
         if not name:
-            res = re.match(r'^([^\[\]]+)(\[.*\])?$', token)
+            res = ENTRY_NAME_RE.match(token)
             if not res:
-                 raise RpcGenError(
-                     'Cannot parse name: \"%s\" '
-                     'around line %d' % (entry, line_count))
-            name = res.group(1)
-            fixed_length = res.group(2)
-            if fixed_length:
-                fixed_length = fixed_length[1:-1]
+                raise RpcGenError(
+                    r"""Cannot parse name: "%s" around line %d""" % (entry, LINE_COUNT)
+                )
+            name = res.group("name")
+            fixed_length = res.group("fixed_length")
             continue
 
         if not separator:
             separator = token
-            if separator != '=':
-                 raise RpcGenError('Expected "=" after name \"%s\" got %s'
-                                   % (name, token))
+            if separator != "=":
+                raise RpcGenError(
+                    r'''Expected "=" after name "%s" got "%s"''' % (name, token)
+                )
             continue
 
         if not tag_set:
             tag_set = 1
-            if not re.match(r'^(0x)?[0-9]+$', token):
-                raise RpcGenError('Expected tag number: \"%s\"' % entry)
+            if not ENTRY_TAG_NUMBER_RE.match(token):
+                raise RpcGenError(r'''Expected tag number: "%s"''' % (entry))
             tag = int(token, 0)
             continue
 
-        raise RpcGenError('Cannot parse \"%s\"' % entry)
+        raise RpcGenError(r'''Cannot parse "%s"''' % (entry))
 
     if not tag_set:
-        raise RpcGenError('Need tag number: \"%s\"' % entry)
+        raise RpcGenError(r'''Need tag number: "%s"''' % (entry))
 
     # Create the right entry
-    if entry_type == 'bytes':
+    if entry_type == "bytes":
         if fixed_length:
             newentry = factory.EntryBytes(entry_type, name, tag, fixed_length)
         else:
             newentry = factory.EntryVarBytes(entry_type, name, tag)
-    elif entry_type == 'int' and not fixed_length:
+    elif entry_type == "int" and not fixed_length:
         newentry = factory.EntryInt(entry_type, name, tag)
-    elif entry_type == 'int64' and not fixed_length:
+    elif entry_type == "int64" and not fixed_length:
         newentry = factory.EntryInt(entry_type, name, tag, bits=64)
-    elif entry_type == 'string' and not fixed_length:
+    elif entry_type == "string" and not fixed_length:
         newentry = factory.EntryString(entry_type, name, tag)
     else:
-        res = structref.match(entry_type)
+        res = STRUCT_REF_RE.match(entry_type)
         if res:
             # References another struct defined in our file
-            newentry = factory.EntryStruct(entry_type, name, tag, res.group(1))
+            newentry = factory.EntryStruct(entry_type, name, tag, res.group("name"))
         else:
             raise RpcGenError('Bad type: "%s" in "%s"' % (entry_type, entry))
 
@@ -1395,32 +1555,30 @@ def ProcessOneEntry(factory, newstruct, entry):
         newentry.MakeArray()
 
     newentry.SetStruct(newstruct)
-    newentry.SetLineCount(line_count)
+    newentry.SetLineCount(LINE_COUNT)
     newentry.Verify()
 
     if array:
         # We need to encapsulate this entry into a struct
-        newname = newentry.Name()+ '_array'
-
-        # Now borgify the new entry.
         newentry = factory.EntryArray(newentry)
         newentry.SetStruct(newstruct)
-        newentry.SetLineCount(line_count)
+        newentry.SetLineCount(LINE_COUNT)
         newentry.MakeArray()
 
     newstruct.AddEntry(newentry)
 
     return structs
 
+
 def ProcessStruct(factory, data):
-    tokens = data.split(' ')
+    tokens = data.split(" ")
 
     # First three tokens are: 'struct' 'name' '{'
     newstruct = factory.Struct(tokens[1])
 
-    inside = ' '.join(tokens[3:-1])
+    inside = " ".join(tokens[3:-1])
 
-    tokens = inside.split(';')
+    tokens = inside.split(";")
 
     structs = []
 
@@ -1435,36 +1593,52 @@ def ProcessStruct(factory, data):
     structs.append(newstruct)
     return structs
 
-def GetNextStruct(file):
-    global line_count
-    global cppdirect
 
-    got_struct = 0
+C_COMMENT_START = "/*"
+C_COMMENT_END = "*/"
 
-    processed_lines = []
+C_COMMENT_START_RE = re.compile(re.escape(C_COMMENT_START))
+C_COMMENT_END_RE = re.compile(re.escape(C_COMMENT_END))
 
-    have_c_comment = 0
-    data = ''
-    while 1:
-        line = file.readline()
+C_COMMENT_START_SUB_RE = re.compile(r"%s.*$" % (re.escape(C_COMMENT_START)))
+C_COMMENT_END_SUB_RE = re.compile(r"%s.*$" % (re.escape(C_COMMENT_END)))
+
+C_MULTILINE_COMMENT_SUB_RE = re.compile(
+    r"%s.*?%s" % (re.escape(C_COMMENT_START), re.escape(C_COMMENT_END))
+)
+CPP_CONDITIONAL_BLOCK_RE = re.compile(r"#(if( |def)|endif)")
+INCLUDE_RE = re.compile(r'#include (".+"|<.+>)')
+
+
+def GetNextStruct(filep):
+    global CPP_DIRECT
+    global LINE_COUNT
+
+    got_struct = False
+    have_c_comment = False
+
+    data = ""
+
+    while True:
+        line = filep.readline()
         if not line:
             break
 
-        line_count += 1
+        LINE_COUNT += 1
         line = line[:-1]
 
-        if not have_c_comment and re.search(r'/\*', line):
-            if re.search(r'/\*.*?\*/', line):
-                line = re.sub(r'/\*.*?\*/', '', line)
+        if not have_c_comment and C_COMMENT_START_RE.search(line):
+            if C_MULTILINE_COMMENT_SUB_RE.search(line):
+                line = C_MULTILINE_COMMENT_SUB_RE.sub("", line)
             else:
-                line = re.sub(r'/\*.*$', '', line)
-                have_c_comment = 1
+                line = C_COMMENT_START_SUB_RE.sub("", line)
+                have_c_comment = True
 
         if have_c_comment:
-            if not re.search(r'\*/', line):
+            if not C_COMMENT_END_RE.search(line):
                 continue
-            have_c_comment = 0
-            line = re.sub(r'^.*\*/', '', line)
+            have_c_comment = False
+            line = C_COMMENT_END_SUB_RE.sub("", line)
 
         line = NormalizeLine(line)
 
@@ -1472,47 +1646,39 @@ def GetNextStruct(file):
             continue
 
         if not got_struct:
-            if re.match(r'#include ["<].*[>"]', line):
-                cppdirect.append(line)
-                continue
-
-            if re.match(r'^#(if( |def)|endif)', line):
-                cppdirect.append(line)
-                continue
-
-            if re.match(r'^#define', line):
-                headerdirect.append(line)
-                continue
-
-            if not structdef.match(line):
-                raise RpcGenError('Missing struct on line %d: %s'
-                                  % (line_count, line))
+            if INCLUDE_RE.match(line):
+                CPP_DIRECT.append(line)
+            elif CPP_CONDITIONAL_BLOCK_RE.match(line):
+                CPP_DIRECT.append(line)
+            elif PREPROCESSOR_DEF_RE.match(line):
+                HEADER_DIRECT.append(line)
+            elif not STRUCT_DEF_RE.match(line):
+                raise RpcGenError("Missing struct on line %d: %s" % (LINE_COUNT, line))
             else:
-                got_struct = 1
+                got_struct = True
                 data += line
             continue
 
         # We are inside the struct
-        tokens = line.split('}')
+        tokens = line.split("}")
         if len(tokens) == 1:
-            data += ' ' + line
+            data += " " + line
             continue
 
-        if len(tokens[1]):
-            raise RpcGenError('Trailing garbage after struct on line %d'
-                              % line_count)
+        if tokens[1]:
+            raise RpcGenError("Trailing garbage after struct on line %d" % LINE_COUNT)
 
         # We found the end of the struct
-        data += ' %s}' % tokens[0]
+        data += " %s}" % tokens[0]
         break
 
     # Remove any comments, that might be in there
-    data = re.sub(r'/\*.*\*/', '', data)
+    data = re.sub(r"/\*.*\*/", "", data)
 
     return data
 
 
-def Parse(factory, file):
+def Parse(factory, filep):
     """
     Parses the input file and returns C code and corresponding header file.
     """
@@ -1521,7 +1687,7 @@ def Parse(factory, file):
 
     while 1:
         # Just gets the whole struct nicely formatted
-        data = GetNextStruct(file)
+        data = GetNextStruct(filep)
 
         if not data:
             break
@@ -1530,199 +1696,230 @@ def Parse(factory, file):
 
     return entities
 
-class CCodeGenerator:
+
+class CCodeGenerator(object):
     def __init__(self):
         pass
 
-    def GuardName(self, name):
+    @staticmethod
+    def GuardName(name):
         # Use the complete provided path to the input file, with all
         # non-identifier characters replaced with underscores, to
         # reduce the chance of a collision between guard macros.
-        return 'EVENT_RPCOUT_' + nonident.sub('_', name).upper() + '_'
+        return "EVENT_RPCOUT_%s_" % (NONIDENT_RE.sub("_", name).upper())
 
     def HeaderPreamble(self, name):
         guard = self.GuardName(name)
-        pre = (
-            '/*\n'
-            ' * Automatically generated from %s\n'
-            ' */\n\n'
-            '#ifndef %s\n'
-            '#define %s\n\n' ) % (
-            name, guard, guard)
-
-        for statement in headerdirect:
-            pre += '%s\n' % statement
-        if headerdirect:
-            pre += '\n'
-
-        pre += (
-            '#include <event2/util.h> /* for ev_uint*_t */\n'
-            '#include <event2/rpc.h>\n'
+        pre = """
+/*
+ * Automatically generated from %s
+ */
+
+#ifndef %s
+#define %s
+
+""" % (
+            name,
+            guard,
+            guard,
         )
 
+        if HEADER_DIRECT:
+            for statement in HEADER_DIRECT:
+                pre += "%s\n" % statement
+            pre += "\n"
+
+        pre += """
+#include <event2/util.h> /* for ev_uint*_t */
+#include <event2/rpc.h>
+"""
+
         return pre
 
     def HeaderPostamble(self, name):
         guard = self.GuardName(name)
-        return '#endif  /* %s */' % guard
+        return "#endif  /* %s */" % (guard)
 
-    def BodyPreamble(self, name, header_file):
+    @staticmethod
+    def BodyPreamble(name, header_file):
         global _NAME
         global _VERSION
 
-        slash = header_file.rfind('/')
+        slash = header_file.rfind("/")
         if slash != -1:
-            header_file = header_file[slash+1:]
-
-        pre = ( '/*\n'
-                ' * Automatically generated from %s\n'
-                ' * by %s/%s.  DO NOT EDIT THIS FILE.\n'
-                ' */\n\n' ) % (name, _NAME, _VERSION)
-        pre += ( '#include <stdlib.h>\n'
-                 '#include <string.h>\n'
-                 '#include <assert.h>\n'
-                 '#include <event2/event-config.h>\n'
-                 '#include <event2/event.h>\n'
-                 '#include <event2/buffer.h>\n'
-                 '#include <event2/tag.h>\n\n'
-                 '#if defined(EVENT____func__) && !defined(__func__)\n'
-                 '#define __func__ EVENT____func__\n'
-                 '#endif\n\n'
-                 )
-
-        for statement in cppdirect:
-            pre += '%s\n' % statement
+            header_file = header_file[slash + 1 :]
+
+        pre = """
+/*
+ * Automatically generated from %(name)s
+ * by %(script_name)s/%(script_version)s.  DO NOT EDIT THIS FILE.
+ */
+
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <event2/event-config.h>
+#include <event2/event.h>
+#include <event2/buffer.h>
+#include <event2/tag.h>
+
+#if defined(EVENT__HAVE___func__)
+# ifndef __func__
+#  define __func__ __func__
+# endif
+#elif defined(EVENT__HAVE___FUNCTION__)
+# define __func__ __FUNCTION__
+#else
+# define __func__ __FILE__
+#endif
+
+""" % {
+            "name": name,
+            "script_name": _NAME,
+            "script_version": _VERSION,
+        }
+
+        for statement in CPP_DIRECT:
+            pre += "%s\n" % statement
 
         pre += '\n#include "%s"\n\n' % header_file
 
-        pre += 'void event_warn(const char *fmt, ...);\n'
-        pre += 'void event_warnx(const char *fmt, ...);\n\n'
+        pre += "void event_warn(const char *fmt, ...);\n"
+        pre += "void event_warnx(const char *fmt, ...);\n\n"
 
         return pre
 
-    def HeaderFilename(self, filename):
-        return '.'.join(filename.split('.')[:-1]) + '.h'
+    @staticmethod
+    def HeaderFilename(filename):
+        return ".".join(filename.split(".")[:-1]) + ".h"
 
-    def CodeFilename(self, filename):
-        return '.'.join(filename.split('.')[:-1]) + '.gen.c'
+    @staticmethod
+    def CodeFilename(filename):
+        return ".".join(filename.split(".")[:-1]) + ".gen.c"
 
-    def Struct(self, name):
+    @staticmethod
+    def Struct(name):
         return StructCCode(name)
 
-    def EntryBytes(self, entry_type, name, tag, fixed_length):
+    @staticmethod
+    def EntryBytes(entry_type, name, tag, fixed_length):
         return EntryBytes(entry_type, name, tag, fixed_length)
 
-    def EntryVarBytes(self, entry_type, name, tag):
+    @staticmethod
+    def EntryVarBytes(entry_type, name, tag):
         return EntryVarBytes(entry_type, name, tag)
 
-    def EntryInt(self, entry_type, name, tag, bits=32):
+    @staticmethod
+    def EntryInt(entry_type, name, tag, bits=32):
         return EntryInt(entry_type, name, tag, bits)
 
-    def EntryString(self, entry_type, name, tag):
+    @staticmethod
+    def EntryString(entry_type, name, tag):
         return EntryString(entry_type, name, tag)
 
-    def EntryStruct(self, entry_type, name, tag, struct_name):
+    @staticmethod
+    def EntryStruct(entry_type, name, tag, struct_name):
         return EntryStruct(entry_type, name, tag, struct_name)
 
-    def EntryArray(self, entry):
+    @staticmethod
+    def EntryArray(entry):
         return EntryArray(entry)
 
-class Usage(RpcGenError):
-    def __init__(self, argv0):
-        RpcGenError.__init__("usage: %s input.rpc [[output.h] output.c]"
-                             % argv0)
 
-class CommandLine:
-    def __init__(self, argv):
+class CommandLine(object):
+    def __init__(self, argv=None):
         """Initialize a command-line to launch event_rpcgen, as if
            from a command-line with CommandLine(sys.argv).  If you're
            calling this directly, remember to provide a dummy value
            for sys.argv[0]
         """
+        global QUIETLY
+
         self.filename = None
         self.header_file = None
         self.impl_file = None
         self.factory = CCodeGenerator()
 
-        if len(argv) >= 2 and argv[1] == '--quiet':
-            global QUIETLY
-            QUIETLY = 1
-            del argv[1]
+        parser = argparse.ArgumentParser(
+            usage="%(prog)s [options] rpc-file [[h-file] c-file]"
+        )
+        parser.add_argument("--quiet", action="store_true", default=False)
+        parser.add_argument("rpc_file", type=argparse.FileType("r"))
+
+        args, extra_args = parser.parse_known_args(args=argv)
 
-        if len(argv) < 2 or len(argv) > 4:
-            raise Usage(argv[0])
+        QUIETLY = args.quiet
 
-        self.filename = argv[1].replace('\\', '/')
-        if len(argv) == 3:
-            self.impl_file = argv[2].replace('\\', '/')
-        if len(argv) == 4:
-            self.header_file = argv[2].replace('\\', '/')
-            self.impl_file = argv[3].replace('\\', '/')
+        if extra_args:
+            if len(extra_args) == 1:
+                self.impl_file = extra_args[0].replace("\\", "/")
+            elif len(extra_args) == 2:
+                self.header_file = extra_args[0].replace("\\", "/")
+                self.impl_file = extra_args[1].replace("\\", "/")
+            else:
+                parser.error("Spurious arguments provided")
 
-        if not self.filename:
-            raise Usage(argv[0])
+        self.rpc_file = args.rpc_file
 
         if not self.impl_file:
-            self.impl_file = self.factory.CodeFilename(self.filename)
+            self.impl_file = self.factory.CodeFilename(self.rpc_file.name)
 
         if not self.header_file:
             self.header_file = self.factory.HeaderFilename(self.impl_file)
 
-        if not self.impl_file.endswith('.c'):
-            raise RpcGenError("can only generate C implementation files")
-        if not self.header_file.endswith('.h'):
-            raise RpcGenError("can only generate C header files")
+        if not self.impl_file.endswith(".c"):
+            parser.error("can only generate C implementation files")
+        if not self.header_file.endswith(".h"):
+            parser.error("can only generate C header files")
 
     def run(self):
-        filename = self.filename
+        filename = self.rpc_file.name
         header_file = self.header_file
         impl_file = self.impl_file
         factory = self.factory
 
-        declare('Reading \"%s\"' % filename)
+        declare('Reading "%s"' % filename)
 
-        fp = open(filename, 'r')
-        entities = Parse(factory, fp)
-        fp.close()
+        with self.rpc_file:
+            entities = Parse(factory, self.rpc_file)
 
         declare('... creating "%s"' % header_file)
-        header_fp = open(header_file, 'w')
-        print >>header_fp, factory.HeaderPreamble(filename)
+        with open(header_file, "w") as header_fp:
+            header_fp.write(factory.HeaderPreamble(filename))
 
-        # Create forward declarations: allows other structs to reference
-        # each other
-        for entry in entities:
-            entry.PrintForwardDeclaration(header_fp)
-        print >>header_fp, ''
+            # Create forward declarations: allows other structs to reference
+            # each other
+            for entry in entities:
+                entry.PrintForwardDeclaration(header_fp)
+            header_fp.write("\n")
 
-        for entry in entities:
-            entry.PrintTags(header_fp)
-            entry.PrintDeclaration(header_fp)
-        print >>header_fp, factory.HeaderPostamble(filename)
-        header_fp.close()
+            for entry in entities:
+                entry.PrintTags(header_fp)
+                entry.PrintDeclaration(header_fp)
+            header_fp.write(factory.HeaderPostamble(filename))
 
         declare('... creating "%s"' % impl_file)
-        impl_fp = open(impl_file, 'w')
-        print >>impl_fp, factory.BodyPreamble(filename, header_file)
-        for entry in entities:
-            entry.PrintCode(impl_fp)
-        impl_fp.close()
+        with open(impl_file, "w") as impl_fp:
+            impl_fp.write(factory.BodyPreamble(filename, header_file))
+            for entry in entities:
+                entry.PrintCode(impl_fp)
 
-if __name__ == '__main__':
-    try:
-        CommandLine(sys.argv).run()
-        sys.exit(0)
-
-    except RpcGenError, e:
-        print >>sys.stderr, e
-        sys.exit(1)
 
-    except EnvironmentError, e:
+def main(argv=None):
+    try:
+        CommandLine(argv=argv).run()
+        return 0
+    except RpcGenError as e:
+        sys.stderr.write(e)
+    except EnvironmentError as e:
         if e.filename and e.strerror:
-            print >>sys.stderr, "%s: %s" % (e.filename, e.strerror)
-            sys.exit(1)
+            sys.stderr.write("%s: %s" % (e.filename, e.strerror))
         elif e.strerror:
-            print >> sys.stderr, e.strerror
-            sys.exit(1)
+            sys.stderr.write(e.strerror)
         else:
             raise
+    return 1
+
+
+if __name__ == "__main__":
+    sys.exit(main(argv=sys.argv[1:]))
diff --git a/ipc/chromium/src/third_party/libevent/event_tagging.c b/ipc/chromium/src/third_party/libevent/event_tagging.c
index 6459dfa72e5b..b021e8c8dea2 100644
--- a/ipc/chromium/src/third_party/libevent/event_tagging.c
+++ b/ipc/chromium/src/third_party/libevent/event_tagging.c
@@ -93,9 +93,13 @@
        a final padding nibble with value 0 is appended.
 */
 
+EVENT2_EXPORT_SYMBOL
 int evtag_decode_int(ev_uint32_t *pnumber, struct evbuffer *evbuf);
+EVENT2_EXPORT_SYMBOL
 int evtag_decode_int64(ev_uint64_t *pnumber, struct evbuffer *evbuf);
+EVENT2_EXPORT_SYMBOL
 int evtag_encode_tag(struct evbuffer *evbuf, ev_uint32_t tag);
+EVENT2_EXPORT_SYMBOL
 int evtag_decode_tag(ev_uint32_t *ptag, struct evbuffer *evbuf);
 
 void
diff --git a/ipc/chromium/src/third_party/libevent/evmap.c b/ipc/chromium/src/third_party/libevent/evmap.c
index 3f76dd0ae1f7..e4e35c6877f8 100644
--- a/ipc/chromium/src/third_party/libevent/evmap.c
+++ b/ipc/chromium/src/third_party/libevent/evmap.c
@@ -43,6 +43,7 @@
 #include <unistd.h>
 #endif
 #include <errno.h>
+#include <limits.h>
 #include <signal.h>
 #include <string.h>
 #include <time.h>
@@ -207,9 +208,15 @@ evmap_make_space(struct event_signal_map *map, int slot, int msize)
 		int nentries = map->nentries ? map->nentries : 32;
 		void **tmp;
 
+		if (slot > INT_MAX / 2)
+			return (-1);
+
 		while (nentries <= slot)
 			nentries <<= 1;
 
+		if (nentries > INT_MAX / msize)
+			return (-1);
+
 		tmp = (void **)mm_realloc(map->entries, nentries * msize);
 		if (tmp == NULL)
 			return (-1);
@@ -393,7 +400,8 @@ evmap_io_del_(struct event_base *base, evutil_socket_t fd, struct event *ev)
 
 	if (res) {
 		void *extra = ((char*)ctx) + sizeof(struct evmap_io);
-		if (evsel->del(base, ev->ev_fd, old, res, extra) == -1) {
+		if (evsel->del(base, ev->ev_fd,
+			old, (ev->ev_events & EV_ET) | res, extra) == -1) {
 			retval = -1;
 		} else {
 			retval = 1;
@@ -424,7 +432,7 @@ evmap_io_active_(struct event_base *base, evutil_socket_t fd, short events)
 	if (NULL == ctx)
 		return;
 	LIST_FOREACH(ev, &ctx->events, ev_io_next) {
-		if (ev->ev_events & events)
+		if (ev->ev_events & (events & ~EV_ET))
 			event_active_nolock_(ev, ev->ev_events & events, 1);
 	}
 }
@@ -445,6 +453,9 @@ evmap_signal_add_(struct event_base *base, int sig, struct event *ev)
 	struct event_signal_map *map = &base->sigmap;
 	struct evmap_signal *ctx = NULL;
 
+	if (sig < 0 || sig >= NSIG)
+		return (-1);
+
 	if (sig >= map->nentries) {
 		if (evmap_make_space(
 			map, sig, sizeof(struct evmap_signal *)) == -1)
@@ -471,7 +482,7 @@ evmap_signal_del_(struct event_base *base, int sig, struct event *ev)
 	struct event_signal_map *map = &base->sigmap;
 	struct evmap_signal *ctx;
 
-	if (sig >= map->nentries)
+	if (sig < 0 || sig >= map->nentries)
 		return (-1);
 
 	GET_SIGNAL_SLOT(ctx, map, sig, evmap_signal);
@@ -858,6 +869,7 @@ event_changelist_add_(struct event_base *base, evutil_socket_t fd, short old, sh
 	struct event_changelist *changelist = &base->changelist;
 	struct event_changelist_fdinfo *fdinfo = p;
 	struct event_change *change;
+	ev_uint8_t evchange = EV_CHANGE_ADD | (events & (EV_ET|EV_PERSIST|EV_SIGNAL));
 
 	event_changelist_check(base);
 
@@ -869,18 +881,12 @@ event_changelist_add_(struct event_base *base, evutil_socket_t fd, short old, sh
 	 * since the delete might fail (because the fd had been closed since
 	 * the last add, for instance. */
 
-	if (events & (EV_READ|EV_SIGNAL)) {
-		change->read_change = EV_CHANGE_ADD |
-		    (events & (EV_ET|EV_PERSIST|EV_SIGNAL));
-	}
-	if (events & EV_WRITE) {
-		change->write_change = EV_CHANGE_ADD |
-		    (events & (EV_ET|EV_PERSIST|EV_SIGNAL));
-	}
-	if (events & EV_CLOSED) {
-		change->close_change = EV_CHANGE_ADD |
-		    (events & (EV_ET|EV_PERSIST|EV_SIGNAL));
-	}
+	if (events & (EV_READ|EV_SIGNAL))
+		change->read_change = evchange;
+	if (events & EV_WRITE)
+		change->write_change = evchange;
+	if (events & EV_CLOSED)
+		change->close_change = evchange;
 
 	event_changelist_check(base);
 	return (0);
@@ -893,6 +899,7 @@ event_changelist_del_(struct event_base *base, evutil_socket_t fd, short old, sh
 	struct event_changelist *changelist = &base->changelist;
 	struct event_changelist_fdinfo *fdinfo = p;
 	struct event_change *change;
+	ev_uint8_t del = EV_CHANGE_DEL | (events & EV_ET);
 
 	event_changelist_check(base);
 	change = event_changelist_get_or_construct(changelist, fd, old, fdinfo);
@@ -919,19 +926,19 @@ event_changelist_del_(struct event_base *base, evutil_socket_t fd, short old, sh
 		if (!(change->old_events & (EV_READ | EV_SIGNAL)))
 			change->read_change = 0;
 		else
-			change->read_change = EV_CHANGE_DEL;
+			change->read_change = del;
 	}
 	if (events & EV_WRITE) {
 		if (!(change->old_events & EV_WRITE))
 			change->write_change = 0;
 		else
-			change->write_change = EV_CHANGE_DEL;
+			change->write_change = del;
 	}
 	if (events & EV_CLOSED) {
 		if (!(change->old_events & EV_CLOSED))
 			change->close_change = 0;
 		else
-			change->close_change = EV_CHANGE_DEL;
+			change->close_change = del;
 	}
 
 	event_changelist_check(base);
diff --git a/ipc/chromium/src/third_party/libevent/evrpc.c b/ipc/chromium/src/third_party/libevent/evrpc.c
index 2443ab27937a..4a60ca5f0703 100644
--- a/ipc/chromium/src/third_party/libevent/evrpc.c
+++ b/ipc/chromium/src/third_party/libevent/evrpc.c
@@ -329,7 +329,8 @@ evrpc_request_cb(struct evhttp_request *req, void *arg)
 	return;
 
 error:
-	evrpc_reqstate_free_(rpc_state);
+	if (rpc_state)
+		evrpc_reqstate_free_(rpc_state);
 	evhttp_send_error(req, HTTP_SERVUNAVAIL, NULL);
 	return;
 }
@@ -891,8 +892,7 @@ evrpc_reply_done(struct evhttp_request *req, void *arg)
 			 * layer is going to free it.  we need to
 			 * request ownership explicitly
 			 */
-			if (req != NULL)
-				evhttp_request_own(req);
+			evhttp_request_own(req);
 
 			evrpc_pause_request(pool, ctx,
 			    evrpc_reply_done_closure);
diff --git a/ipc/chromium/src/third_party/libevent/evthread-internal.h b/ipc/chromium/src/third_party/libevent/evthread-internal.h
index efdecf81e7cd..83e409f09b4c 100644
--- a/ipc/chromium/src/third_party/libevent/evthread-internal.h
+++ b/ipc/chromium/src/third_party/libevent/evthread-internal.h
@@ -38,7 +38,7 @@ extern "C" {
 
 struct event_base;
 
-#ifndef _WIN32
+#if !defined(_WIN32) && !defined(__CYGWIN__)
 /* On Windows, the way we currently make DLLs, it's not allowed for us to
  * have shared global structures.  Thus, we only do the direct-call-to-function
  * code path if we know that the local shared library system supports it.
@@ -49,9 +49,12 @@ struct event_base;
 #if ! defined(EVENT__DISABLE_THREAD_SUPPORT) && defined(EVTHREAD_EXPOSE_STRUCTS)
 /* Global function pointers to lock-related functions. NULL if locking isn't
    enabled. */
+EVENT2_EXPORT_SYMBOL
 extern struct evthread_lock_callbacks evthread_lock_fns_;
+EVENT2_EXPORT_SYMBOL
 extern struct evthread_condition_callbacks evthread_cond_fns_;
 extern unsigned long (*evthread_id_fn_)(void);
+EVENT2_EXPORT_SYMBOL
 extern int evthread_lock_debugging_enabled_;
 
 /** Return the ID of the current thread, or 1 if threading isn't enabled. */
@@ -182,14 +185,23 @@ EVLOCK_TRY_LOCK_(void *lock)
 #elif ! defined(EVENT__DISABLE_THREAD_SUPPORT)
 
 unsigned long evthreadimpl_get_id_(void);
+EVENT2_EXPORT_SYMBOL
 int evthreadimpl_is_lock_debugging_enabled_(void);
+EVENT2_EXPORT_SYMBOL
 void *evthreadimpl_lock_alloc_(unsigned locktype);
+EVENT2_EXPORT_SYMBOL
 void evthreadimpl_lock_free_(void *lock, unsigned locktype);
+EVENT2_EXPORT_SYMBOL
 int evthreadimpl_lock_lock_(unsigned mode, void *lock);
+EVENT2_EXPORT_SYMBOL
 int evthreadimpl_lock_unlock_(unsigned mode, void *lock);
+EVENT2_EXPORT_SYMBOL
 void *evthreadimpl_cond_alloc_(unsigned condtype);
+EVENT2_EXPORT_SYMBOL
 void evthreadimpl_cond_free_(void *cond);
+EVENT2_EXPORT_SYMBOL
 int evthreadimpl_cond_signal_(void *cond, int broadcast);
+EVENT2_EXPORT_SYMBOL
 int evthreadimpl_cond_wait_(void *cond, void *lock, const struct timeval *tv);
 int evthreadimpl_locking_enabled_(void);
 
@@ -355,6 +367,7 @@ EVLOCK_TRY_LOCK_(void *lock)
 		EVLOCK_UNLOCK(lock1_tmplock_,mode1);			\
 	} while (0)
 
+EVENT2_EXPORT_SYMBOL
 int evthread_is_debug_lock_held_(void *lock);
 void *evthread_debug_get_real_lock_(void *lock);
 
@@ -377,6 +390,7 @@ int evutil_global_setup_locks_(const int enable_locks);
 int evutil_secure_rng_global_setup_locks_(const int enable_locks);
 
 /** Return current evthread_lock_callbacks */
+EVENT2_EXPORT_SYMBOL
 struct evthread_lock_callbacks *evthread_get_lock_callbacks(void);
 /** Return current evthread_condition_callbacks */
 struct evthread_condition_callbacks *evthread_get_condition_callbacks(void);
diff --git a/ipc/chromium/src/third_party/libevent/evthread.c b/ipc/chromium/src/third_party/libevent/evthread.c
index f3f1eddc8934..3eac594d64dc 100644
--- a/ipc/chromium/src/third_party/libevent/evthread.c
+++ b/ipc/chromium/src/third_party/libevent/evthread.c
@@ -46,7 +46,7 @@
 #endif
 
 #ifndef EVENT__DISABLE_DEBUG_MODE
-extern int event_debug_created_threadable_ctx_;                    
+extern int event_debug_created_threadable_ctx_;
 extern int event_debug_mode_on_;
 #endif
 
diff --git a/ipc/chromium/src/third_party/libevent/evutil.c b/ipc/chromium/src/third_party/libevent/evutil.c
index 1e8ef7bd3280..9817f086433d 100644
--- a/ipc/chromium/src/third_party/libevent/evutil.c
+++ b/ipc/chromium/src/third_party/libevent/evutil.c
@@ -29,6 +29,7 @@
 
 #ifdef _WIN32
 #include <winsock2.h>
+#include <winerror.h>
 #include <ws2tcpip.h>
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
@@ -40,6 +41,7 @@
 /* For structs needed by GetAdaptersAddresses */
 #define _WIN32_WINNT 0x0501
 #include <iphlpapi.h>
+#include <netioapi.h>
 #endif
 
 #include <sys/types.h>
@@ -73,6 +75,9 @@
 #endif
 #include <time.h>
 #include <sys/stat.h>
+#ifndef _WIN32
+#include <net/if.h>
+#endif
 #ifdef EVENT__HAVE_IFADDRS_H
 #include <ifaddrs.h>
 #endif
@@ -385,6 +390,17 @@ evutil_make_listen_socket_reuseable_port(evutil_socket_t sock)
 #endif
 }
 
+int
+evutil_make_listen_socket_ipv6only(evutil_socket_t sock)
+{
+#if defined(IPV6_V6ONLY)
+	int one = 1;
+	return setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, (void*) &one,
+	    (ev_socklen_t)sizeof(one));
+#endif
+	return 0;
+}
+
 int
 evutil_make_tcp_listen_socket_deferred(evutil_socket_t sock)
 {
@@ -595,44 +611,56 @@ evutil_socket_finished_connecting_(evutil_socket_t fd)
    set by evutil_check_interfaces. */
 static int have_checked_interfaces, had_ipv4_address, had_ipv6_address;
 
-/* Macro: True iff the IPv4 address 'addr', in host order, is in 127.0.0.0/8
- */
-#define EVUTIL_V4ADDR_IS_LOCALHOST(addr) (((addr)>>24) == 127)
+/* True iff the IPv4 address 'addr', in host order, is in 127.0.0.0/8 */
+static inline int evutil_v4addr_is_localhost(ev_uint32_t addr)
+{ return addr>>24 == 127; }
 
-/* Macro: True iff the IPv4 address 'addr', in host order, is a class D
- * (multiclass) address.
- */
-#define EVUTIL_V4ADDR_IS_CLASSD(addr) ((((addr)>>24) & 0xf0) == 0xe0)
+/* True iff the IPv4 address 'addr', in host order, is link-local
+ * 169.254.0.0/16 (RFC3927) */
+static inline int evutil_v4addr_is_linklocal(ev_uint32_t addr)
+{ return ((addr & 0xffff0000U) == 0xa9fe0000U); }
+
+/* True iff the IPv4 address 'addr', in host order, is a class D
+ * (multiclass) address.  */
+static inline int evutil_v4addr_is_classd(ev_uint32_t addr)
+{ return ((addr>>24) & 0xf0) == 0xe0; }
+
+int
+evutil_v4addr_is_local_(const struct in_addr *in)
+{
+	const ev_uint32_t addr = ntohl(in->s_addr);
+	return addr == INADDR_ANY ||
+		evutil_v4addr_is_localhost(addr) ||
+		evutil_v4addr_is_linklocal(addr) ||
+		evutil_v4addr_is_classd(addr);
+}
+int
+evutil_v6addr_is_local_(const struct in6_addr *in)
+{
+	static const char ZEROES[] =
+		"\x00\x00\x00\x00\x00\x00\x00\x00"
+		"\x00\x00\x00\x00\x00\x00\x00\x00";
+
+	const unsigned char *addr = (const unsigned char *)in->s6_addr;
+	return !memcmp(addr, ZEROES, 8) ||
+		((addr[0] & 0xfe) == 0xfc) ||
+		(addr[0] == 0xfe && (addr[1] & 0xc0) == 0x80) ||
+		(addr[0] == 0xfe && (addr[1] & 0xc0) == 0xc0) ||
+		(addr[0] == 0xff);
+}
 
 static void
 evutil_found_ifaddr(const struct sockaddr *sa)
 {
-	const char ZEROES[] = "\x00\x00\x00\x00\x00\x00\x00\x00"
-	    "\x00\x00\x00\x00\x00\x00\x00\x00";
-
 	if (sa->sa_family == AF_INET) {
 		const struct sockaddr_in *sin = (struct sockaddr_in *)sa;
-		ev_uint32_t addr = ntohl(sin->sin_addr.s_addr);
-		if (addr == 0 ||
-		    EVUTIL_V4ADDR_IS_LOCALHOST(addr) ||
-		    EVUTIL_V4ADDR_IS_CLASSD(addr)) {
-			/* Not actually a usable external address. */
-		} else {
+		if (!evutil_v4addr_is_local_(&sin->sin_addr)) {
 			event_debug(("Detected an IPv4 interface"));
 			had_ipv4_address = 1;
 		}
 	} else if (sa->sa_family == AF_INET6) {
 		const struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)sa;
-		const unsigned char *addr =
-		    (unsigned char*)sin6->sin6_addr.s6_addr;
-		if (!memcmp(addr, ZEROES, 8) ||
-		    ((addr[0] & 0xfe) == 0xfc) ||
-		    (addr[0] == 0xfe && (addr[1] & 0xc0) == 0x80) ||
-		    (addr[0] == 0xfe && (addr[1] & 0xc0) == 0xc0) ||
-		    (addr[0] == 0xff)) {
-			/* This is a reserved, ipv4compat, ipv4map, loopback,
-			 * link-local, multicast, or unspecified address. */
-		} else {
+		if (!evutil_v6addr_is_local_(&sin6->sin6_addr)) {
 			event_debug(("Detected an IPv6 interface"));
 			had_ipv6_address = 1;
 		}
@@ -670,7 +698,7 @@ evutil_check_ifaddrs(void)
 	   "GetAdaptersInfo", but that's deprecated; let's just try
 	   GetAdaptersAddresses and fall back to connect+getsockname.
 	*/
-	HMODULE lib = evutil_load_windows_system_library_(TEXT("ihplapi.dll"));
+	HMODULE lib = evutil_load_windows_system_library_(TEXT("iphlpapi.dll"));
 	GetAdaptersAddresses_fn_t fn;
 	ULONG size, res;
 	IP_ADAPTER_ADDRESSES *addresses = NULL, *address;
@@ -727,7 +755,7 @@ done:
 /* Test whether we have an ipv4 interface and an ipv6 interface.  Return 0 if
  * the test seemed successful. */
 static int
-evutil_check_interfaces(int force_recheck)
+evutil_check_interfaces(void)
 {
 	evutil_socket_t fd = -1;
 	struct sockaddr_in sin, sin_out;
@@ -735,9 +763,12 @@ evutil_check_interfaces(int force_recheck)
 	ev_socklen_t sin_out_len = sizeof(sin_out);
 	ev_socklen_t sin6_out_len = sizeof(sin6_out);
 	int r;
-	if (have_checked_interfaces && !force_recheck)
+	if (have_checked_interfaces)
 		return 0;
 
+	/* From this point on we have done the ipv4/ipv6 interface check */
+	have_checked_interfaces = 1;
+
 	if (evutil_check_ifaddrs() == 0) {
 		/* Use a nice sane interface, if this system has one. */
 		return 0;
@@ -963,6 +994,7 @@ evutil_getaddrinfo_common_(const char *nodename, const char *servname,
     struct evutil_addrinfo *hints, struct evutil_addrinfo **res, int *portnum)
 {
 	int port = 0;
+	unsigned int if_index;
 	const char *pname;
 
 	if (nodename == NULL && servname == NULL)
@@ -1036,10 +1068,12 @@ evutil_getaddrinfo_common_(const char *nodename, const char *servname,
 	if (hints->ai_family == PF_INET6 || hints->ai_family == PF_UNSPEC) {
 		struct sockaddr_in6 sin6;
 		memset(&sin6, 0, sizeof(sin6));
-		if (1==evutil_inet_pton(AF_INET6, nodename, &sin6.sin6_addr)) {
+		if (1 == evutil_inet_pton_scope(
+			AF_INET6, nodename, &sin6.sin6_addr, &if_index)) {
 			/* Got an ipv6 address. */
 			sin6.sin6_family = AF_INET6;
 			sin6.sin6_port = htons(port);
+			sin6.sin6_scope_id = if_index;
 			*res = evutil_new_addrinfo_((struct sockaddr*)&sin6,
 			    sizeof(sin6), hints);
 			if (!*res)
@@ -1053,7 +1087,7 @@ evutil_getaddrinfo_common_(const char *nodename, const char *servname,
 		struct sockaddr_in sin;
 		memset(&sin, 0, sizeof(sin));
 		if (1==evutil_inet_pton(AF_INET, nodename, &sin.sin_addr)) {
-			/* Got an ipv6 address. */
+			/* Got an ipv4 address. */
 			sin.sin_family = AF_INET;
 			sin.sin_port = htons(port);
 			*res = evutil_new_addrinfo_((struct sockaddr*)&sin,
@@ -1205,8 +1239,7 @@ evutil_adjust_hints_for_addrconfig_(struct evutil_addrinfo *hints)
 		return;
 	if (hints->ai_family != PF_UNSPEC)
 		return;
-	if (!have_checked_interfaces)
-		evutil_check_interfaces(0);
+	evutil_check_interfaces();
 	if (had_ipv4_address && !had_ipv6_address) {
 		hints->ai_family = PF_INET;
 	} else if (!had_ipv4_address && had_ipv6_address) {
@@ -1955,6 +1988,41 @@ evutil_inet_ntop(int af, const void *src, char *dst, size_t len)
 #endif
 }
 
+int
+evutil_inet_pton_scope(int af, const char *src, void *dst, unsigned *indexp)
+{
+	int r;
+	unsigned if_index;
+	char *check, *cp, *tmp_src;
+
+	*indexp = 0; /* Reasonable default */
+
+	/* Bail out if not IPv6 */
+	if (af != AF_INET6)
+		return evutil_inet_pton(af, src, dst);
+
+	cp = strchr(src, '%');
+
+	/* Bail out if no zone ID */
+	if (cp == NULL)
+		return evutil_inet_pton(af, src, dst);
+
+	if_index = if_nametoindex(cp + 1);
+	if (if_index == 0) {
+		/* Could be numeric */
+		if_index = strtoul(cp + 1, &check, 10);
+		if (check[0] != '\0')
+			return 0;
+	}
+	*indexp = if_index;
+	tmp_src = mm_strdup(src);
+	cp = strchr(tmp_src, '%');
+	*cp = '\0';
+	r = evutil_inet_pton(af, tmp_src, dst);
+	free(tmp_src);
+	return r;
+}
+
 int
 evutil_inet_pton(int af, const char *src, void *dst)
 {
@@ -2071,6 +2139,7 @@ int
 evutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *outlen)
 {
 	int port;
+	unsigned int if_index;
 	char buf[128];
 	const char *cp, *addr_part, *port_part;
 	int is_ipv6;
@@ -2140,10 +2209,13 @@ evutil_parse_sockaddr_port(const char *ip_as_string, struct sockaddr *out, int *
 #endif
 		sin6.sin6_family = AF_INET6;
 		sin6.sin6_port = htons(port);
-		if (1 != evutil_inet_pton(AF_INET6, addr_part, &sin6.sin6_addr))
+		if (1 != evutil_inet_pton_scope(
+			AF_INET6, addr_part, &sin6.sin6_addr, &if_index)) {
 			return -1;
+		}
 		if ((int)sizeof(sin6) > *outlen)
 			return -1;
+		sin6.sin6_scope_id = if_index;
 		memset(out, 0, *outlen);
 		memcpy(out, &sin6, sizeof(sin6));
 		*outlen = sizeof(sin6);
@@ -2297,7 +2369,7 @@ static const unsigned char EVUTIL_TOLOWER_TABLE[256] = {
 #define IMPL_CTYPE_FN(name)						\
 	int EVUTIL_##name##_(char c) {					\
 		ev_uint8_t u = c;					\
-		return !!(EVUTIL_##name##_TABLE[(u >> 5) & 7] & (1 << (u & 31))); \
+		return !!(EVUTIL_##name##_TABLE[(u >> 5) & 7] & (1U << (u & 31))); \
 	}
 IMPL_CTYPE_FN(ISALPHA)
 IMPL_CTYPE_FN(ISALNUM)
@@ -2593,7 +2665,7 @@ evutil_accept4_(evutil_socket_t sockfd, struct sockaddr *addr,
 }
 
 /* Internal function: Set fd[0] and fd[1] to a pair of fds such that writes on
- * fd[0] get read from fd[1].  Make both fds nonblocking and close-on-exec.
+ * fd[1] get read from fd[0].  Make both fds nonblocking and close-on-exec.
  * Return 0 on success, -1 on failure.
  */
 int
diff --git a/ipc/chromium/src/third_party/libevent/evutil_rand.c b/ipc/chromium/src/third_party/libevent/evutil_rand.c
index 02df7899d106..8e9afdaa6753 100644
--- a/ipc/chromium/src/third_party/libevent/evutil_rand.c
+++ b/ipc/chromium/src/third_party/libevent/evutil_rand.c
@@ -171,9 +171,7 @@ evutil_secure_rng_init(void)
 	int val;
 
 	ARC4_LOCK_();
-	if (!arc4_seeded_ok)
-		arc4_stir();
-	val = arc4_seeded_ok ? 0 : -1;
+	val = (!arc4_stir()) ? 0 : -1;
 	ARC4_UNLOCK_();
 	return val;
 }
@@ -192,7 +190,7 @@ evutil_secure_rng_get_bytes(void *buf, size_t n)
 	ev_arc4random_buf(buf, n);
 }
 
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(ANDROID)
+#if !defined(EVENT__HAVE_ARC4RANDOM) || defined(EVENT__HAVE_ARC4RANDOM_ADDRANDOM)
 void
 evutil_secure_rng_add_bytes(const char *buf, size_t n)
 {
diff --git a/ipc/chromium/src/third_party/libevent/evutil_time.c b/ipc/chromium/src/third_party/libevent/evutil_time.c
index 00fd5fb4f77b..c327218227a4 100644
--- a/ipc/chromium/src/third_party/libevent/evutil_time.c
+++ b/ipc/chromium/src/third_party/libevent/evutil_time.c
@@ -43,7 +43,7 @@
 #ifndef EVENT__HAVE_GETTIMEOFDAY
 #include <sys/timeb.h>
 #endif
-#if !defined(EVENT__HAVE_NANOSLEEP) && !defined(EVENT_HAVE_USLEEP) && \
+#if !defined(EVENT__HAVE_NANOSLEEP) && !defined(EVENT__HAVE_USLEEP) && \
 	!defined(_WIN32)
 #include <sys/select.h>
 #endif
@@ -65,6 +65,9 @@
 
 #ifndef EVENT__HAVE_GETTIMEOFDAY
 /* No gettimeofday; this must be windows. */
+
+typedef void (WINAPI *GetSystemTimePreciseAsFileTime_fn_t) (LPFILETIME);
+
 int
 evutil_gettimeofday(struct timeval *tv, struct timezone *tz)
 {
@@ -90,7 +93,22 @@ evutil_gettimeofday(struct timeval *tv, struct timezone *tz)
 	if (tv == NULL)
 		return -1;
 
-	GetSystemTimeAsFileTime(&ft.ft_ft);
+	static GetSystemTimePreciseAsFileTime_fn_t GetSystemTimePreciseAsFileTime_fn = NULL;
+	static int check_precise = 1;
+
+	if (EVUTIL_UNLIKELY(check_precise)) {
+		HMODULE h = evutil_load_windows_system_library_(TEXT("kernel32.dll"));
+		if (h != NULL)
+			GetSystemTimePreciseAsFileTime_fn =
+				(GetSystemTimePreciseAsFileTime_fn_t)
+					GetProcAddress(h, "GetSystemTimePreciseAsFileTime");
+		check_precise = 0;
+	}
+
+	if (GetSystemTimePreciseAsFileTime_fn != NULL)
+		GetSystemTimePreciseAsFileTime_fn(&ft.ft_ft);
+	else
+		GetSystemTimeAsFileTime(&ft.ft_ft);
 
 	if (EVUTIL_UNLIKELY(ft.ft_64 < EPOCH_BIAS)) {
 		/* Time before the unix epoch. */
@@ -126,8 +144,22 @@ evutil_usleep_(const struct timeval *tv)
 		return;
 #if defined(_WIN32)
 	{
-		long msec = evutil_tv_to_msec_(tv);
-		Sleep((DWORD)msec);
+		__int64 usec;
+		LARGE_INTEGER li;
+		HANDLE timer;
+
+		usec = tv->tv_sec * 1000000LL + tv->tv_usec;
+		if (!usec)
+			return;
+
+		li.QuadPart = -10LL * usec;
+		timer = CreateWaitableTimer(NULL, TRUE, NULL);
+		if (!timer)
+			return;
+
+		SetWaitableTimer(timer, &li, 0, NULL, NULL, 0);
+		WaitForSingleObject(timer, INFINITE);
+		CloseHandle(timer);
 	}
 #elif defined(EVENT__HAVE_NANOSLEEP)
 	{
@@ -141,7 +173,10 @@ evutil_usleep_(const struct timeval *tv)
 	sleep(tv->tv_sec);
 	usleep(tv->tv_usec);
 #else
-	select(0, NULL, NULL, NULL, tv);
+	{
+		struct timeval tv2 = *tv;
+		select(0, NULL, NULL, NULL, &tv2);
+	}
 #endif
 }
 
@@ -155,18 +190,28 @@ evutil_date_rfc1123(char *date, const size_t datelen, const struct tm *tm)
 
 	time_t t = time(NULL);
 
-#ifndef _WIN32
+#if defined(EVENT__HAVE__GMTIME64_S) || !defined(_WIN32)
 	struct tm sys;
 #endif
 
 	/* If `tm` is null, set system's current time. */
 	if (tm == NULL) {
-#ifdef _WIN32
-		/** TODO: detect _gmtime64()/_gmtime64_s() */
-		tm = gmtime(&t);
-#else
+#if !defined(_WIN32)
 		gmtime_r(&t, &sys);
 		tm = &sys;
+		/** detect _gmtime64()/_gmtime64_s() */
+#elif defined(EVENT__HAVE__GMTIME64_S)
+		errno_t err;
+		err = _gmtime64_s(&sys, &t);
+		if (err) {
+			event_errx(1, "Invalid argument to _gmtime64_s");
+		} else {
+			tm = &sys;
+		}
+#elif defined(EVENT__HAVE__GMTIME64)
+		tm = _gmtime64(&t);
+#else
+		tm = gmtime(&t);
 #endif
 	}
 
diff --git a/ipc/chromium/src/third_party/libevent/extra/abi-check/README.md b/ipc/chromium/src/third_party/libevent/extra/abi-check/README.md
new file mode 100644
index 000000000000..77fdd94128db
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/extra/abi-check/README.md
@@ -0,0 +1,35 @@
+## libevent ABI/API changes
+
+
+This script is used to generate information about changes in libevent ABI/API
+between various versions using [LVC tools](https://github.com/lvc). Such an
+overview can help developers migrate from one version to another.
+
+Here is the `abi_check.sh`, which is used to generate ABI/API timeline for
+libevent.
+
+You can limit the number of included libevent versions via a number given
+as a parameter to the script. For example
+
+```shell
+$ ./abi_check.sh 3
+```
+
+generates overview for the last 3 versions and the current version.
+If no parameter given, it will generate overview for the last 2 versions and
+the current version by default.
+
+But this script requires some tools that are available in the following docker image:
+
+```
+docker.pkg.github.com/azat/docker-images/lvc-debian
+```
+
+And the full command looks like:
+
+```shell
+  docker run --rm -it -v $PWD:/src:ro -w /src -v tmp/le-abi-check-root:/abi-root -e ABI_CHECK_ROOT=/abi-root docker.pkg.github.com/azat/docker-images/lvc-debian /src/extra/abi-check/abi_check.sh
+```
+
+'timeline/libevent/index.html' is the final result and can be viewed
+[here](https://libevent.org/abi)
diff --git a/ipc/chromium/src/third_party/libevent/extra/abi-check/abi_check.sh b/ipc/chromium/src/third_party/libevent/extra/abi-check/abi_check.sh
new file mode 100755
index 000000000000..e860657e9b1f
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/extra/abi-check/abi_check.sh
@@ -0,0 +1,53 @@
+#!/usr/bin/env bash
+
+# Requirements:
+# - wdiff
+# - rfcdiff
+# - universal-ctags
+# - abi-tracker
+# - abi-monitor
+# - git
+#
+# All of this are included in:
+#   docker.pkg.github.com/azat/docker-images/lvc-debian:latest
+#
+# TODO:
+# - move image into libevent namespace
+
+# verify backward compatibility of API/ABI changes
+
+set -e
+
+LIMIT=${1:-2}
+EVENT_SOURCE_DIR=${EVENT_SOURCE_DIR:-"$(cd "$(dirname "$0")"/../.. && pwd)"}
+ABI_CHECK_ROOT=${ABI_CHECK_ROOT:-$EVENT_SOURCE_DIR/.abi-check}
+ABI_CHECK_WORKSPACE=${ABI_CHECK_WORKSPACE:-"work/abi-check"}
+
+mkdir -p "$ABI_CHECK_ROOT/$ABI_CHECK_WORKSPACE"
+cd "$ABI_CHECK_ROOT/$ABI_CHECK_WORKSPACE"
+
+# copy current source code and profile into workspace
+mkdir -p src/libevent/current
+mkdir -p installed/libevent/current
+( # to avoid cd back
+  cd "$EVENT_SOURCE_DIR"
+  # XXX: not `git archive` since it will not copy changes that are not in index,
+  # and maybe some issues on CI (since it does not contain full clone)
+  find . -maxdepth 1 -mindepth 1 | {
+    git check-ignore --no-index --verbose --non-matching --stdin
+  } | fgrep :: | cut -f2 | grep -v /.git/ | tee /dev/stderr | {
+    xargs cp -r -t "$ABI_CHECK_ROOT/$ABI_CHECK_WORKSPACE/src/libevent/current/"
+  }
+  cp extra/abi-check/libevent.json "$ABI_CHECK_ROOT/$ABI_CHECK_WORKSPACE/"
+)
+
+# run LVC tools
+abi-monitor -get -limit "$LIMIT" libevent.json
+# XXX: abi-monitor 1.12 supports "-make -j8", but 1.10 does not
+# (we can detect which version we have, and add this options)
+abi-monitor -v current -build libevent.json
+abi-monitor -build libevent.json
+abi-tracker -build libevent.json
+
+# remove useless files
+rm -rf src installed build_logs libevent.json
diff --git a/ipc/chromium/src/third_party/libevent/extra/abi-check/libevent.json b/ipc/chromium/src/third_party/libevent/extra/abi-check/libevent.json
new file mode 100644
index 000000000000..42930e933c0b
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/extra/abi-check/libevent.json
@@ -0,0 +1,12 @@
+{
+  "Name":           "libevent",
+  "Title":          "Libevent",
+  "SourceUrl":      "https://github.com/libevent/libevent/tags",
+  "Git":            "https://github.com/libevent/libevent.git",
+  "Maintainer":     "Nick Mathewson, Azat Khuzhin and Niels Provos",
+  "MaintainerUrl":  "https://libevent.org",
+  "BuildSystem":    "Autotools",
+  "HeadersDiff":    "On",
+  "Package":        "release-",
+  "ReleasePattern": "\A([\d\-\.\_]+)(|\-beta|\-rc|\-stable)\Z",
+}
diff --git a/ipc/chromium/src/third_party/libevent/extra/lsan.supp b/ipc/chromium/src/third_party/libevent/extra/lsan.supp
new file mode 100644
index 000000000000..c1b130bf7e9a
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/extra/lsan.supp
@@ -0,0 +1,3 @@
+# TODO: temporary, until tests itself will be fixed
+leak:libcrypto.so
+leak:libssl.so
diff --git a/ipc/chromium/src/third_party/libevent/extra/tsan.supp b/ipc/chromium/src/third_party/libevent/extra/tsan.supp
new file mode 100644
index 000000000000..414a12c16f0b
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/extra/tsan.supp
@@ -0,0 +1,2 @@
+# https://github.com/libevent/libevent/issues/777
+race:event_debug_mode_too_late
diff --git a/ipc/chromium/src/third_party/libevent/http-internal.h b/ipc/chromium/src/third_party/libevent/http-internal.h
index 45555171c2cf..feaf436d7421 100644
--- a/ipc/chromium/src/third_party/libevent/http-internal.h
+++ b/ipc/chromium/src/third_party/libevent/http-internal.h
@@ -18,9 +18,6 @@
 #define HTTP_WRITE_TIMEOUT	50
 #define HTTP_READ_TIMEOUT	50
 
-#define HTTP_PREFIX		"http://"
-#define HTTP_DEFAULTPORT	80
-
 enum message_read_status {
 	ALL_DATA_READ = 1,
 	MORE_DATA_EXPECTED = 0,
@@ -184,12 +181,15 @@ int evhttp_connection_connect_(struct evhttp_connection *);
 
 enum evhttp_request_error;
 /* notifies the current request that it failed; resets connection */
+EVENT2_EXPORT_SYMBOL
 void evhttp_connection_fail_(struct evhttp_connection *,
     enum evhttp_request_error error);
 
 enum message_read_status;
 
+EVENT2_EXPORT_SYMBOL
 enum message_read_status evhttp_parse_firstline_(struct evhttp_request *, struct evbuffer*);
+EVENT2_EXPORT_SYMBOL
 enum message_read_status evhttp_parse_headers_(struct evhttp_request *, struct evbuffer*);
 
 void evhttp_start_read_(struct evhttp_connection *);
@@ -199,7 +199,8 @@ void evhttp_start_write_(struct evhttp_connection *);
 void evhttp_response_code_(struct evhttp_request *, int, const char *);
 void evhttp_send_page_(struct evhttp_request *, struct evbuffer *);
 
+EVENT2_EXPORT_SYMBOL
 int evhttp_decode_uri_internal(const char *uri, size_t length,
     char *ret, int decode_plus);
 
-#endif /* _HTTP_H */
+#endif /* HTTP_INTERNAL_H_INCLUDED_ */
diff --git a/ipc/chromium/src/third_party/libevent/http.c b/ipc/chromium/src/third_party/libevent/http.c
index f5a2ef931a5f..04f089bc0182 100644
--- a/ipc/chromium/src/third_party/libevent/http.c
+++ b/ipc/chromium/src/third_party/libevent/http.c
@@ -51,9 +51,16 @@
 #ifndef _WIN32
 #include <sys/socket.h>
 #include <sys/stat.h>
-#else
+#else /* _WIN32 */
 #include <winsock2.h>
 #include <ws2tcpip.h>
+#endif /* _WIN32 */
+
+#ifdef EVENT__HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+#ifdef EVENT__HAVE_AFUNIX_H
+#include <afunix.h>
 #endif
 
 #include <sys/queue.h>
@@ -78,7 +85,7 @@
 #include <string.h>
 #ifndef _WIN32
 #include <syslog.h>
-#endif
+#endif /* !_WIN32 */
 #include <signal.h>
 #ifdef EVENT__HAVE_UNISTD_H
 #include <unistd.h>
@@ -170,9 +177,10 @@ fake_getnameinfo(const struct sockaddr *sa, size_t salen, char *host,
 
 extern int debug;
 
-static evutil_socket_t bind_socket_ai(struct evutil_addrinfo *, int reuse);
+static evutil_socket_t create_bind_socket_nonblock(struct evutil_addrinfo *, int reuse);
 static evutil_socket_t bind_socket(const char *, ev_uint16_t, int reuse);
 static void name_from_addr(struct sockaddr *, ev_socklen_t, char **, char **);
+static struct evhttp_uri *evhttp_uri_parse_authority(char *source_uri);
 static int evhttp_associate_new_request_with_connection(
 	struct evhttp_connection *evcon);
 static void evhttp_connection_start_detectclose(
@@ -350,6 +358,7 @@ evhttp_response_needs_body(struct evhttp_request *req)
 	return (req->response_code != HTTP_NOCONTENT &&
 		req->response_code != HTTP_NOTMODIFIED &&
 		(req->response_code < 100 || req->response_code >= 200) &&
+		req->type != EVHTTP_REQ_CONNECT &&
 		req->type != EVHTTP_REQ_HEAD);
 }
 
@@ -368,15 +377,15 @@ evhttp_write_buffer(struct evhttp_connection *evcon,
 	evcon->cb_arg = arg;
 
 	/* Disable the read callback: we don't actually care about data;
-	 * we only care about close detection.  (We don't disable reading,
-	 * since we *do* want to learn about any close events.) */
+	 * we only care about close detection. (We don't disable reading --
+	 * EV_READ, since we *do* want to learn about any close events.) */
 	bufferevent_setcb(evcon->bufev,
 	    NULL, /*read*/
 	    evhttp_write_cb,
 	    evhttp_error_cb,
 	    evcon);
 
-	bufferevent_enable(evcon->bufev, EV_WRITE);
+	bufferevent_enable(evcon->bufev, EV_READ|EV_WRITE);
 }
 
 static void
@@ -470,6 +479,9 @@ evhttp_is_connection_close(int flags, struct evkeyvalq* headers)
 static int
 evhttp_is_request_connection_close(struct evhttp_request *req)
 {
+	if (req->type == EVHTTP_REQ_CONNECT)
+		return 0;
+
 	return
 		evhttp_is_connection_close(req->flags, req->input_headers) ||
 		evhttp_is_connection_close(req->flags, req->output_headers);
@@ -770,6 +782,11 @@ evhttp_connection_fail_(struct evhttp_connection *evcon,
 	/* We are trying the next request that was queued on us */
 	if (TAILQ_FIRST(&evcon->requests) != NULL)
 		evhttp_connection_connect_(evcon);
+	else
+		if ((evcon->flags & EVHTTP_CON_OUTGOING) &&
+		    (evcon->flags & EVHTTP_CON_AUTOFREE)) {
+			evhttp_connection_free(evcon);
+		}
 
 	/* The call to evhttp_connection_reset_ overwrote errno.
 	 * Let's restore the original errno, so that the user's
@@ -1170,7 +1187,9 @@ static void
 evhttp_deferred_read_cb(struct event_callback *cb, void *data)
 {
 	struct evhttp_connection *evcon = data;
-	evhttp_read_cb(evcon->bufev, evcon);
+	struct bufferevent *bev = evcon->bufev;
+	if (bev->readcb)
+		(bev->readcb)(evcon->bufev, evcon);
 }
 
 static void
@@ -1202,6 +1221,7 @@ void
 evhttp_connection_free(struct evhttp_connection *evcon)
 {
 	struct evhttp_request *req;
+	int need_close = 0;
 
 	/* notify interested parties that this connection is going down */
 	if (evcon->fd != -1) {
@@ -1228,21 +1248,22 @@ evhttp_connection_free(struct evhttp_connection *evcon)
 		event_debug_unassign(&evcon->retry_ev);
 	}
 
-	if (evcon->bufev != NULL)
-		bufferevent_free(evcon->bufev);
-
 	event_deferred_cb_cancel_(get_deferred_queue(evcon),
 	    &evcon->read_more_deferred_cb);
 
-	if (evcon->fd == -1)
-		evcon->fd = bufferevent_getfd(evcon->bufev);
+	if (evcon->bufev != NULL) {
+		need_close =
+			!(bufferevent_get_options_(evcon->bufev) & BEV_OPT_CLOSE_ON_FREE);
+		if (evcon->fd == -1)
+			evcon->fd = bufferevent_getfd(evcon->bufev);
+
+		bufferevent_free(evcon->bufev);
+	}
 
 	if (evcon->fd != -1) {
-		bufferevent_disable(evcon->bufev, EV_READ|EV_WRITE);
 		shutdown(evcon->fd, EVUTIL_SHUT_WR);
-		if (!(bufferevent_get_options_(evcon->bufev) & BEV_OPT_CLOSE_ON_FREE)) {
+		if (need_close)
 			evutil_closesocket(evcon->fd);
-		}
 	}
 
 	if (evcon->bind_address != NULL)
@@ -1287,6 +1308,8 @@ evhttp_request_dispatch(struct evhttp_connection* evcon)
 	if (req == NULL)
 		return;
 
+	EVUTIL_ASSERT(req->kind == EVHTTP_REQUEST);
+
 	/* delete possible close detection events */
 	evhttp_connection_stop_detectclose(evcon);
 
@@ -1309,6 +1332,8 @@ evhttp_connection_reset_(struct evhttp_connection *evcon)
 	struct evbuffer *tmp;
 	int err;
 
+	bufferevent_setcb(evcon->bufev, NULL, NULL, NULL, NULL);
+
 	/* XXXX This is not actually an optimal fix.  Instead we ought to have
 	   an API for "stop connecting", or use bufferevent_setfd to turn off
 	   connecting.  But for Libevent 2.0, this seems like a minimal change
@@ -1334,7 +1359,8 @@ evhttp_connection_reset_(struct evhttp_connection *evcon)
 		evutil_closesocket(evcon->fd);
 		evcon->fd = -1;
 	}
-	bufferevent_setfd(evcon->bufev, -1);
+	err = bufferevent_setfd(evcon->bufev, -1);
+	EVUTIL_ASSERT(!err && "setfd");
 
 	/* we need to clean up any buffered data */
 	tmp = bufferevent_get_output(evcon->bufev);
@@ -1353,7 +1379,6 @@ static void
 evhttp_connection_start_detectclose(struct evhttp_connection *evcon)
 {
 	evcon->flags |= EVHTTP_CON_CLOSEDETECT;
-
 	bufferevent_enable(evcon->bufev, EV_READ);
 }
 
@@ -1361,7 +1386,6 @@ static void
 evhttp_connection_stop_detectclose(struct evhttp_connection *evcon)
 {
 	evcon->flags &= ~EVHTTP_CON_CLOSEDETECT;
-
 	bufferevent_disable(evcon->bufev, EV_READ);
 }
 
@@ -1526,6 +1550,14 @@ evhttp_error_cb(struct bufferevent *bufev, short what, void *arg)
 			return;
 		}
 
+		if (what & BEV_EVENT_READING &&
+			evcon->flags & EVHTTP_CON_READ_ON_WRITE_ERROR &&
+			evbuffer_get_length(bufferevent_get_input(bufev))) {
+			event_deferred_cb_schedule_(get_deferred_queue(evcon),
+			    &evcon->read_more_deferred_cb);
+			return;
+		}
+
 		evhttp_connection_fail_(evcon, EVREQ_HTTP_EOF);
 	} else if (what == BEV_EVENT_CONNECTED) {
 	} else {
@@ -1683,8 +1715,9 @@ evhttp_parse_response_line(struct evhttp_request *req, char *line)
 /* Parse the first line of a HTTP request */
 
 static int
-evhttp_parse_request_line(struct evhttp_request *req, char *line)
+evhttp_parse_request_line(struct evhttp_request *req, char *line, size_t len)
 {
+	char *eos = line + len;
 	char *method;
 	char *uri;
 	char *version;
@@ -1693,16 +1726,24 @@ evhttp_parse_request_line(struct evhttp_request *req, char *line)
 	size_t method_len;
 	enum evhttp_cmd_type type;
 
+	while (eos > line && *(eos-1) == ' ') {
+		*(eos-1) = '\0';
+		--eos;
+		--len;
+	}
+	if (len < strlen("GET / HTTP/1.0"))
+		return -1;
+
 	/* Parse the request line */
 	method = strsep(&line, " ");
-	if (line == NULL)
-		return (-1);
-	uri = strsep(&line, " ");
-	if (line == NULL)
-		return (-1);
-	version = strsep(&line, " ");
-	if (line != NULL)
-		return (-1);
+	if (!line)
+		return -1;
+	uri = line;
+	version = strrchr(uri, ' ');
+	if (!version || uri == version)
+		return -1;
+	*version = '\0';
+	version++;
 
 	method_len = (uri - method) - 1;
 	type       = EVHTTP_REQ_UNKNOWN_;
@@ -1822,16 +1863,22 @@ evhttp_parse_request_line(struct evhttp_request *req, char *line)
 	req->type = type;
 
 	if (evhttp_parse_http_version(version, req) < 0)
-		return (-1);
+		return -1;
 
 	if ((req->uri = mm_strdup(uri)) == NULL) {
 		event_debug(("%s: mm_strdup", __func__));
-		return (-1);
+		return -1;
 	}
 
-	if ((req->uri_elems = evhttp_uri_parse_with_flags(req->uri,
-		    EVHTTP_URI_NONCONFORMANT)) == NULL) {
-		return -1;
+	if (type == EVHTTP_REQ_CONNECT) {
+		if ((req->uri_elems = evhttp_uri_parse_authority(req->uri)) == NULL) {
+			return -1;
+		}
+	} else {
+		if ((req->uri_elems = evhttp_uri_parse_with_flags(req->uri,
+			    EVHTTP_URI_NONCONFORMANT)) == NULL) {
+			return -1;
+		}
 	}
 
 	/* If we have an absolute-URI, check to see if it is an http request
@@ -1845,7 +1892,7 @@ evhttp_parse_request_line(struct evhttp_request *req, char *line)
 	    !evhttp_find_vhost(req->evcon->http_server, NULL, hostname))
 		req->flags |= EVHTTP_PROXY_REQUEST;
 
-	return (0);
+	return 0;
 }
 
 const char *
@@ -1980,9 +2027,9 @@ evhttp_parse_firstline_(struct evhttp_request *req, struct evbuffer *buffer)
 	char *line;
 	enum message_read_status status = ALL_DATA_READ;
 
-	size_t line_length;
+	size_t len;
 	/* XXX try */
-	line = evbuffer_readln(buffer, &line_length, EVBUFFER_EOL_CRLF);
+	line = evbuffer_readln(buffer, &len, EVBUFFER_EOL_CRLF);
 	if (line == NULL) {
 		if (req->evcon != NULL &&
 		    evbuffer_get_length(buffer) > req->evcon->max_headers_size)
@@ -1991,17 +2038,16 @@ evhttp_parse_firstline_(struct evhttp_request *req, struct evbuffer *buffer)
 			return (MORE_DATA_EXPECTED);
 	}
 
-	if (req->evcon != NULL &&
-	    line_length > req->evcon->max_headers_size) {
+	if (req->evcon != NULL && len > req->evcon->max_headers_size) {
 		mm_free(line);
 		return (DATA_TOO_LONG);
 	}
 
-	req->headers_size = line_length;
+	req->headers_size = len;
 
 	switch (req->kind) {
 	case EVHTTP_REQUEST:
-		if (evhttp_parse_request_line(req, line) == -1)
+		if (evhttp_parse_request_line(req, line, len) == -1)
 			status = DATA_CORRUPTED;
 		break;
 	case EVHTTP_RESPONSE:
@@ -2054,12 +2100,12 @@ evhttp_parse_headers_(struct evhttp_request *req, struct evbuffer* buffer)
 	enum message_read_status status = MORE_DATA_EXPECTED;
 
 	struct evkeyvalq* headers = req->input_headers;
-	size_t line_length;
-	while ((line = evbuffer_readln(buffer, &line_length, EVBUFFER_EOL_CRLF))
+	size_t len;
+	while ((line = evbuffer_readln(buffer, &len, EVBUFFER_EOL_CRLF))
 	       != NULL) {
 		char *skey, *svalue;
 
-		req->headers_size += line_length;
+		req->headers_size += len;
 
 		if (req->evcon != NULL &&
 		    req->headers_size > req->evcon->max_headers_size) {
@@ -2123,11 +2169,7 @@ evhttp_get_body_length(struct evhttp_request *req)
 		req->ntoread = -1;
 	else if (content_length == NULL &&
 	    evutil_ascii_strcasecmp(connection, "Close") != 0) {
-		/* Bad combination, we don't know when it will end */
-		event_warnx("%s: we got no content length, but the "
-		    "server wants to keep the connection open: %s.",
-		    __func__, connection);
-		return (-1);
+		req->ntoread = 0;
 	} else if (content_length == NULL) {
 		req->ntoread = -1;
 	} else {
@@ -2155,16 +2197,15 @@ evhttp_method_may_have_body(enum evhttp_cmd_type type)
 	case EVHTTP_REQ_POST:
 	case EVHTTP_REQ_PUT:
 	case EVHTTP_REQ_PATCH:
-		return 1;
-	case EVHTTP_REQ_TRACE:
-		return 0;
-	/* XXX May any of the below methods have a body? */
+
 	case EVHTTP_REQ_GET:
-	case EVHTTP_REQ_HEAD:
 	case EVHTTP_REQ_DELETE:
 	case EVHTTP_REQ_OPTIONS:
 	case EVHTTP_REQ_CONNECT:
-		return 0;
+		return 1;
+
+	case EVHTTP_REQ_TRACE:
+	case EVHTTP_REQ_HEAD:
 	default:
 		return 0;
 	}
@@ -2544,9 +2585,11 @@ evhttp_connection_connect_(struct evhttp_connection *evcon)
 			return (-1);
 		}
 
-		bufferevent_setfd(evcon->bufev, evcon->fd);
+		if (bufferevent_setfd(evcon->bufev, evcon->fd))
+			return (-1);
 	} else {
-		bufferevent_setfd(evcon->bufev, -1);
+		if (bufferevent_setfd(evcon->bufev, -1))
+			return (-1);
 	}
 
 	/* Set up a callback for successful connection setup */
@@ -2562,7 +2605,8 @@ evhttp_connection_connect_(struct evhttp_connection *evcon)
 		bufferevent_set_timeouts(evcon->bufev, &evcon->timeout, &evcon->timeout);
 	}
 	/* make sure that we get a write callback */
-	bufferevent_enable(evcon->bufev, EV_WRITE);
+	if (bufferevent_enable(evcon->bufev, EV_WRITE))
+		return (-1);
 
 	evcon->state = EVCON_CONNECTING;
 
@@ -2628,6 +2672,10 @@ evhttp_make_request(struct evhttp_connection *evcon,
 
 	TAILQ_INSERT_TAIL(&evcon->requests, req, next);
 
+	/* We do not want to conflict with retry_ev */
+	if (evcon->retry_cnt)
+		return (0);
+
 	/* If the connection object is not connected; make it so */
 	if (!evhttp_connected(evcon)) {
 		int res = evhttp_connection_connect_(evcon);
@@ -2638,7 +2686,7 @@ evhttp_make_request(struct evhttp_connection *evcon,
 		if (res != 0)
 			TAILQ_REMOVE(&evcon->requests, req, next);
 
-		return res;
+		return (res);
 	}
 
 	/*
@@ -2820,6 +2868,10 @@ evhttp_send_reply_start(struct evhttp_request *req, int code,
     const char *reason)
 {
 	evhttp_response_code_(req, code, reason);
+
+	if (req->evcon == NULL)
+		return;
+
 	if (evhttp_find_header(req->output_headers, "Content-Length") == NULL &&
 	    REQ_VERSION_ATLEAST(req, 1, 1) &&
 	    evhttp_response_needs_body(req)) {
@@ -3059,16 +3111,15 @@ evhttp_uriencode(const char *uri, ev_ssize_t len, int space_as_plus)
 {
 	struct evbuffer *buf = evbuffer_new();
 	const char *p, *end;
-	char *result;
+	char *result = NULL;
 
-	if (buf == NULL) {
-		return (NULL);
+	if (!buf) {
+		goto out;
 	}
 
-
 	if (len >= 0) {
 		if (uri + len < uri) {
-			return (NULL);
+			goto out;
 		}
 
 		end = uri + len;
@@ -3077,11 +3128,11 @@ evhttp_uriencode(const char *uri, ev_ssize_t len, int space_as_plus)
 
 		if (slen >= EV_SSIZE_MAX) {
 			/* we don't want to mix signed and unsigned */
-			return (NULL);
+			goto out;
 		}
 
 		if (uri + slen < uri) {
-			return (NULL);
+			goto out;
 		}
 
 		end = uri + slen;
@@ -3103,9 +3154,10 @@ evhttp_uriencode(const char *uri, ev_ssize_t len, int space_as_plus)
 	if (result)
 		evbuffer_remove(buf, result, evbuffer_get_length(buf));
 
-	evbuffer_free(buf);
-
-	return (result);
+out:
+	if (buf)
+		evbuffer_free(buf);
+	return result;
 }
 
 char *
@@ -3234,6 +3286,7 @@ evhttp_parse_query_impl(const char *str, struct evkeyvalq *headers,
 	p = argument = line;
 	while (p != NULL && *p != '\0') {
 		char *key, *value, *decoded_value;
+		int err;
 		argument = strsep(&p, "&");
 
 		value = argument;
@@ -3249,8 +3302,10 @@ evhttp_parse_query_impl(const char *str, struct evkeyvalq *headers,
 		evhttp_decode_uri_internal(value, strlen(value),
 		    decoded_value, 1 /*always_decode_plus*/);
 		event_debug(("Query Param: %s -> %s\n", key, decoded_value));
-		evhttp_add_header_internal(headers, key, decoded_value);
+		err = evhttp_add_header_internal(headers, key, decoded_value);
 		mm_free(decoded_value);
+		if (err)
+			goto error;
 	}
 
 	result = 0;
@@ -3416,6 +3471,8 @@ evhttp_handle_request(struct evhttp_request *req, void *arg)
 	/* we have a new request on which the user needs to take action */
 	req->userdone = 0;
 
+	bufferevent_disable(req->evcon->bufev, EV_READ);
+
 	if (req->type == 0 || req->uri == NULL) {
 		evhttp_send_error(req, req->response_code, NULL);
 		return;
@@ -3503,13 +3560,16 @@ evhttp_bind_socket_with_handle(struct evhttp *http, const char *address, ev_uint
 {
 	evutil_socket_t fd;
 	struct evhttp_bound_socket *bound;
+	int serrno;
 
 	if ((fd = bind_socket(address, port, 1 /*reuse*/)) == -1)
 		return (NULL);
 
 	if (listen(fd, 128) == -1) {
+		serrno = EVUTIL_SOCKET_ERROR();
 		event_sock_warn(fd, "%s: listen", __func__);
 		evutil_closesocket(fd);
+		EVUTIL_SET_SOCKET_ERROR(serrno);
 		return (NULL);
 	}
 
@@ -4169,6 +4229,13 @@ evhttp_get_request_connection(
 	char *hostname = NULL, *portname = NULL;
 	struct bufferevent* bev = NULL;
 
+#ifdef EVENT__HAVE_STRUCT_SOCKADDR_UN
+	if (sa->sa_family == AF_UNIX) {
+		struct sockaddr_un *sa_un = (struct sockaddr_un *)sa;
+		sa_un->sun_path[0] = '\0';
+	}
+#endif
+
 	name_from_addr(sa, salen, &hostname, &portname);
 	if (hostname == NULL || portname == NULL) {
 		if (hostname) mm_free(hostname);
@@ -4200,11 +4267,19 @@ evhttp_get_request_connection(
 
 	evcon->fd = fd;
 
-	bufferevent_enable(evcon->bufev, EV_READ);
-	bufferevent_disable(evcon->bufev, EV_WRITE);
-	bufferevent_setfd(evcon->bufev, fd);
+	if (bufferevent_setfd(evcon->bufev, fd))
+		goto err;
+	if (bufferevent_enable(evcon->bufev, EV_READ))
+		goto err;
+	if (bufferevent_disable(evcon->bufev, EV_WRITE))
+		goto err;
+	bufferevent_socket_set_conn_address_(evcon->bufev, sa, salen);
 
 	return (evcon);
+
+err:
+	evhttp_connection_free(evcon);
+	return (NULL);
 }
 
 static int
@@ -4313,9 +4388,8 @@ name_from_addr(struct sockaddr *sa, ev_socklen_t salen,
 }
 
 /* Create a non-blocking socket and bind it */
-/* todo: rename this function */
 static evutil_socket_t
-bind_socket_ai(struct evutil_addrinfo *ai, int reuse)
+create_bind_socket_nonblock(struct evutil_addrinfo *ai, int reuse)
 {
 	evutil_socket_t fd;
 
@@ -4389,14 +4463,14 @@ bind_socket(const char *address, ev_uint16_t port, int reuse)
 
 	/* just create an unbound socket */
 	if (address == NULL && port == 0)
-		return bind_socket_ai(NULL, 0);
+		return create_bind_socket_nonblock(NULL, 0);
 
 	aitop = make_addrinfo(address, port);
 
 	if (aitop == NULL)
 		return (-1);
 
-	fd = bind_socket_ai(aitop, reuse);
+	fd = create_bind_socket_nonblock(aitop, reuse);
 
 	evutil_freeaddrinfo(aitop);
 
@@ -4821,6 +4895,36 @@ err:
 	return NULL;
 }
 
+static struct evhttp_uri *
+evhttp_uri_parse_authority(char *source_uri)
+{
+	struct evhttp_uri *uri = mm_calloc(1, sizeof(struct evhttp_uri));
+	char *end;
+
+	if (uri == NULL) {
+		event_warn("%s: calloc", __func__);
+		goto err;
+	}
+	uri->port = -1;
+	uri->flags = 0;
+
+	end = end_of_authority(source_uri);
+	if (parse_authority(uri, source_uri, end) < 0)
+		goto err;
+
+	uri->path = mm_strdup("");
+	if (uri->path == NULL) {
+		event_warn("%s: strdup", __func__);
+		goto err;
+	}
+
+	return uri;
+err:
+	if (uri)
+		evhttp_uri_free(uri);
+	return NULL;
+}
+
 void
 evhttp_uri_free(struct evhttp_uri *uri)
 {
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/buffer.h b/ipc/chromium/src/third_party/libevent/include/event2/buffer.h
index 468588b9f141..88af3ae141b1 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/buffer.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/buffer.h
@@ -726,7 +726,8 @@ int evbuffer_write_atmost(struct evbuffer *buffer, evutil_socket_t fd,
 
   @param buffer the evbuffer to store the result
   @param fd the file descriptor to read from
-  @param howmuch the number of bytes to be read
+  @param howmuch the number of bytes to be read. If the given number is negative
+  or out of maximum bytes per one read, as many bytes as we can will be read.
   @return the number of bytes read, or -1 if an error occurred
   @see evbuffer_write()
  */
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/buffer_compat.h b/ipc/chromium/src/third_party/libevent/include/event2/buffer_compat.h
index 24f828c21033..0ce10254487d 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/buffer_compat.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/buffer_compat.h
@@ -90,9 +90,10 @@ typedef void (*evbuffer_cb)(struct evbuffer *buffer, size_t old_len, size_t new_
   @param cb the callback function to invoke when the evbuffer is modified,
 	 or NULL to remove all callbacks.
   @param cbarg an argument to be provided to the callback function
+  @return 0 if successful, or -1 on error
  */
 EVENT2_EXPORT_SYMBOL
-void evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg);
+int evbuffer_setcb(struct evbuffer *buffer, evbuffer_cb cb, void *cbarg);
 
 
 /**
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/bufferevent.h b/ipc/chromium/src/third_party/libevent/include/event2/bufferevent.h
index 825918e3a452..48cd153563bb 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/bufferevent.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/bufferevent.h
@@ -491,7 +491,7 @@ short bufferevent_get_enabled(struct bufferevent *bufev);
 
   (In other words, if reading or writing is disabled, or if the
   bufferevent's read or write operation has been suspended because
-  there's no data to write, or not enough banwidth, or so on, the
+  there's no data to write, or not enough bandwidth, or so on, the
   timeout isn't active.  The timeout only becomes active when we we're
   willing to actually read or write.)
 
@@ -518,6 +518,9 @@ int bufferevent_set_timeouts(struct bufferevent *bufev,
   On input, a bufferevent does not invoke the user read callback unless
   there is at least low watermark data in the buffer.	If the read buffer
   is beyond the high watermark, the bufferevent stops reading from the network.
+  But be aware that bufferevent input/read buffer can overrun high watermark
+  limit (typical example is openssl bufferevent), so you should not relay in
+  this.
 
   On output, the user write callback is invoked whenever the buffered data
   falls below the low watermark.  Filters that write to this bufev will try
@@ -566,7 +569,7 @@ void bufferevent_unlock(struct bufferevent *bufev);
 /**
  * Public interface to manually increase the reference count of a bufferevent
  * this is useful in situations where a user may reference the bufferevent
- * somewhere eles (unknown to libevent)
+ * somewhere else (unknown to libevent)
  *
  * @param bufev the bufferevent to increase the refcount on
  *
@@ -799,7 +802,7 @@ void ev_token_bucket_cfg_free(struct ev_token_bucket_cfg *cfg);
    They are: socket-based bufferevents (normal and IOCP-based), and SSL-based
    bufferevents.
 
-   Return 0 on sucess, -1 on failure.
+   Return 0 on success, -1 on failure.
  */
 EVENT2_EXPORT_SYMBOL
 int bufferevent_set_rate_limit(struct bufferevent *bev,
@@ -850,7 +853,7 @@ int bufferevent_rate_limit_group_set_cfg(
 
    The default min-share is currently 64 bytes.
 
-   Returns 0 on success, -1 on faulre.
+   Returns 0 on success, -1 on failure.
  */
 EVENT2_EXPORT_SYMBOL
 int bufferevent_rate_limit_group_set_min_share(
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/bufferevent_compat.h b/ipc/chromium/src/third_party/libevent/include/event2/bufferevent_compat.h
index 65482042f9d1..a5a3c7207d64 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/bufferevent_compat.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/bufferevent_compat.h
@@ -28,6 +28,8 @@
 #ifndef EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_
 #define EVENT2_BUFFEREVENT_COMPAT_H_INCLUDED_
 
+#include <event2/visibility.h>
+
 #define evbuffercb bufferevent_data_cb
 #define everrorcb bufferevent_event_cb
 
@@ -72,6 +74,7 @@
 	  error occurred
   @see bufferevent_base_set(), bufferevent_free()
   */
+EVENT2_EXPORT_SYMBOL
 struct bufferevent *bufferevent_new(evutil_socket_t fd,
     evbuffercb readcb, evbuffercb writecb, everrorcb errorcb, void *cbarg);
 
@@ -83,6 +86,7 @@ struct bufferevent *bufferevent_new(evutil_socket_t fd,
   @param timeout_read the read timeout
   @param timeout_write the write timeout
  */
+EVENT2_EXPORT_SYMBOL
 void bufferevent_settimeout(struct bufferevent *bufev,
     int timeout_read, int timeout_write);
 
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/dns.h b/ipc/chromium/src/third_party/libevent/include/event2/dns.h
index 17cd86a2ec2d..13ce027e4a8c 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/dns.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/dns.h
@@ -179,11 +179,39 @@ extern "C" {
 
 #define DNS_QUERY_NO_SEARCH 1
 
+/* Allow searching */
 #define DNS_OPTION_SEARCH 1
+/* Parse "nameserver" and add default if no such section */
 #define DNS_OPTION_NAMESERVERS 2
+/* Parse additional options like:
+ * - timeout:
+ * - getaddrinfo-allow-skew:
+ * - max-timeouts:
+ * - max-inflight:
+ * - attempts:
+ * - randomize-case:
+ * - initial-probe-timeout:
+ */
 #define DNS_OPTION_MISC 4
+/* Load hosts file (i.e. "/etc/hosts") */
 #define DNS_OPTION_HOSTSFILE 8
-#define DNS_OPTIONS_ALL 15
+/**
+ * All above:
+ * - DNS_OPTION_SEARCH
+ * - DNS_OPTION_NAMESERVERS
+ * - DNS_OPTION_MISC
+ * - DNS_OPTION_HOSTSFILE
+ */
+#define DNS_OPTIONS_ALL (    \
+    DNS_OPTION_SEARCH      | \
+    DNS_OPTION_NAMESERVERS | \
+    DNS_OPTION_MISC        | \
+    DNS_OPTION_HOSTSFILE   | \
+    0                        \
+)
+/* Do not "default" nameserver (i.e. "127.0.0.1:53") if there is no nameservers
+ * in resolv.conf, (iff DNS_OPTION_NAMESERVERS is set) */
+#define DNS_OPTION_NAMESERVERS_NO_DEFAULT 16
 
 /* Obsolete name for DNS_QUERY_NO_SEARCH */
 #define DNS_NO_SEARCH DNS_QUERY_NO_SEARCH
@@ -208,6 +236,10 @@ struct event_base;
 /** Flag for evdns_base_new: Do not prevent the libevent event loop from
  * exiting when we have no active dns requests. */
 #define EVDNS_BASE_DISABLE_WHEN_INACTIVE 0x8000
+/** Flag for evdns_base_new: If EVDNS_BASE_INITIALIZE_NAMESERVERS isset, do not
+ * add default nameserver if there are no nameservers in resolv.conf
+ * @see DNS_OPTION_NAMESERVERS_NO_DEFAULT */
+#define EVDNS_BASE_NAMESERVERS_NO_DEFAULT 0x10000
 
 /**
   Initialize the asynchronous DNS library.
@@ -218,7 +250,7 @@ struct event_base;
 
   @param event_base the event base to associate the dns client with
   @param flags any of EVDNS_BASE_INITIALIZE_NAMESERVERS|
-    EVDNS_BASE_DISABLE_WHEN_INACTIVE
+    EVDNS_BASE_DISABLE_WHEN_INACTIVE|EVDNS_BASE_NAMESERVERS_NO_DEFAULT
   @return evdns_base object if successful, or NULL if an error occurred.
   @see evdns_base_free()
  */
@@ -423,7 +455,8 @@ void evdns_cancel_request(struct evdns_base *base, struct evdns_request *req);
   The currently available configuration options are:
 
     ndots, timeout, max-timeouts, max-inflight, attempts, randomize-case,
-    bind-to, initial-probe-timeout, getaddrinfo-allow-skew.
+    bind-to, initial-probe-timeout, getaddrinfo-allow-skew,
+    so-rcvbuf, so-sndbuf.
 
   In versions before Libevent 2.0.3-alpha, the option name needed to end with
   a colon.
@@ -453,7 +486,7 @@ int evdns_base_set_option(struct evdns_base *base, const char *option, const cha
 
   @param base the evdns_base to which to apply this operation
   @param flags any of DNS_OPTION_NAMESERVERS|DNS_OPTION_SEARCH|DNS_OPTION_MISC|
-    DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL
+    DNS_OPTION_HOSTSFILE|DNS_OPTIONS_ALL|DNS_OPTION_NAMESERVERS_NO_DEFAULT
   @param filename the path to the resolv.conf file
   @return 0 if successful, or various positive error codes if an error
     occurred (see above)
@@ -478,6 +511,7 @@ int evdns_base_resolv_conf_parse(struct evdns_base *base, int flags, const char
 EVENT2_EXPORT_SYMBOL
 int evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname);
 
+#if defined(EVENT_IN_DOXYGEN_) || defined(_WIN32)
 /**
   Obtain nameserver information using the Windows API.
 
@@ -488,7 +522,6 @@ int evdns_base_load_hosts(struct evdns_base *base, const char *hosts_fname);
   @return 0 if successful, or -1 if an error occurred
   @see evdns_resolv_conf_parse()
  */
-#ifdef _WIN32
 EVENT2_EXPORT_SYMBOL
 int evdns_base_config_windows_nameservers(struct evdns_base *);
 #define EVDNS_BASE_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
@@ -615,7 +648,8 @@ typedef void (*evdns_request_callback_fn_type)(struct evdns_server_request *, vo
     @param callback A function to invoke whenever we get a DNS request
       on the socket.
     @param user_data Data to pass to the callback.
-    @return an evdns_server_port structure for this server port.
+    @return an evdns_server_port structure for this server port or NULL if
+      an error occurred.
  */
 EVENT2_EXPORT_SYMBOL
 struct evdns_server_port *evdns_add_server_port_with_base(struct event_base *base, evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/dns_compat.h b/ipc/chromium/src/third_party/libevent/include/event2/dns_compat.h
index 965fd65445b4..a58c4b29375e 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/dns_compat.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/dns_compat.h
@@ -49,6 +49,7 @@ extern "C" {
 
 /* For int types. */
 #include <event2/util.h>
+#include <event2/visibility.h>
 
 /**
   Initialize the asynchronous DNS library.
@@ -66,6 +67,7 @@ extern "C" {
   @return 0 if successful, or -1 if an error occurred
   @see evdns_shutdown()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_init(void);
 
 struct evdns_base;
@@ -76,6 +78,7 @@ struct evdns_base;
    @deprecated This function is deprecated because use of the global
      evdns_base is error-prone.
  */
+EVENT2_EXPORT_SYMBOL
 struct evdns_base *evdns_get_global_base(void);
 
 /**
@@ -93,6 +96,7 @@ struct evdns_base *evdns_get_global_base(void);
 		active requests will return DNS_ERR_SHUTDOWN.
   @see evdns_init()
  */
+EVENT2_EXPORT_SYMBOL
 void evdns_shutdown(int fail_requests);
 
 /**
@@ -109,6 +113,7 @@ void evdns_shutdown(int fail_requests);
   @return 0 if successful, or -1 if an error occurred
   @see evdns_nameserver_ip_add()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_nameserver_add(unsigned long int address);
 
 /**
@@ -126,6 +131,7 @@ int evdns_nameserver_add(unsigned long int address);
   @return the number of configured nameservers
   @see evdns_nameserver_add()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_count_nameservers(void);
 
 /**
@@ -140,6 +146,7 @@ int evdns_count_nameservers(void);
   @return 0 if successful, or -1 if an error occurred
   @see evdns_resume()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_clear_nameservers_and_suspend(void);
 
 /**
@@ -155,6 +162,7 @@ int evdns_clear_nameservers_and_suspend(void);
   @return 0 if successful, or -1 if an error occurred
   @see evdns_clear_nameservers_and_suspend()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_resume(void);
 
 /**
@@ -170,6 +178,7 @@ int evdns_resume(void);
   @return 0 if successful, or -1 if an error occurred
   @see evdns_nameserver_add()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_nameserver_ip_add(const char *ip_as_string);
 
 /**
@@ -186,6 +195,7 @@ int evdns_nameserver_ip_add(const char *ip_as_string);
   @return 0 if successful, or -1 if an error occurred
   @see evdns_resolve_ipv6(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_resolve_ipv4(const char *name, int flags, evdns_callback_type callback, void *ptr);
 
 /**
@@ -198,6 +208,7 @@ int evdns_resolve_ipv4(const char *name, int flags, evdns_callback_type callback
   @return 0 if successful, or -1 if an error occurred
   @see evdns_resolve_ipv4(), evdns_resolve_reverse(), evdns_resolve_reverse_ipv6()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_resolve_ipv6(const char *name, int flags, evdns_callback_type callback, void *ptr);
 
 struct in_addr;
@@ -217,6 +228,7 @@ struct in6_addr;
   @return 0 if successful, or -1 if an error occurred
   @see evdns_resolve_reverse_ipv6()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_type callback, void *ptr);
 
 /**
@@ -233,6 +245,7 @@ int evdns_resolve_reverse(const struct in_addr *in, int flags, evdns_callback_ty
   @return 0 if successful, or -1 if an error occurred
   @see evdns_resolve_reverse_ipv6()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callback_type callback, void *ptr);
 
 /**
@@ -251,6 +264,7 @@ int evdns_resolve_reverse_ipv6(const struct in6_addr *in, int flags, evdns_callb
   @param flags Ignored.
   @return 0 if successful, or -1 if an error occurred
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_set_option(const char *option, const char *val, int flags);
 
 /**
@@ -278,6 +292,7 @@ int evdns_set_option(const char *option, const char *val, int flags);
     occurred (see above)
   @see resolv.conf(3), evdns_config_windows_nameservers()
  */
+EVENT2_EXPORT_SYMBOL
 int evdns_resolv_conf_parse(int flags, const char *const filename);
 
 /**
@@ -287,6 +302,7 @@ int evdns_resolv_conf_parse(int flags, const char *const filename);
     caller to specify which evdns_base it applies to.  The recommended
     function is evdns_base_search_clear().
  */
+EVENT2_EXPORT_SYMBOL
 void evdns_search_clear(void);
 
 /**
@@ -298,6 +314,7 @@ void evdns_search_clear(void);
 
   @param domain the domain to be added to the search list
  */
+EVENT2_EXPORT_SYMBOL
 void evdns_search_add(const char *domain);
 
 /**
@@ -312,6 +329,7 @@ void evdns_search_add(const char *domain);
 
   @param ndots the new ndots parameter
  */
+EVENT2_EXPORT_SYMBOL
 void evdns_search_ndots_set(const int ndots);
 
 /**
@@ -322,9 +340,13 @@ void evdns_search_ndots_set(const int ndots);
     function is evdns_add_server_port_with_base().
 
 */
-struct evdns_server_port *evdns_add_server_port(evutil_socket_t socket, int flags, evdns_request_callback_fn_type callback, void *user_data);
+EVENT2_EXPORT_SYMBOL
+struct evdns_server_port *
+evdns_add_server_port(evutil_socket_t socket, int flags,
+	evdns_request_callback_fn_type callback, void *user_data);
 
 #ifdef _WIN32
+EVENT2_EXPORT_SYMBOL
 int evdns_config_windows_nameservers(void);
 #define EVDNS_CONFIG_WINDOWS_NAMESERVERS_IMPLEMENTED
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/event.h b/ipc/chromium/src/third_party/libevent/include/event2/event.h
index 6e0a4f04c739..a6b6144a92be 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/event.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/event.h
@@ -232,7 +232,7 @@ struct event_base
  *
  * Generally, you can create events with event_new(), then make them
  * pending with event_add().  As your event_base runs, it will run the
- * callbacks of an events whose conditions are triggered.  When you
+ * callbacks of an events whose conditions are triggered.  When you no
  * longer want the event, free it with event_free().
  *
  * In more depth:
@@ -285,7 +285,7 @@ struct event
  * There are many options that can be used to alter the behavior and
  * implementation of an event_base.  To avoid having to pass them all in a
  * complex many-argument constructor, we provide an abstract data type
- * wrhere you set up configation information before passing it to
+ * where you set up configuration information before passing it to
  * event_base_new_with_config().
  *
  * @see event_config_new(), event_config_free(), event_base_new_with_config(),
@@ -632,7 +632,7 @@ int event_config_set_num_cpus_hint(struct event_config *cfg, int cpus);
 /**
  * Record an interval and/or a number of callbacks after which the event base
  * should check for new events.  By default, the event base will run as many
- * events are as activated at the higest activated priority before checking
+ * events are as activated at the highest activated priority before checking
  * for new events.  If you configure it by setting max_interval, it will check
  * the time after each callback, and not allow more than max_interval to
  * elapse before checking for new events.  If you configure it by setting
@@ -692,10 +692,7 @@ EVENT2_EXPORT_SYMBOL
 void event_base_free(struct event_base *);
 
 /**
-   As event_free, but do not run finalizers.
-
-   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
-   BECOMES STABLE.
+   As event_base_free, but do not run finalizers.
  */
 EVENT2_EXPORT_SYMBOL
 void event_base_free_nofinalize(struct event_base *);
@@ -944,9 +941,6 @@ int event_base_got_break(struct event_base *);
  * To use this option safely, you may need to use event_finalize() or
  * event_free_finalize() in order to safely tear down an event in a
  * multithreaded application.  See those functions for more information.
- *
- * THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
- * BECOMES STABLE.
  **/
 #define EV_FINALIZE     0x40
 /**
@@ -963,11 +957,13 @@ int event_base_got_break(struct event_base *);
 /**
    @name evtimer_* macros
 
-    Aliases for working with one-shot timer events */
+   Aliases for working with one-shot timer events
+   If you need EV_PERSIST timer use event_*() functions.
+ */
 /**@{*/
 #define evtimer_assign(ev, b, cb, arg) \
 	event_assign((ev), (b), -1, 0, (cb), (arg))
-#define evtimer_new(b, cb, arg)	       event_new((b), -1, 0, (cb), (arg))
+#define evtimer_new(b, cb, arg)		event_new((b), -1, 0, (cb), (arg))
 #define evtimer_add(ev, tv)		event_add((ev), (tv))
 #define evtimer_del(ev)			event_del(ev)
 #define evtimer_pending(ev, tv)		event_pending((ev), EV_TIMEOUT, (tv))
@@ -990,6 +986,20 @@ int event_base_got_break(struct event_base *);
 #define evsignal_initialized(ev)	event_initialized(ev)
 /**@}*/
 
+/**
+   @name evuser_* macros
+
+   Aliases for working with user-triggered events
+   If you need EV_PERSIST event use event_*() functions.
+ */
+/**@{*/
+#define evuser_new(b, cb, arg)		event_new((b), -1, 0, (cb), (arg))
+#define evuser_del(ev)			event_del(ev)
+#define evuser_pending(ev, tv)		event_pending((ev), 0, (tv))
+#define evuser_initialized(ev)		event_initialized(ev)
+#define evuser_trigger(ev)		event_active((ev), 0, 0)
+/**@}*/
+
 /**
    A callback function for an event.
 
@@ -1029,7 +1039,7 @@ EVENT2_EXPORT_SYMBOL
 void *event_self_cbarg(void);
 
 /**
-  Allocate and asssign a new event structure, ready to be added.
+  Allocate and assign a new event structure, ready to be added.
 
   The function event_new() returns a new event that can be used in
   future calls to event_add() and event_del().  The fd and events
@@ -1055,10 +1065,10 @@ void *event_self_cbarg(void);
   The EV_TIMEOUT flag has no effect here.
 
   It is okay to have multiple events all listening on the same fds; but
-  they must either all be edge-triggered, or all not be edge triggerd.
+  they must either all be edge-triggered, or all not be edge triggered.
 
   When the event becomes active, the event loop will run the provided
-  callbuck function, with three arguments.  The first will be the provided
+  callback function, with three arguments.  The first will be the provided
   fd value.  The second will be a bitfield of the events that triggered:
   EV_READ, EV_WRITE, or EV_SIGNAL.  Here the EV_TIMEOUT flag indicates
   that a timeout occurred, and EV_ET indicates that an edge-triggered
@@ -1073,7 +1083,7 @@ void *event_self_cbarg(void);
   @param callback_arg an argument to be passed to the callback function
 
   @return a newly allocated struct event that must later be freed with
-    event_free().
+    event_free() or NULL if an error occurred.
   @see event_free(), event_add(), event_del(), event_assign()
  */
 EVENT2_EXPORT_SYMBOL
@@ -1124,18 +1134,14 @@ int event_assign(struct event *, struct event_base *, evutil_socket_t, short, ev
 /**
    Deallocate a struct event * returned by event_new().
 
-   If the event is pending or active, first make it non-pending and
-   non-active.
+   If the event is pending or active, this function makes it non-pending
+   and non-active first.
  */
 EVENT2_EXPORT_SYMBOL
 void event_free(struct event *);
 
 /**
  * Callback type for event_finalize and event_free_finalize().
- *
- * THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
- * BECOMES STABLE.
- *
  **/
 typedef void (*event_finalize_callback_fn)(struct event *, void *);
 /**
@@ -1163,13 +1169,10 @@ typedef void (*event_finalize_callback_fn)(struct event *, void *);
    event_finalize() does not.
 
    A finalizer callback must not make events pending or active.  It must not
-   add events, activate events, or attempt to "resucitate" the event being
+   add events, activate events, or attempt to "resuscitate" the event being
    finalized in any way.
 
-   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
-   BECOMES STABLE.
-
-   @return 0 on succes, -1 on failure.
+   @return 0 on success, -1 on failure.
  */
 /**@{*/
 EVENT2_EXPORT_SYMBOL
@@ -1199,7 +1202,7 @@ int event_free_finalize(unsigned, struct event *, event_finalize_callback_fn);
   @param arg an argument to be passed to the callback function
   @param timeout the maximum amount of time to wait for the event. NULL
          makes an EV_READ/EV_WRITE event make forever; NULL makes an
-        EV_TIMEOUT event succees immediately.
+        EV_TIMEOUT event success immediately.
   @return 0 if successful, or -1 if an error occurred
  */
 EVENT2_EXPORT_SYMBOL
@@ -1210,7 +1213,7 @@ int event_base_once(struct event_base *, evutil_socket_t, short, event_callback_
 
   The function event_add() schedules the execution of the event 'ev' when the
   condition specified by event_assign() or event_new() occurs, or when the time
-  specified in timeout has elapesed.  If atimeout is NULL, no timeout
+  specified in timeout has elapsed.  If a timeout is NULL, no timeout
   occurs and the function will only be
   called if a matching event occurs.  The event in the
   ev argument must be already initialized by event_assign() or event_new()
@@ -1236,7 +1239,7 @@ int event_add(struct event *ev, const struct timeval *timeout);
    leaves the event otherwise pending.
 
    @param ev an event struct initialized via event_assign() or event_new()
-   @return 0 on success, or -1 if  an error occurrect.
+   @return 0 on success, or -1 if an error occurred.
 */
 EVENT2_EXPORT_SYMBOL
 int event_remove_timer(struct event *ev);
@@ -1259,9 +1262,6 @@ int event_del(struct event *);
    As event_del(), but never blocks while the event's callback is running
    in another thread, even if the event was constructed without the
    EV_FINALIZE flag.
-
-   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
-   BECOMES STABLE.
  */
 EVENT2_EXPORT_SYMBOL
 int event_del_noblock(struct event *ev);
@@ -1269,9 +1269,6 @@ int event_del_noblock(struct event *ev);
    As event_del(), but always blocks while the event's callback is running
    in another thread, even if the event was constructed with the
    EV_FINALIZE flag.
-
-   THIS IS AN EXPERIMENTAL API. IT MIGHT CHANGE BEFORE THE LIBEVENT 2.1 SERIES
-   BECOMES STABLE.
  */
 EVENT2_EXPORT_SYMBOL
 int event_del_block(struct event *ev);
@@ -1324,7 +1321,7 @@ struct event *event_base_get_running_event(struct event_base *base);
   The event_initialized() function can be used to check if an event has been
   initialized.
 
-  Warning: This function is only useful for distinguishing a a zeroed-out
+  Warning: This function is only useful for distinguishing a zeroed-out
     piece of memory from an initialized event, it can easily be confused by
     uninitialized memory.  Thus, it should ONLY be used to distinguish an
     initialized event from zero.
@@ -1531,7 +1528,7 @@ const struct timeval *event_base_init_common_timeout(struct event_base *base,
 
  Note also that if you are going to call this function, you should do so
  before any call to any Libevent function that does allocation.
- Otherwise, those funtions will allocate their memory using malloc(), but
+ Otherwise, those functions will allocate their memory using malloc(), but
  then later free it using your provided free_fn.
 
  @param malloc_fn A replacement for malloc.
@@ -1570,7 +1567,7 @@ void event_base_dump_events(struct event_base *, FILE *);
 
    @param base the event_base on which to activate the events.
    @param fd An fd to active events on.
-   @param events One or more of EV_{READ,WRITE}.
+   @param events One or more of EV_{READ,WRITE,TIMEOUT}.
  */
 EVENT2_EXPORT_SYMBOL
 void event_base_active_by_fd(struct event_base *base, evutil_socket_t fd, short events);
@@ -1627,7 +1624,7 @@ int event_base_foreach_event(struct event_base *base, event_base_foreach_event_c
     cached time.
 
     Generally, this value will only be cached while actually
-    processing event callbacks, and may be very inaccuate if your
+    processing event callbacks, and may be very inaccurate if your
     callbacks take a long time to execute.
 
     Returns 0 on success, negative on failure.
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/http.h b/ipc/chromium/src/third_party/libevent/include/event2/http.h
index 8fb5642f7f48..2a41303ede0e 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/http.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/http.h
@@ -78,7 +78,8 @@ struct evdns_base;
  * Create a new HTTP server.
  *
  * @param base (optional) the event base to receive the HTTP events
- * @return a pointer to a newly initialized evhttp server structure
+ * @return a pointer to a newly initialized evhttp server structure or NULL
+ *   on error
  * @see evhttp_free()
  */
 EVENT2_EXPORT_SYMBOL
@@ -516,7 +517,8 @@ enum evhttp_request_kind { EVHTTP_REQUEST, EVHTTP_RESPONSE };
  *     when the connection closes.  It must have no fd set on it.
  * @param address the address to which to connect
  * @param port the port to connect to
- * @return an evhttp_connection object that can be used for making requests
+ * @return an evhttp_connection object that can be used for making requests or
+ *   NULL on error
  */
 EVENT2_EXPORT_SYMBOL
 struct evhttp_connection *evhttp_connection_base_bufferevent_new(
@@ -636,7 +638,8 @@ void evhttp_request_free(struct evhttp_request *req);
  *     specified host name resolution will block.
  * @param address the address to which to connect
  * @param port the port to connect to
- * @return an evhttp_connection object that can be used for making requests
+ * @return an evhttp_connection object that can be used for making requests or
+ *   NULL on error
  */
 EVENT2_EXPORT_SYMBOL
 struct evhttp_connection *evhttp_connection_base_new(
@@ -927,14 +930,14 @@ char *evhttp_uriencode(const char *str, ev_ssize_t size, int space_to_plus);
 
 /**
   Helper function to sort of decode a URI-encoded string.  Unlike
-  evhttp_get_decoded_uri, it decodes all plus characters that appear
+  evhttp_uridecode, it decodes all plus characters that appear
   _after_ the first question mark character, but no plusses that occur
   before.  This is not a good way to decode URIs in whole or in part.
 
   The returned string must be freed by the caller
 
   @deprecated  This function is deprecated; you probably want to use
-     evhttp_get_decoded_uri instead.
+     evhttp_uridecode instead.
 
   @param uri an encoded URI
   @return a newly allocated unencoded URI or NULL on failure
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/http_compat.h b/ipc/chromium/src/third_party/libevent/include/event2/http_compat.h
index 43c2c43e46b5..794a581083e4 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/http_compat.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/http_compat.h
@@ -56,8 +56,10 @@ extern "C" {
  *
  * @param address the address to which the HTTP server should be bound
  * @param port the port number on which the HTTP server should listen
- * @return an struct evhttp object
+ * @return a pointer to a newly initialized evhttp server structure
+ *   or NULL on error
  */
+EVENT2_EXPORT_SYMBOL
 struct evhttp *evhttp_start(const char *address, ev_uint16_t port);
 
 /**
@@ -67,6 +69,7 @@ struct evhttp *evhttp_start(const char *address, ev_uint16_t port);
  *
  * @deprecated It does not allow an event base to be specified
  */
+EVENT2_EXPORT_SYMBOL
 struct evhttp_connection *evhttp_connection_new(
 	const char *address, ev_uint16_t port);
 
@@ -76,6 +79,7 @@ struct evhttp_connection *evhttp_connection_new(
  *
  * @deprecated XXXX Why?
  */
+EVENT2_EXPORT_SYMBOL
 void evhttp_connection_set_base(struct evhttp_connection *evcon,
     struct event_base *base);
 
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/listener.h b/ipc/chromium/src/third_party/libevent/include/event2/listener.h
index 84b4da055d8d..789a27c2aacc 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/listener.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/listener.h
@@ -97,6 +97,18 @@ typedef void (*evconnlistener_errorcb)(struct evconnlistener *, void *);
  * This is only available on Linux and kernel 3.9+
  */
 #define LEV_OPT_REUSEABLE_PORT		(1u<<7)
+/** Flag: Indicates that the listener wants to work only in IPv6 socket.
+ *
+ * According to RFC3493 and most Linux distributions, default value is to
+ * work in IPv4-mapped mode. If there is a requirement to bind same port
+ * on same ip addresses but different handlers for both IPv4 and IPv6,
+ * it is required to set IPV6_V6ONLY socket option to be sure that the
+ * code works as expected without affected by bindv6only sysctl setting in
+ * system.
+ *
+ * This socket option also supported by Windows.
+ */
+#define LEV_OPT_BIND_IPV6ONLY		(1u<<8)
 
 /**
    Allocate a new evconnlistener object to listen for incoming TCP connections
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/rpc.h b/ipc/chromium/src/third_party/libevent/include/event2/rpc.h
index dd43df266a17..1bc31d57117e 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/rpc.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/rpc.h
@@ -27,6 +27,10 @@
 #ifndef EVENT2_RPC_H_INCLUDED_
 #define EVENT2_RPC_H_INCLUDED_
 
+/* For int types. */
+#include <event2/util.h>
+#include <event2/visibility.h>
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -178,6 +182,7 @@ EVRPC_STRUCT(rpcname) {	\
 	struct evhttp_request* http_req; \
 	struct evbuffer* rpc_data; \
 };								     \
+EVENT2_EXPORT_SYMBOL \
 int evrpc_send_request_##rpcname(struct evrpc_pool *, \
     struct reqstruct *, struct rplystruct *, \
     void (*)(struct evrpc_status *, \
@@ -187,6 +192,7 @@ int evrpc_send_request_##rpcname(struct evrpc_pool *, \
 struct evrpc_pool;
 
 /** use EVRPC_GENERATE instead */
+EVENT2_EXPORT_SYMBOL
 struct evrpc_request_wrapper *evrpc_make_request_ctx(
 	struct evrpc_pool *pool, void *request, void *reply,
 	const char *rpcname,
@@ -257,10 +263,13 @@ struct evrpc_request_wrapper *evrpc_make_request_ctx(
 #define EVRPC_REQUEST_HTTP(rpc_req) (rpc_req)->http_req
 
 /** completes the server response to an rpc request */
+EVENT2_EXPORT_SYMBOL
 void evrpc_request_done(struct evrpc_req_generic *req);
 
 /** accessors for request and reply */
+EVENT2_EXPORT_SYMBOL
 void *evrpc_get_request(struct evrpc_req_generic *req);
+EVENT2_EXPORT_SYMBOL
 void *evrpc_get_reply(struct evrpc_req_generic *req);
 
 /** Creates the reply to an RPC request
@@ -285,9 +294,10 @@ struct evhttp;
 /** Creates a new rpc base from which RPC requests can be received
  *
  * @param server a pointer to an existing HTTP server
- * @return a newly allocated evrpc_base struct
+ * @return a newly allocated evrpc_base struct or NULL if an error occurred
  * @see evrpc_free()
  */
+EVENT2_EXPORT_SYMBOL
 struct evrpc_base *evrpc_init(struct evhttp *server);
 
 /**
@@ -298,6 +308,7 @@ struct evrpc_base *evrpc_init(struct evhttp *server);
  * @param base the evrpc_base object to be freed
  * @see evrpc_init
  */
+EVENT2_EXPORT_SYMBOL
 void evrpc_free(struct evrpc_base *base);
 
 /** register RPCs with the HTTP Server
@@ -319,10 +330,10 @@ void evrpc_free(struct evrpc_base *base);
 #define EVRPC_REGISTER(base, name, request, reply, callback, cbarg)	\
 	evrpc_register_generic(base, #name,				\
 	    (void (*)(struct evrpc_req_generic *, void *))callback, cbarg, \
-	    (void *(*)(void *))request##_new, NULL,			\
+	    (void *(*)(void *))request##_new_with_arg, NULL,		\
 	    (void (*)(void *))request##_free,				\
 	    (int (*)(void *, struct evbuffer *))request##_unmarshal,	\
-	    (void *(*)(void *))reply##_new, NULL,			\
+	    (void *(*)(void *))reply##_new_with_arg, NULL,		\
 	    (void (*)(void *))reply##_free, \
 	    (int (*)(void *))reply##_complete, \
 	    (void (*)(struct evbuffer *, void *))reply##_marshal)
@@ -334,6 +345,7 @@ void evrpc_free(struct evrpc_base *base);
 
    @see EVRPC_REGISTER()
 */
+EVENT2_EXPORT_SYMBOL
 int evrpc_register_rpc(struct evrpc_base *, struct evrpc *,
     void (*)(struct evrpc_req_generic*, void *), void *);
 
@@ -347,6 +359,7 @@ int evrpc_register_rpc(struct evrpc_base *, struct evrpc *,
  */
 #define EVRPC_UNREGISTER(base, name) evrpc_unregister_rpc((base), #name)
 
+EVENT2_EXPORT_SYMBOL
 int evrpc_unregister_rpc(struct evrpc_base *base, const char *name);
 
 /*
@@ -385,6 +398,7 @@ struct evrpc_status;
    @returns 0 on success, -1 otherwise.
    @see EVRPC_MAKE_REQUEST(), EVRPC_MAKE_CTX()
 */
+EVENT2_EXPORT_SYMBOL
 int evrpc_make_request(struct evrpc_request_wrapper *ctx);
 
 /** creates an rpc connection pool
@@ -394,15 +408,18 @@ int evrpc_make_request(struct evrpc_request_wrapper *ctx);
  *
  * @param base a pointer to an struct event_based object; can be left NULL
  *   in singled-threaded applications
- * @return a newly allocated struct evrpc_pool object
+ * @return a newly allocated struct evrpc_pool object or NULL if an error
+ *   occurred
  * @see evrpc_pool_free()
  */
+EVENT2_EXPORT_SYMBOL
 struct evrpc_pool *evrpc_pool_new(struct event_base *base);
 /** frees an rpc connection pool
  *
  * @param pool a pointer to an evrpc_pool allocated via evrpc_pool_new()
  * @see evrpc_pool_new()
  */
+EVENT2_EXPORT_SYMBOL
 void evrpc_pool_free(struct evrpc_pool *pool);
 
 /**
@@ -413,6 +430,7 @@ void evrpc_pool_free(struct evrpc_pool *pool);
  * @param pool the pool to which to add the connection
  * @param evcon the connection to add to the pool.
  */
+EVENT2_EXPORT_SYMBOL
 void evrpc_pool_add_connection(struct evrpc_pool *pool,
     struct evhttp_connection *evcon);
 
@@ -424,6 +442,7 @@ void evrpc_pool_add_connection(struct evrpc_pool *pool,
  * @param pool the pool from which to remove the connection
  * @param evcon the connection to remove from the pool.
  */
+EVENT2_EXPORT_SYMBOL
 void evrpc_pool_remove_connection(struct evrpc_pool *pool,
     struct evhttp_connection *evcon);
 
@@ -442,6 +461,7 @@ void evrpc_pool_remove_connection(struct evrpc_pool *pool,
  * @param timeout_in_secs the number of seconds after which a request should
  *   timeout and a failure be returned to the callback.
  */
+EVENT2_EXPORT_SYMBOL
 void evrpc_pool_set_timeout(struct evrpc_pool *pool, int timeout_in_secs);
 
 /**
@@ -489,6 +509,7 @@ enum EVRPC_HOOK_RESULT {
  * @return a handle to the hook so it can be removed later
  * @see evrpc_remove_hook()
  */
+EVENT2_EXPORT_SYMBOL
 void *evrpc_add_hook(void *vbase,
     enum EVRPC_HOOK_TYPE hook_type,
     int (*cb)(void *, struct evhttp_request *, struct evbuffer *, void *),
@@ -502,6 +523,7 @@ void *evrpc_add_hook(void *vbase,
  * @return 1 on success or 0 on failure
  * @see evrpc_add_hook()
  */
+EVENT2_EXPORT_SYMBOL
 int evrpc_remove_hook(void *vbase,
     enum EVRPC_HOOK_TYPE hook_type,
     void *handle);
@@ -511,8 +533,8 @@ int evrpc_remove_hook(void *vbase,
  * @param vbase a pointer to either struct evrpc_base or struct evrpc_pool
  * @param ctx the context pointer provided to the original hook call
  */
-int
-evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res);
+EVENT2_EXPORT_SYMBOL
+int evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res);
 
 /** adds meta data to request
  *
@@ -525,6 +547,7 @@ evrpc_resume_request(void *vbase, void *ctx, enum EVRPC_HOOK_RESULT res);
  * @param data the data to be associated with the key
  * @param data_size the size of the data
  */
+EVENT2_EXPORT_SYMBOL
 void evrpc_hook_add_meta(void *ctx, const char *key,
     const void *data, size_t data_size);
 
@@ -538,6 +561,7 @@ void evrpc_hook_add_meta(void *ctx, const char *key,
  * @param data_size pointer to the size of the data
  * @return 0 on success or -1 on failure
  */
+EVENT2_EXPORT_SYMBOL
 int evrpc_hook_find_meta(void *ctx, const char *key,
     void **data, size_t *data_size);
 
@@ -545,8 +569,10 @@ int evrpc_hook_find_meta(void *ctx, const char *key,
  * returns the connection object associated with the request
  *
  * @param ctx the context provided to the hook call
- * @return a pointer to the evhttp_connection object
+ * @return a pointer to the evhttp_connection object or NULL if an error
+ *   occurred
  */
+EVENT2_EXPORT_SYMBOL
 struct evhttp_connection *evrpc_hook_get_connection(void *ctx);
 
 /**
@@ -556,6 +582,7 @@ struct evhttp_connection *evrpc_hook_get_connection(void *ctx);
 
    @see EVRPC_MAKE_REQUEST()
  */
+EVENT2_EXPORT_SYMBOL
 int evrpc_send_request_generic(struct evrpc_pool *pool,
     void *request, void *reply,
     void (*cb)(struct evrpc_status *, void *, void *, void *),
@@ -572,8 +599,8 @@ int evrpc_send_request_generic(struct evrpc_pool *pool,
 
    @see EVRPC_REGISTER()
  */
-int
-evrpc_register_generic(struct evrpc_base *base, const char *name,
+EVENT2_EXPORT_SYMBOL
+int evrpc_register_generic(struct evrpc_base *base, const char *name,
     void (*callback)(struct evrpc_req_generic *, void *), void *cbarg,
     void *(*req_new)(void *), void *req_new_arg, void (*req_free)(void *),
     int (*req_unmarshal)(void *, struct evbuffer *),
@@ -582,9 +609,12 @@ evrpc_register_generic(struct evrpc_base *base, const char *name,
     void (*rpl_marshal)(struct evbuffer *, void *));
 
 /** accessors for obscure and undocumented functionality */
+EVENT2_EXPORT_SYMBOL
 struct evrpc_pool* evrpc_request_get_pool(struct evrpc_request_wrapper *ctx);
+EVENT2_EXPORT_SYMBOL
 void evrpc_request_set_pool(struct evrpc_request_wrapper *ctx,
     struct evrpc_pool *pool);
+EVENT2_EXPORT_SYMBOL
 void evrpc_request_set_cb(struct evrpc_request_wrapper *ctx,
     void (*cb)(struct evrpc_status*, void *request, void *reply, void *arg),
     void *cb_arg);
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/rpc_struct.h b/ipc/chromium/src/third_party/libevent/include/event2/rpc_struct.h
index 8f691f49fbcd..f3cb460aed41 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/rpc_struct.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/rpc_struct.h
@@ -38,6 +38,16 @@ extern "C" {
 
  */
 
+/* Fix so that people don't have to run with <sys/queue.h> */
+#ifndef TAILQ_ENTRY
+#define EVENT_DEFINED_TQENTRY_
+#define TAILQ_ENTRY(type)						\
+struct {								\
+	struct type *tqe_next;	/* next element */			\
+	struct type **tqe_prev;	/* address of previous next element */	\
+}
+#endif /* !TAILQ_ENTRY */
+
 /**
  * provides information about the completed RPC request.
  */
@@ -93,6 +103,10 @@ struct evrpc {
 	struct evrpc_base *base;
 };
 
+#ifdef EVENT_DEFINED_TQENTRY_
+#undef TAILQ_ENTRY
+#endif
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/util.h b/ipc/chromium/src/third_party/libevent/include/event2/util.h
index c6f450bf0d08..02aa7ba9dab8 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/util.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/util.h
@@ -58,9 +58,6 @@ extern "C" {
 #endif
 #include <stdarg.h>
 #ifdef EVENT__HAVE_NETDB_H
-#if !defined(_GNU_SOURCE)
-#define _GNU_SOURCE
-#endif
 #include <netdb.h>
 #endif
 
@@ -259,6 +256,7 @@ extern "C" {
 #define EV_INT32_MAX  INT32_MAX
 #define EV_INT32_MIN  INT32_MIN
 #define EV_UINT16_MAX UINT16_MAX
+#define EV_INT16_MIN  INT16_MIN
 #define EV_INT16_MAX  INT16_MAX
 #define EV_UINT8_MAX  UINT8_MAX
 #define EV_INT8_MAX   INT8_MAX
@@ -425,6 +423,18 @@ int evutil_make_listen_socket_reuseable(evutil_socket_t sock);
 EVENT2_EXPORT_SYMBOL
 int evutil_make_listen_socket_reuseable_port(evutil_socket_t sock);
 
+/** Set ipv6 only bind socket option to make listener work only in ipv6 sockets.
+
+    According to RFC3493 and most Linux distributions, default value for the
+    sockets is to work in IPv4-mapped mode. In IPv4-mapped mode, it is not possible
+    to bind same port from different IPv4 and IPv6 handlers.
+
+    @param sock The socket to make in ipv6only working mode
+    @return 0 on success, -1 on failure
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_make_listen_socket_ipv6only(evutil_socket_t sock);
+
 /** Do platform-specific operations as needed to close a socket upon a
     successful execution of one of the exec*() functions.
 
@@ -438,7 +448,8 @@ int evutil_make_socket_closeonexec(evutil_socket_t sock);
     socket() or accept().
 
     @param sock The socket to be closed
-    @return 0 on success, -1 on failure
+    @return 0 on success (whether the operation is supported or not),
+            -1 on failure
  */
 EVENT2_EXPORT_SYMBOL
 int evutil_closesocket(evutil_socket_t sock);
@@ -470,6 +481,7 @@ int evutil_socket_geterror(evutil_socket_t sock);
 /** Convert a socket error to a string. */
 EVENT2_EXPORT_SYMBOL
 const char *evutil_socket_error_to_string(int errcode);
+#define EVUTIL_INVALID_SOCKET INVALID_SOCKET
 #elif defined(EVENT_IN_DOXYGEN_)
 /**
    @name Socket error functions
@@ -493,14 +505,16 @@ const char *evutil_socket_error_to_string(int errcode);
 #define evutil_socket_geterror(sock) ...
 /** Convert a socket error to a string. */
 #define evutil_socket_error_to_string(errcode) ...
+#define EVUTIL_INVALID_SOCKET -1
 /**@}*/
-#else
+#else /** !EVENT_IN_DOXYGEN_ && !_WIN32 */
 #define EVUTIL_SOCKET_ERROR() (errno)
 #define EVUTIL_SET_SOCKET_ERROR(errcode)		\
 		do { errno = (errcode); } while (0)
 #define evutil_socket_geterror(sock) (errno)
 #define evutil_socket_error_to_string(errcode) (strerror(errcode))
-#endif
+#define EVUTIL_INVALID_SOCKET -1
+#endif /** !_WIN32 */
 
 
 /**
@@ -598,6 +612,12 @@ int evutil_vsnprintf(char *buf, size_t buflen, const char *format, va_list ap)
 /** Replacement for inet_ntop for platforms which lack it. */
 EVENT2_EXPORT_SYMBOL
 const char *evutil_inet_ntop(int af, const void *src, char *dst, size_t len);
+/** Variation of inet_pton that also parses IPv6 scopes. Public for
+    unit tests. No reason to call this directly.
+ */
+EVENT2_EXPORT_SYMBOL
+int evutil_inet_pton_scope(int af, const char *src, void *dst,
+	unsigned *indexp);
 /** Replacement for inet_pton for platforms which lack it. */
 EVENT2_EXPORT_SYMBOL
 int evutil_inet_pton(int af, const char *src, void *dst);
@@ -842,7 +862,7 @@ int evutil_secure_rng_init(void);
 EVENT2_EXPORT_SYMBOL
 int evutil_secure_rng_set_urandom_device_file(char *fname);
 
-#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(ANDROID)
+#if !defined(EVENT__HAVE_ARC4RANDOM) || defined(EVENT__HAVE_ARC4RANDOM_ADDRANDOM)
 /** Seed the random number generator with extra random bytes.
 
     You should almost never need to call this function; it should be
diff --git a/ipc/chromium/src/third_party/libevent/include/event2/visibility.h b/ipc/chromium/src/third_party/libevent/include/event2/visibility.h
index fb16dbeeddd0..006bbf06d80f 100644
--- a/ipc/chromium/src/third_party/libevent/include/event2/visibility.h
+++ b/ipc/chromium/src/third_party/libevent/include/event2/visibility.h
@@ -29,22 +29,39 @@
 
 #include <event2/event-config.h>
 
-#if defined(event_EXPORTS) || defined(event_extra_EXPORTS) || defined(event_core_EXPORTS)
+#if defined(event_shared_EXPORTS) || \
+    defined(event_extra_shared_EXPORTS) || \
+    defined(event_core_shared_EXPORTS) || \
+    defined(event_pthreads_shared_EXPORTS) || \
+    defined(event_openssl_shared_EXPORTS)
+
 # if defined (__SUNPRO_C) && (__SUNPRO_C >= 0x550)
 #  define EVENT2_EXPORT_SYMBOL __global
 # elif defined __GNUC__
 #  define EVENT2_EXPORT_SYMBOL __attribute__ ((visibility("default")))
 # elif defined(_MSC_VER)
-#  define EVENT2_EXPORT_SYMBOL extern __declspec(dllexport)
+#  define EVENT2_EXPORT_SYMBOL __declspec(dllexport)
 # else
 #  define EVENT2_EXPORT_SYMBOL /* unknown compiler */
 # endif
-#else
-# if defined(EVENT__NEED_DLLIMPORT) && defined(_MSC_VER) && !defined(EVENT_BUILDING_REGRESS_TEST)
-#  define EVENT2_EXPORT_SYMBOL extern __declspec(dllimport)
-# else
-#  define EVENT2_EXPORT_SYMBOL
+
+#else /* event_*_EXPORTS */
+
+# define EVENT2_EXPORT_SYMBOL
+
+#endif /* event_*_EXPORTS */
+
+/** We need to dllimport event_debug_logging_mask_ into event_extra */
+#if defined(_MSC_VER)
+# if defined(event_core_shared_EXPORTS) /** from core export */
+#  define EVENT2_CORE_EXPORT_SYMBOL __declspec(dllexport)
+# elif defined(event_extra_shared_EXPORTS) || /** from extra import */ \
+       defined(EVENT_VISIBILITY_WANT_DLLIMPORT)
+#  define EVENT2_CORE_EXPORT_SYMBOL __declspec(dllimport)
 # endif
+#endif /* _MSC_VER */
+#if !defined(EVENT2_CORE_EXPORT_SYMBOL)
+# define EVENT2_CORE_EXPORT_SYMBOL EVENT2_EXPORT_SYMBOL
 #endif
 
 #endif /* EVENT2_VISIBILITY_H_INCLUDED_ */
diff --git a/ipc/chromium/src/third_party/libevent/include/include.am b/ipc/chromium/src/third_party/libevent/include/include.am
index 9aad2dba4abe..aaa2042af1f6 100644
--- a/ipc/chromium/src/third_party/libevent/include/include.am
+++ b/ipc/chromium/src/third_party/libevent/include/include.am
@@ -1,4 +1,4 @@
-# include/Makefile.am for libevent
+# include/include.am for libevent
 # Copyright 2000-2007 Niels Provos
 # Copyright 2007-2012 Niels Provos and Nick Mathewson
 #
@@ -11,7 +11,6 @@ EVENT2_EXPORT = \
 	include/event2/buffer_compat.h \
 	include/event2/bufferevent.h \
 	include/event2/bufferevent_compat.h \
-	include/event2/bufferevent_ssl.h \
 	include/event2/bufferevent_struct.h \
 	include/event2/dns.h \
 	include/event2/dns_compat.h \
@@ -33,6 +32,10 @@ EVENT2_EXPORT = \
 	include/event2/util.h \
 	include/event2/visibility.h
 
+if OPENSSL
+EVENT2_EXPORT += include/event2/bufferevent_ssl.h
+endif
+
 ## Without the nobase_ prefixing, Automake would strip "include/event2/" from
 ## the source header filename to derive the installed header filename.
 ## With nobase_ the installed path is $(includedir)/include/event2/ev*.h.
diff --git a/ipc/chromium/src/third_party/libevent/iocp-internal.h b/ipc/chromium/src/third_party/libevent/iocp-internal.h
index 93dbe2b1a454..21e0e0af6807 100644
--- a/ipc/chromium/src/third_party/libevent/iocp-internal.h
+++ b/ipc/chromium/src/third_party/libevent/iocp-internal.h
@@ -92,6 +92,7 @@ struct event_iocp_port {
 	HANDLE *shutdownSemaphore;
 };
 
+EVENT2_EXPORT_SYMBOL
 const struct win32_extension_fns *event_get_win32_extension_fns_(void);
 #else
 /* Dummy definition so we can test-compile more things on unix. */
@@ -106,12 +107,14 @@ struct event_overlapped {
     @param cb The callback that should be invoked once the IO operation has
 	finished.
  */
+EVENT2_EXPORT_SYMBOL
 void event_overlapped_init_(struct event_overlapped *, iocp_callback cb);
 
 /** Allocate and return a new evbuffer that supports overlapped IO on a given
     socket.  The socket must be associated with an IO completion port using
     event_iocp_port_associate_.
 */
+EVENT2_EXPORT_SYMBOL
 struct evbuffer *evbuffer_overlapped_new_(evutil_socket_t fd);
 
 /** XXXX Document (nickm) */
@@ -131,6 +134,7 @@ void evbuffer_overlapped_set_fd_(struct evbuffer *buf, evutil_socket_t fd);
     @param ol Overlapped object with associated completion callback.
     @return 0 on success, -1 on error.
  */
+EVENT2_EXPORT_SYMBOL
 int evbuffer_launch_read_(struct evbuffer *buf, size_t n, struct event_overlapped *ol);
 
 /** Start writing data from the start of an evbuffer.
@@ -145,21 +149,26 @@ int evbuffer_launch_read_(struct evbuffer *buf, size_t n, struct event_overlappe
     @param ol Overlapped object with associated completion callback.
     @return 0 on success, -1 on error.
  */
+EVENT2_EXPORT_SYMBOL
 int evbuffer_launch_write_(struct evbuffer *buf, ev_ssize_t n, struct event_overlapped *ol);
 
 /** XXX document */
+EVENT2_EXPORT_SYMBOL
 void evbuffer_commit_read_(struct evbuffer *, ev_ssize_t);
+EVENT2_EXPORT_SYMBOL
 void evbuffer_commit_write_(struct evbuffer *, ev_ssize_t);
 
 /** Create an IOCP, and launch its worker threads.  Internal use only.
 
     This interface is unstable, and will change.
  */
+EVENT2_EXPORT_SYMBOL
 struct event_iocp_port *event_iocp_port_launch_(int n_cpus);
 
 /** Associate a file descriptor with an iocp, such that overlapped IO on the
     fd will happen on one of the iocp's worker threads.
 */
+EVENT2_EXPORT_SYMBOL
 int event_iocp_port_associate_(struct event_iocp_port *port, evutil_socket_t fd,
     ev_uintptr_t key);
 
@@ -169,22 +178,27 @@ int event_iocp_port_associate_(struct event_iocp_port *port, evutil_socket_t fd,
     0. Otherwise, return -1.  If you get a -1 return value, it is safe to call
     this function again.
 */
+EVENT2_EXPORT_SYMBOL
 int event_iocp_shutdown_(struct event_iocp_port *port, long waitMsec);
 
 /* FIXME document. */
+EVENT2_EXPORT_SYMBOL
 int event_iocp_activate_overlapped_(struct event_iocp_port *port,
     struct event_overlapped *o,
     ev_uintptr_t key, ev_uint32_t n_bytes);
 
 struct event_base;
 /* FIXME document. */
+EVENT2_EXPORT_SYMBOL
 struct event_iocp_port *event_base_get_iocp_(struct event_base *base);
 
 /* FIXME document. */
+EVENT2_EXPORT_SYMBOL
 int event_base_start_iocp_(struct event_base *base, int n_cpus);
 void event_base_stop_iocp_(struct event_base *base);
 
 /* FIXME document. */
+EVENT2_EXPORT_SYMBOL
 struct bufferevent *bufferevent_async_new_(struct event_base *base,
     evutil_socket_t fd, int options);
 
diff --git a/ipc/chromium/src/third_party/libevent/kqueue.c b/ipc/chromium/src/third_party/libevent/kqueue.c
index a959c58af52b..dfd7751d6497 100644
--- a/ipc/chromium/src/third_party/libevent/kqueue.c
+++ b/ipc/chromium/src/third_party/libevent/kqueue.c
@@ -37,6 +37,7 @@
 #endif
 #include <sys/queue.h>
 #include <sys/event.h>
+#include <limits.h>
 #include <signal.h>
 #include <stdio.h>
 #include <stdlib.h>
@@ -50,7 +51,10 @@
 /* Some platforms apparently define the udata field of struct kevent as
  * intptr_t, whereas others define it as void*.  There doesn't seem to be an
  * easy way to tell them apart via autoconf, so we need to use OS macros. */
-#if defined(EVENT__HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__) && !defined(__CloudABI__)
+#if defined(__NetBSD__)
+#define PTR_TO_UDATA(x) ((typeof(((struct kevent *)0)->udata))(x))
+#define INT_TO_UDATA(x) ((typeof(((struct kevent *)0)->udata))(intptr_t)(x))
+#elif defined(EVENT__HAVE_INTTYPES_H) && !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(__darwin__) && !defined(__APPLE__) && !defined(__CloudABI__)
 #define PTR_TO_UDATA(x)	((intptr_t)(x))
 #define INT_TO_UDATA(x) ((intptr_t)(x))
 #else
@@ -62,6 +66,7 @@
 #include "log-internal.h"
 #include "evmap-internal.h"
 #include "event2/thread.h"
+#include "event2/util.h"
 #include "evthread-internal.h"
 #include "changelist-internal.h"
 
@@ -207,9 +212,17 @@ kq_build_changes_list(const struct event_changelist *changelist,
 		struct event_change *in_ch = &changelist->changes[i];
 		struct kevent *out_ch;
 		if (n_changes >= kqop->changes_size - 1) {
-			int newsize = kqop->changes_size * 2;
+			int newsize;
 			struct kevent *newchanges;
 
+			if (kqop->changes_size > INT_MAX / 2 ||
+			    (size_t)kqop->changes_size * 2 > EV_SIZE_MAX /
+			    sizeof(struct kevent)) {
+				event_warnx("%s: int overflow", __func__);
+				return (-1);
+			}
+
+			newsize = kqop->changes_size * 2;
 			newchanges = mm_realloc(kqop->changes,
 			    newsize * sizeof(struct kevent));
 			if (newchanges == NULL) {
diff --git a/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h b/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h
index dd64dc621002..101d39d45510 100644
--- a/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h
+++ b/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h
@@ -26,9 +26,15 @@
 /* Define to 1 if you have the `accept4' function. */
 #define EVENT__HAVE_ACCEPT4 1
 
+/* Define to 1 if you have the <afunix.h> header file. */
+/* #undef EVENT__HAVE_AFUNIX_H 1 */
+
 /* Define to 1 if you have the `arc4random' function. */
 /* #undef EVENT__HAVE_ARC4RANDOM */
 
+/* Define to 1 if you have the `arc4random_addrandom' function. */
+/* #undef EVENT__HAVE_ARC4RANDOM_ADDRANDOM */
+
 /* Define to 1 if you have the `arc4random_buf' function. */
 /* #undef EVENT__HAVE_ARC4RANDOM_BUF */
 
@@ -46,14 +52,6 @@
    don't. */
 #define EVENT__HAVE_DECL_KERN_ARND 0
 
-/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if you
-   don't. */
-#define EVENT__HAVE_DECL_KERN_RANDOM 1
-
-/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if you
-   don't. */
-#define EVENT__HAVE_DECL_RANDOM_UUID 1
-
 /* Define if /dev/poll is available */
 /* #undef EVENT__HAVE_DEVPOLL */
 
@@ -72,9 +70,6 @@
 /* Define to 1 if you have the <errno.h> header file. */
 #define EVENT__HAVE_ERRNO_H 1
 
-/* Define to 1 if you have ERR_remove_thread_stat(). */
-/* #undef EVENT__HAVE_ERR_REMOVE_THREAD_STATE */
-
 /* Define to 1 if you have the `eventfd' function. */
 #define EVENT__HAVE_EVENTFD 1
 
@@ -120,6 +115,9 @@
 /* Define to 1 if you have the `getprotobynumber' function. */
 #define EVENT__HAVE_GETPROTOBYNUMBER 1
 
+/* Define to 1 if you have the `getrandom' function. */
+/* #undef EVENT__HAVE_GETRANDOM */
+
 /* Define to 1 if you have the `getservbyname' function. */
 #define EVENT__HAVE_GETSERVBYNAME 1
 
@@ -144,12 +142,18 @@
 /* Define to 1 if you have the `kqueue' function. */
 /* #undef EVENT__HAVE_KQUEUE */
 
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef EVENT__HAVE_LIBWS2_32 */
+
 /* Define if the system has zlib */
 #define EVENT__HAVE_LIBZ 1
 
 /* Define to 1 if you have the `mach_absolute_time' function. */
 /* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */
 
+/* Define to 1 if you have the <mach/mach.h> header file. */
+/* #undef EVENT__HAVE_MACH_MACH_H */
+
 /* Define to 1 if you have the <mach/mach_time.h> header file. */
 /* #undef EVENT__HAVE_MACH_MACH_TIME_H */
 
@@ -177,6 +181,9 @@
 /* Define if the system has openssl */
 /* #undef EVENT__HAVE_OPENSSL */
 
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+/* #undef EVENT__HAVE_OPENSSL_SSL_H */
+
 /* Define to 1 if you have the `pipe' function. */
 #define EVENT__HAVE_PIPE 1
 
@@ -273,6 +280,9 @@
 /* Define to 1 if `s6_addr32' is a member of `struct in6_addr'. */
 #define EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 1
 
+/* Define to 1 if the system has the type `struct linger'. */
+#define EVENT__HAVE_STRUCT_LINGER 1
+
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
 #define EVENT__HAVE_STRUCT_SOCKADDR_IN6 1
 
@@ -291,8 +301,8 @@
 /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
 /* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
 
-/* Define to 1 if the system has the type `struct so_linger'. */
-#define EVENT__HAVE_STRUCT_SO_LINGER 1
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define EVENT__HAVE_STRUCT_SOCKADDR_UN 1
 
 /* Define to 1 if you have the `sysctl' function. */
 /* #undef EVENT__HAVE_SYSCTL */
@@ -321,6 +331,9 @@
 /* Define to 1 if you have the <sys/queue.h> header file. */
 #define EVENT__HAVE_SYS_QUEUE_H 1
 
+/* Define to 1 if you have the <sys/random.h> header file. */
+/* #undef EVENT__HAVE_SYS_RANDOM_H */
+
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #define EVENT__HAVE_SYS_RESOURCE_H 1
 
@@ -351,6 +364,9 @@
 /* Define to 1 if you have the <sys/uio.h> header file. */
 #define EVENT__HAVE_SYS_UIO_H 1
 
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define EVENT__HAVE_SYS_UN_H 1
+
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #define EVENT__HAVE_SYS_WAIT_H 1
 
@@ -402,20 +418,29 @@
 /* Define to 1 if you have the `vasprintf' function. */
 #define EVENT__HAVE_VASPRINTF 1
 
-/* Define if waitpid() supports WNOWAIT */
-#define EVENT__HAVE_WAITPID_WITH_WNOWAIT 1
-
 /* Define if kqueue works correctly with pipes */
 /* #undef EVENT__HAVE_WORKING_KQUEUE */
 
 /* Define to 1 if you have the <zlib.h> header file. */
 #define EVENT__HAVE_ZLIB_H 1
 
+/* Define to 1 if you have the `_gmtime64' function. */
+/* #undef EVENT__HAVE__GMTIME64 */
+
+/* Define to 1 if you have the `_gmtime64_s' function. */
+/* #undef EVENT__HAVE__GMTIME64_S */
+
+/* Define to 1 if compiler have __FUNCTION__ */
+#define EVENT__HAVE___FUNCTION__ 1
+
+/* Define to 1 if compiler have __func__ */
+#define EVENT__HAVE___func__ 1
+
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define EVENT__LT_OBJDIR ".libs/"
 
 /* Numeric representation of the version */
-#define EVENT__NUMERIC_VERSION 0x02010800
+#define EVENT__NUMERIC_VERSION 0x02010c00
 
 /* Name of package */
 #define EVENT__PACKAGE "libevent"
@@ -427,7 +452,7 @@
 #define EVENT__PACKAGE_NAME "libevent"
 
 /* Define to the full name and version of this package. */
-#define EVENT__PACKAGE_STRING "libevent 2.1.8-stable"
+#define EVENT__PACKAGE_STRING "libevent 2.1.12-stable"
 
 /* Define to the one symbol short name of this package. */
 #define EVENT__PACKAGE_TARNAME "libevent"
@@ -436,7 +461,7 @@
 #define EVENT__PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define EVENT__PACKAGE_VERSION "2.1.8-stable"
+#define EVENT__PACKAGE_VERSION "2.1.12-stable"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -484,6 +509,13 @@
 #define EVENT__SIZEOF_SIZE_T 4
 #endif
 
+/* The size of `time_t', as computed by sizeof. */
+#ifdef __LP64__
+#define EVENT__SIZEOF_TIME_T 8
+#else
+#define EVENT__SIZEOF_TIME_T 4
+#endif
+
 /* The size of `void *', as computed by sizeof. */
 #ifdef __LP64__
 #define EVENT__SIZEOF_VOID_P 8
@@ -496,79 +528,79 @@
 /* ------------------------------------------------------------------------ */
 
 /* Define to 1 if you have the ANSI C header files. */
-#define EVENT__STDC_HEADERS 1
+#define STDC_HEADERS 1
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #define EVENT__TIME_WITH_SYS_TIME 1
 
 /* Enable extensions on AIX 3, Interix.  */
-#ifndef EVENT___ALL_SOURCE
-# define EVENT___ALL_SOURCE 1
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
 #endif
 /* Enable GNU extensions on systems that have them.  */
-#ifndef EVENT___GNU_SOURCE
-# define EVENT___GNU_SOURCE 1
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
 #endif
 /* Enable threading extensions on Solaris.  */
-#ifndef EVENT___POSIX_PTHREAD_SEMANTICS
-# define EVENT___POSIX_PTHREAD_SEMANTICS 1
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
 #endif
 /* Enable extensions on HP NonStop.  */
-#ifndef EVENT___TANDEM_SOURCE
-# define EVENT___TANDEM_SOURCE 1
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
 #endif
 /* Enable general extensions on Solaris.  */
-#ifndef EVENT____EXTENSIONS__
-# define EVENT____EXTENSIONS__ 1
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
 #endif
 
 
 /* Version number of package */
-#define EVENT__VERSION "2.1.8-stable"
+#define EVENT__VERSION "2.1.12-stable"
 
 /* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef EVENT___DARWIN_USE_64_BIT_INODE
-# define EVENT___DARWIN_USE_64_BIT_INODE 1
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
 #endif
 
 /* Number of bits in a file offset, on hosts where this is settable. */
-/* #undef EVENT___FILE_OFFSET_BITS */
+/* #undef _FILE_OFFSET_BITS */
 
 /* Define for large files, on AIX-style hosts. */
-/* #undef EVENT___LARGE_FILES */
+/* #undef _LARGE_FILES */
 
 /* Define to 1 if on MINIX. */
-/* #undef EVENT___MINIX */
+/* #undef _MINIX */
 
 /* Define to 2 if the system does not provide POSIX.1 features except with
    this defined. */
-/* #undef EVENT___POSIX_1_SOURCE */
+/* #undef _POSIX_1_SOURCE */
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
-/* #undef EVENT___POSIX_SOURCE */
+/* #undef _POSIX_SOURCE */
 
 /* Define to appropriate substitue if compiler doesnt have __func__ */
-/* #undef EVENT____func__ */
+/* #undef __func__ */
 
 /* Define to empty if `const' does not conform to ANSI C. */
-/* #undef EVENT__const */
+/* #undef const */
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef EVENT____cplusplus
-/* #undef EVENT__inline */
+#ifndef __cplusplus
+/* #undef inline */
 #endif
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__pid_t */
+/* #undef pid_t */
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef EVENT__size_t */
+/* #undef size_t */
 
 /* Define to unsigned int if you dont have it */
-/* #undef EVENT__socklen_t */
+/* #undef socklen_t */
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__ssize_t */
+/* #undef ssize_t */
 
 #endif /* event2/event-config.h */
diff --git a/ipc/chromium/src/third_party/libevent/listener.c b/ipc/chromium/src/third_party/libevent/listener.c
index 2862d32e38d0..f5c00c9c0e30 100644
--- a/ipc/chromium/src/third_party/libevent/listener.c
+++ b/ipc/chromium/src/third_party/libevent/listener.c
@@ -35,6 +35,7 @@
 #define _WIN32_WINNT 0x0403
 #endif
 #include <winsock2.h>
+#include <winerror.h>
 #include <ws2tcpip.h>
 #include <mswsock.h>
 #endif
@@ -245,6 +246,11 @@ evconnlistener_new_bind(struct event_base *base, evconnlistener_cb cb,
 			goto err;
 	}
 
+	if (flags & LEV_OPT_BIND_IPV6ONLY) {
+		if (evutil_make_listen_socket_ipv6only(fd) < 0)
+			goto err;
+	}
+
 	if (sa) {
 		if (bind(fd, sa, socklen)<0)
 			goto err;
@@ -421,11 +427,14 @@ listener_read_cb(evutil_socket_t fd, short what, void *p)
 		if (lev->refcnt == 1) {
 			int freed = listener_decref_and_unlock(lev);
 			EVUTIL_ASSERT(freed);
-
-			evutil_closesocket(new_fd);
 			return;
 		}
 		--lev->refcnt;
+		if (!lev->enabled) {
+			/* the callback could have disabled the listener */
+			UNLOCK(lev);
+			return;
+		}
 	}
 	err = evutil_socket_geterror(fd);
 	if (EVUTIL_ERR_ACCEPT_RETRIABLE(err)) {
@@ -504,7 +513,7 @@ new_accepting_socket(struct evconnlistener_iocp *lev, int family)
 		return NULL;
 
 	event_overlapped_init_(&res->overlapped, accepted_socket_cb);
-	res->s = INVALID_SOCKET;
+	res->s = EVUTIL_INVALID_SOCKET;
 	res->lev = lev;
 	res->buflen = buflen;
 	res->family = family;
@@ -522,7 +531,7 @@ static void
 free_and_unlock_accepting_socket(struct accepting_socket *as)
 {
 	/* requires lock. */
-	if (as->s != INVALID_SOCKET)
+	if (as->s != EVUTIL_INVALID_SOCKET)
 		closesocket(as->s);
 
 	LeaveCriticalSection(&as->lock);
@@ -542,7 +551,7 @@ start_accepting(struct accepting_socket *as)
 	if (!as->lev->base.enabled)
 		return 0;
 
-	if (s == INVALID_SOCKET) {
+	if (s == EVUTIL_INVALID_SOCKET) {
 		error = WSAGetLastError();
 		goto report_err;
 	}
@@ -589,7 +598,7 @@ stop_accepting(struct accepting_socket *as)
 {
 	/* requires lock. */
 	SOCKET s = as->s;
-	as->s = INVALID_SOCKET;
+	as->s = EVUTIL_INVALID_SOCKET;
 	closesocket(s);
 }
 
@@ -631,7 +640,7 @@ accepted_socket_invoke_user_cb(struct event_callback *dcb, void *arg)
 			&socklen_remote);
 		sock = as->s;
 		cb = lev->cb;
-		as->s = INVALID_SOCKET;
+		as->s = EVUTIL_INVALID_SOCKET;
 
 		/* We need to call this so getsockname, getpeername, and
 		 * shutdown work correctly on the accepted socket. */
@@ -679,7 +688,7 @@ accepted_socket_cb(struct event_overlapped *o, ev_uintptr_t key, ev_ssize_t n, i
 		free_and_unlock_accepting_socket(as);
 		listener_decref_and_unlock(lev);
 		return;
-	} else if (as->s == INVALID_SOCKET) {
+	} else if (as->s == EVUTIL_INVALID_SOCKET) {
 		/* This is okay; we were disabled by iocp_listener_disable. */
 		LeaveCriticalSection(&as->lock);
 	} else {
@@ -717,7 +726,7 @@ iocp_listener_enable(struct evconnlistener *lev)
 		if (!as)
 			continue;
 		EnterCriticalSection(&as->lock);
-		if (!as->free_on_cb && as->s == INVALID_SOCKET)
+		if (!as->free_on_cb && as->s == EVUTIL_INVALID_SOCKET)
 			start_accepting(as);
 		LeaveCriticalSection(&as->lock);
 	}
@@ -739,7 +748,7 @@ iocp_listener_disable_impl(struct evconnlistener *lev, int shutdown)
 		if (!as)
 			continue;
 		EnterCriticalSection(&as->lock);
-		if (!as->free_on_cb && as->s != INVALID_SOCKET) {
+		if (!as->free_on_cb && as->s != EVUTIL_INVALID_SOCKET) {
 			if (shutdown)
 				as->free_on_cb = 1;
 			stop_accepting(as);
diff --git a/ipc/chromium/src/third_party/libevent/log-internal.h b/ipc/chromium/src/third_party/libevent/log-internal.h
index 330478a9edd6..2c31608b25be 100644
--- a/ipc/chromium/src/third_party/libevent/log-internal.h
+++ b/ipc/chromium/src/third_party/libevent/log-internal.h
@@ -29,6 +29,10 @@
 
 #include "event2/util.h"
 
+#ifdef __cplusplus
+extern "C" {
+#endif
+
 #ifdef __GNUC__
 #define EV_CHECK_FMT(a,b) __attribute__((format(printf, a, b)))
 #define EV_NORETURN __attribute__((noreturn))
@@ -39,32 +43,35 @@
 
 #define EVENT_ERR_ABORT_ ((int)0xdeaddead)
 
-#define USE_GLOBAL_FOR_DEBUG_LOGGING
-
 #if !defined(EVENT__DISABLE_DEBUG_MODE) || defined(USE_DEBUG)
 #define EVENT_DEBUG_LOGGING_ENABLED
 #endif
 
 #ifdef EVENT_DEBUG_LOGGING_ENABLED
-#ifdef USE_GLOBAL_FOR_DEBUG_LOGGING
-extern ev_uint32_t event_debug_logging_mask_;
+EVENT2_CORE_EXPORT_SYMBOL extern ev_uint32_t event_debug_logging_mask_;
 #define event_debug_get_logging_mask_() (event_debug_logging_mask_)
 #else
-ev_uint32_t event_debug_get_logging_mask_(void);
-#endif
-#else
 #define event_debug_get_logging_mask_() (0)
 #endif
 
+EVENT2_EXPORT_SYMBOL
 void event_err(int eval, const char *fmt, ...) EV_CHECK_FMT(2,3) EV_NORETURN;
+EVENT2_EXPORT_SYMBOL
 void event_warn(const char *fmt, ...) EV_CHECK_FMT(1,2);
+EVENT2_EXPORT_SYMBOL
 void event_sock_err(int eval, evutil_socket_t sock, const char *fmt, ...) EV_CHECK_FMT(3,4) EV_NORETURN;
+EVENT2_EXPORT_SYMBOL
 void event_sock_warn(evutil_socket_t sock, const char *fmt, ...) EV_CHECK_FMT(2,3);
+EVENT2_EXPORT_SYMBOL
 void event_errx(int eval, const char *fmt, ...) EV_CHECK_FMT(2,3) EV_NORETURN;
+EVENT2_EXPORT_SYMBOL
 void event_warnx(const char *fmt, ...) EV_CHECK_FMT(1,2);
+EVENT2_EXPORT_SYMBOL
 void event_msgx(const char *fmt, ...) EV_CHECK_FMT(1,2);
+EVENT2_EXPORT_SYMBOL
 void event_debugx_(const char *fmt, ...) EV_CHECK_FMT(1,2);
 
+EVENT2_EXPORT_SYMBOL
 void event_logv_(int severity, const char *errstr, const char *fmt, va_list ap)
 	EV_CHECK_FMT(3,0);
 
@@ -80,4 +87,8 @@ void event_logv_(int severity, const char *errstr, const char *fmt, va_list ap)
 
 #undef EV_CHECK_FMT
 
+#ifdef __cplusplus
+}
 #endif
+
+#endif /* LOG_INTERNAL_H_INCLUDED_ */
diff --git a/ipc/chromium/src/third_party/libevent/log.c b/ipc/chromium/src/third_party/libevent/log.c
index e8ae9fdc310e..a9debb864e4f 100644
--- a/ipc/chromium/src/third_party/libevent/log.c
+++ b/ipc/chromium/src/third_party/libevent/log.c
@@ -69,16 +69,7 @@ static event_fatal_cb fatal_fn = NULL;
 #define DEFAULT_MASK 0
 #endif
 
-#ifdef USE_GLOBAL_FOR_DEBUG_LOGGING
-ev_uint32_t event_debug_logging_mask_ = DEFAULT_MASK;
-#else
-static ev_uint32_t event_debug_logging_mask_ = DEFAULT_MASK;
-ev_uint32_t
-event_debug_get_logging_mask_(void)
-{
-	return event_debug_logging_mask_;
-}
-#endif
+EVENT2_EXPORT_SYMBOL ev_uint32_t event_debug_logging_mask_ = DEFAULT_MASK;
 #endif /* EVENT_DEBUG_LOGGING_ENABLED */
 
 void
diff --git a/ipc/chromium/src/third_party/libevent/m4/ax_check_funcs_ex.m4 b/ipc/chromium/src/third_party/libevent/m4/ax_check_funcs_ex.m4
new file mode 100644
index 000000000000..7aaa58b054d5
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/m4/ax_check_funcs_ex.m4
@@ -0,0 +1,22 @@
+# Check if the function is available.
+# HAVE_XXX will be defined if yes.
+
+# $1: the name of function
+# $2: the headers in where the function declared
+AC_DEFUN([AX_CHECK_DECL_EX], [dnl
+	AS_IF([test "x$2" = "x"], [AC_MSG_ERROR([header not privided])])
+	AS_VAR_PUSHDEF([have_func_var], [HAVE_[]m4_toupper($1)])
+	AC_CHECK_DECL([$1],dnl
+		[AC_DEFINE([have_func_var], [1], [Define to 1 if you have the `$1' function.])],,dnl
+		[$2]dnl
+	)
+	AS_VAR_POPDEF([have_func_var])dnl
+])
+
+AC_DEFUN([AX_CHECK_DECLS_EX], [dnl
+	AS_IF([test "x$2" = "x"], [AC_MSG_ERROR([header not privided])])
+	m4_foreach([decl],dnl
+		m4_split(m4_normalize($1)),dnl
+		[AX_CHECK_DECL_EX([decl], [$2])]dnl
+	)
+])
diff --git a/ipc/chromium/src/third_party/libevent/m4/ax_prog_doxygen.m4 b/ipc/chromium/src/third_party/libevent/m4/ax_prog_doxygen.m4
new file mode 100644
index 000000000000..e5bdeb5992dc
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/m4/ax_prog_doxygen.m4
@@ -0,0 +1,600 @@
+# ===========================================================================
+#     https://www.gnu.org/software/autoconf-archive/ax_prog_doxygen.html
+# ===========================================================================
+#
+# SYNOPSIS
+#
+#   DX_INIT_DOXYGEN(PROJECT-NAME, [DOXYFILE-PATH], [OUTPUT-DIR], ...)
+#   DX_DOXYGEN_FEATURE(ON|OFF)
+#   DX_DOT_FEATURE(ON|OFF)
+#   DX_HTML_FEATURE(ON|OFF)
+#   DX_CHM_FEATURE(ON|OFF)
+#   DX_CHI_FEATURE(ON|OFF)
+#   DX_MAN_FEATURE(ON|OFF)
+#   DX_RTF_FEATURE(ON|OFF)
+#   DX_XML_FEATURE(ON|OFF)
+#   DX_PDF_FEATURE(ON|OFF)
+#   DX_PS_FEATURE(ON|OFF)
+#
+# DESCRIPTION
+#
+#   The DX_*_FEATURE macros control the default setting for the given
+#   Doxygen feature. Supported features are 'DOXYGEN' itself, 'DOT' for
+#   generating graphics, 'HTML' for plain HTML, 'CHM' for compressed HTML
+#   help (for MS users), 'CHI' for generating a separate .chi file by the
+#   .chm file, and 'MAN', 'RTF', 'XML', 'PDF' and 'PS' for the appropriate
+#   output formats. The environment variable DOXYGEN_PAPER_SIZE may be
+#   specified to override the default 'a4wide' paper size.
+#
+#   By default, HTML, PDF and PS documentation is generated as this seems to
+#   be the most popular and portable combination. MAN pages created by
+#   Doxygen are usually problematic, though by picking an appropriate subset
+#   and doing some massaging they might be better than nothing. CHM and RTF
+#   are specific for MS (note that you can't generate both HTML and CHM at
+#   the same time). The XML is rather useless unless you apply specialized
+#   post-processing to it.
+#
+#   The macros mainly control the default state of the feature. The use can
+#   override the default by specifying --enable or --disable. The macros
+#   ensure that contradictory flags are not given (e.g.,
+#   --enable-doxygen-html and --enable-doxygen-chm,
+#   --enable-doxygen-anything with --disable-doxygen, etc.) Finally, each
+#   feature will be automatically disabled (with a warning) if the required
+#   programs are missing.
+#
+#   Once all the feature defaults have been specified, call DX_INIT_DOXYGEN
+#   with the following parameters: a one-word name for the project for use
+#   as a filename base etc., an optional configuration file name (the
+#   default is '$(srcdir)/Doxyfile', the same as Doxygen's default), and an
+#   optional output directory name (the default is 'doxygen-doc'). To run
+#   doxygen multiple times for different configuration files and output
+#   directories provide more parameters: the second, forth, sixth, etc
+#   parameter are configuration file names and the third, fifth, seventh,
+#   etc parameter are output directories. No checking is done to catch
+#   duplicates.
+#
+#   Automake Support
+#
+#   The DX_RULES substitution can be used to add all needed rules to the
+#   Makefile. Note that this is a substitution without being a variable:
+#   only the @DX_RULES@ syntax will work.
+#
+#   The provided targets are:
+#
+#     doxygen-doc: Generate all doxygen documentation.
+#
+#     doxygen-run: Run doxygen, which will generate some of the
+#                  documentation (HTML, CHM, CHI, MAN, RTF, XML)
+#                  but will not do the post processing required
+#                  for the rest of it (PS, PDF).
+#
+#     doxygen-ps:  Generate doxygen PostScript documentation.
+#
+#     doxygen-pdf: Generate doxygen PDF documentation.
+#
+#   Note that by default these are not integrated into the automake targets.
+#   If doxygen is used to generate man pages, you can achieve this
+#   integration by setting man3_MANS to the list of man pages generated and
+#   then adding the dependency:
+#
+#     $(man3_MANS): doxygen-doc
+#
+#   This will cause make to run doxygen and generate all the documentation.
+#
+#   The following variable is intended for use in Makefile.am:
+#
+#     DX_CLEANFILES = everything to clean.
+#
+#   Then add this variable to MOSTLYCLEANFILES.
+#
+# LICENSE
+#
+#   Copyright (c) 2009 Oren Ben-Kiki <oren@ben-kiki.org>
+#   Copyright (c) 2015 Olaf Mandel <olaf@mandel.name>
+#
+#   Copying and distribution of this file, with or without modification, are
+#   permitted in any medium without royalty provided the copyright notice
+#   and this notice are preserved. This file is offered as-is, without any
+#   warranty.
+
+#serial 24
+
+## ----------##
+## Defaults. ##
+## ----------##
+
+DX_ENV=""
+AC_DEFUN([DX_FEATURE_doc],  OFF)
+AC_DEFUN([DX_FEATURE_dot],  OFF)
+AC_DEFUN([DX_FEATURE_man],  OFF)
+AC_DEFUN([DX_FEATURE_html], ON)
+AC_DEFUN([DX_FEATURE_chm],  OFF)
+AC_DEFUN([DX_FEATURE_chi],  OFF)
+AC_DEFUN([DX_FEATURE_rtf],  OFF)
+AC_DEFUN([DX_FEATURE_xml],  OFF)
+AC_DEFUN([DX_FEATURE_pdf],  ON)
+AC_DEFUN([DX_FEATURE_ps],   ON)
+
+## --------------- ##
+## Private macros. ##
+## --------------- ##
+
+# DX_ENV_APPEND(VARIABLE, VALUE)
+# ------------------------------
+# Append VARIABLE="VALUE" to DX_ENV for invoking doxygen and add it
+# as a substitution (but not a Makefile variable). The substitution
+# is skipped if the variable name is VERSION.
+AC_DEFUN([DX_ENV_APPEND],
+[AC_SUBST([DX_ENV], ["$DX_ENV $1='$2'"])dnl
+m4_if([$1], [VERSION], [], [AC_SUBST([$1], [$2])dnl
+AM_SUBST_NOTMAKE([$1])])dnl
+])
+
+# DX_DIRNAME_EXPR
+# ---------------
+# Expand into a shell expression prints the directory part of a path.
+AC_DEFUN([DX_DIRNAME_EXPR],
+         [[expr ".$1" : '\(\.\)[^/]*$' \| "x$1" : 'x\(.*\)/[^/]*$']])
+
+# DX_IF_FEATURE(FEATURE, IF-ON, IF-OFF)
+# -------------------------------------
+# Expands according to the M4 (static) status of the feature.
+AC_DEFUN([DX_IF_FEATURE], [ifelse(DX_FEATURE_$1, ON, [$2], [$3])])
+
+# DX_REQUIRE_PROG(VARIABLE, PROGRAM)
+# ----------------------------------
+# Require the specified program to be found for the DX_CURRENT_FEATURE to work.
+AC_DEFUN([DX_REQUIRE_PROG], [
+AC_PATH_TOOL([$1], [$2])
+if test "$DX_FLAG_[]DX_CURRENT_FEATURE$$1" = 1; then
+    if test "x$2" = "xdoxygen"; then
+        AC_MSG_ERROR([$2 not found - will not DX_CURRENT_DESCRIPTION])
+    else
+        AC_MSG_WARN([$2 not found - will not DX_CURRENT_DESCRIPTION])
+    fi
+    AC_SUBST(DX_FLAG_[]DX_CURRENT_FEATURE, 0)
+fi
+])
+
+# DX_TEST_FEATURE(FEATURE)
+# ------------------------
+# Expand to a shell expression testing whether the feature is active.
+AC_DEFUN([DX_TEST_FEATURE], [test "$DX_FLAG_$1" = 1])
+
+# DX_CHECK_DEPEND(REQUIRED_FEATURE, REQUIRED_STATE)
+# -------------------------------------------------
+# Verify that a required features has the right state before trying to turn on
+# the DX_CURRENT_FEATURE.
+AC_DEFUN([DX_CHECK_DEPEND], [
+test "$DX_FLAG_$1" = "$2" \
+|| AC_MSG_ERROR([doxygen-DX_CURRENT_FEATURE ifelse([$2], 1,
+                            requires, contradicts) doxygen-$1])
+])
+
+# DX_CLEAR_DEPEND(FEATURE, REQUIRED_FEATURE, REQUIRED_STATE)
+# ----------------------------------------------------------
+# Turn off the DX_CURRENT_FEATURE if the required feature is off.
+AC_DEFUN([DX_CLEAR_DEPEND], [
+test "$DX_FLAG_$1" = "$2" || AC_SUBST(DX_FLAG_[]DX_CURRENT_FEATURE, 0)
+])
+
+# DX_FEATURE_ARG(FEATURE, DESCRIPTION,
+#                CHECK_DEPEND, CLEAR_DEPEND,
+#                REQUIRE, DO-IF-ON, DO-IF-OFF)
+# --------------------------------------------
+# Parse the command-line option controlling a feature. CHECK_DEPEND is called
+# if the user explicitly turns the feature on (and invokes DX_CHECK_DEPEND),
+# otherwise CLEAR_DEPEND is called to turn off the default state if a required
+# feature is disabled (using DX_CLEAR_DEPEND). REQUIRE performs additional
+# requirement tests (DX_REQUIRE_PROG). Finally, an automake flag is set and
+# DO-IF-ON or DO-IF-OFF are called according to the final state of the feature.
+AC_DEFUN([DX_ARG_ABLE], [
+    AC_DEFUN([DX_CURRENT_FEATURE], [$1])
+    AC_DEFUN([DX_CURRENT_DESCRIPTION], [$2])
+    AC_ARG_ENABLE(doxygen-$1,
+                  [AS_HELP_STRING(DX_IF_FEATURE([$1], [--disable-doxygen-$1],
+                                                      [--enable-doxygen-$1]),
+                                  DX_IF_FEATURE([$1], [don't $2], [$2]))],
+                  [
+case "$enableval" in
+#(
+y|Y|yes|Yes|YES)
+    AC_SUBST([DX_FLAG_$1], 1)
+    $3
+;; #(
+n|N|no|No|NO)
+    AC_SUBST([DX_FLAG_$1], 0)
+;; #(
+*)
+    AC_MSG_ERROR([invalid value '$enableval' given to doxygen-$1])
+;;
+esac
+], [
+AC_SUBST([DX_FLAG_$1], [DX_IF_FEATURE([$1], 1, 0)])
+$4
+])
+if DX_TEST_FEATURE([$1]); then
+    $5
+    :
+fi
+if DX_TEST_FEATURE([$1]); then
+    $6
+    :
+else
+    $7
+    :
+fi
+])
+
+## -------------- ##
+## Public macros. ##
+## -------------- ##
+
+# DX_XXX_FEATURE(DEFAULT_STATE)
+# -----------------------------
+AC_DEFUN([DX_DOXYGEN_FEATURE], [AC_DEFUN([DX_FEATURE_doc],  [$1])])
+AC_DEFUN([DX_DOT_FEATURE],     [AC_DEFUN([DX_FEATURE_dot], [$1])])
+AC_DEFUN([DX_MAN_FEATURE],     [AC_DEFUN([DX_FEATURE_man],  [$1])])
+AC_DEFUN([DX_HTML_FEATURE],    [AC_DEFUN([DX_FEATURE_html], [$1])])
+AC_DEFUN([DX_CHM_FEATURE],     [AC_DEFUN([DX_FEATURE_chm],  [$1])])
+AC_DEFUN([DX_CHI_FEATURE],     [AC_DEFUN([DX_FEATURE_chi],  [$1])])
+AC_DEFUN([DX_RTF_FEATURE],     [AC_DEFUN([DX_FEATURE_rtf],  [$1])])
+AC_DEFUN([DX_XML_FEATURE],     [AC_DEFUN([DX_FEATURE_xml],  [$1])])
+AC_DEFUN([DX_XML_FEATURE],     [AC_DEFUN([DX_FEATURE_xml],  [$1])])
+AC_DEFUN([DX_PDF_FEATURE],     [AC_DEFUN([DX_FEATURE_pdf],  [$1])])
+AC_DEFUN([DX_PS_FEATURE],      [AC_DEFUN([DX_FEATURE_ps],   [$1])])
+
+# DX_INIT_DOXYGEN(PROJECT, [CONFIG-FILE], [OUTPUT-DOC-DIR], ...)
+# --------------------------------------------------------------
+# PROJECT also serves as the base name for the documentation files.
+# The default CONFIG-FILE is "$(srcdir)/Doxyfile" and OUTPUT-DOC-DIR is
+# "doxygen-doc".
+# More arguments are interpreted as interleaved CONFIG-FILE and
+# OUTPUT-DOC-DIR values.
+AC_DEFUN([DX_INIT_DOXYGEN], [
+
+# Files:
+AC_SUBST([DX_PROJECT], [$1])
+AC_SUBST([DX_CONFIG], ['ifelse([$2], [], [$(srcdir)/Doxyfile], [$2])'])
+AC_SUBST([DX_DOCDIR], ['ifelse([$3], [], [doxygen-doc], [$3])'])
+m4_if(m4_eval(3 < m4_count($@)), 1, [m4_for([DX_i], 4, m4_count($@), 2,
+      [AC_SUBST([DX_CONFIG]m4_eval(DX_i[/2]),
+                'm4_default_nblank_quoted(m4_argn(DX_i, $@),
+                                          [$(srcdir)/Doxyfile])')])])dnl
+m4_if(m4_eval(3 < m4_count($@)), 1, [m4_for([DX_i], 5, m4_count($@,), 2,
+      [AC_SUBST([DX_DOCDIR]m4_eval([(]DX_i[-1)/2]),
+                'm4_default_nblank_quoted(m4_argn(DX_i, $@),
+                                          [doxygen-doc])')])])dnl
+m4_define([DX_loop], m4_dquote(m4_if(m4_eval(3 < m4_count($@)), 1,
+          [m4_for([DX_i], 4, m4_count($@), 2, [, m4_eval(DX_i[/2])])],
+          [])))dnl
+
+# Environment variables used inside doxygen.cfg:
+DX_ENV_APPEND(SRCDIR, $srcdir)
+DX_ENV_APPEND(PROJECT, $DX_PROJECT)
+DX_ENV_APPEND(VERSION, $PACKAGE_VERSION)
+
+# Doxygen itself:
+DX_ARG_ABLE(doc, [generate any doxygen documentation],
+            [],
+            [],
+            [DX_REQUIRE_PROG([DX_DOXYGEN], doxygen)
+             DX_REQUIRE_PROG([DX_PERL], perl)],
+            [DX_ENV_APPEND(PERL_PATH, $DX_PERL)])
+
+# Dot for graphics:
+DX_ARG_ABLE(dot, [generate graphics for doxygen documentation],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [DX_REQUIRE_PROG([DX_DOT], dot)],
+            [DX_ENV_APPEND(HAVE_DOT, YES)
+             DX_ENV_APPEND(DOT_PATH, [`DX_DIRNAME_EXPR($DX_DOT)`])],
+            [DX_ENV_APPEND(HAVE_DOT, NO)])
+
+# Man pages generation:
+DX_ARG_ABLE(man, [generate doxygen manual pages],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [],
+            [DX_ENV_APPEND(GENERATE_MAN, YES)],
+            [DX_ENV_APPEND(GENERATE_MAN, NO)])
+
+# RTF file generation:
+DX_ARG_ABLE(rtf, [generate doxygen RTF documentation],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [],
+            [DX_ENV_APPEND(GENERATE_RTF, YES)],
+            [DX_ENV_APPEND(GENERATE_RTF, NO)])
+
+# XML file generation:
+DX_ARG_ABLE(xml, [generate doxygen XML documentation],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [],
+            [DX_ENV_APPEND(GENERATE_XML, YES)],
+            [DX_ENV_APPEND(GENERATE_XML, NO)])
+
+# (Compressed) HTML help generation:
+DX_ARG_ABLE(chm, [generate doxygen compressed HTML help documentation],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [DX_REQUIRE_PROG([DX_HHC], hhc)],
+            [DX_ENV_APPEND(HHC_PATH, $DX_HHC)
+             DX_ENV_APPEND(GENERATE_HTML, YES)
+             DX_ENV_APPEND(GENERATE_HTMLHELP, YES)],
+            [DX_ENV_APPEND(GENERATE_HTMLHELP, NO)])
+
+# Separate CHI file generation.
+DX_ARG_ABLE(chi, [generate doxygen separate compressed HTML help index file],
+            [DX_CHECK_DEPEND(chm, 1)],
+            [DX_CLEAR_DEPEND(chm, 1)],
+            [],
+            [DX_ENV_APPEND(GENERATE_CHI, YES)],
+            [DX_ENV_APPEND(GENERATE_CHI, NO)])
+
+# Plain HTML pages generation:
+DX_ARG_ABLE(html, [generate doxygen plain HTML documentation],
+            [DX_CHECK_DEPEND(doc, 1) DX_CHECK_DEPEND(chm, 0)],
+            [DX_CLEAR_DEPEND(doc, 1) DX_CLEAR_DEPEND(chm, 0)],
+            [],
+            [DX_ENV_APPEND(GENERATE_HTML, YES)],
+            [DX_TEST_FEATURE(chm) || DX_ENV_APPEND(GENERATE_HTML, NO)])
+
+# PostScript file generation:
+DX_ARG_ABLE(ps, [generate doxygen PostScript documentation],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [DX_REQUIRE_PROG([DX_LATEX], latex)
+             DX_REQUIRE_PROG([DX_MAKEINDEX], makeindex)
+             DX_REQUIRE_PROG([DX_DVIPS], dvips)
+             DX_REQUIRE_PROG([DX_EGREP], egrep)])
+
+# PDF file generation:
+DX_ARG_ABLE(pdf, [generate doxygen PDF documentation],
+            [DX_CHECK_DEPEND(doc, 1)],
+            [DX_CLEAR_DEPEND(doc, 1)],
+            [DX_REQUIRE_PROG([DX_PDFLATEX], pdflatex)
+             DX_REQUIRE_PROG([DX_MAKEINDEX], makeindex)
+             DX_REQUIRE_PROG([DX_EGREP], egrep)])
+
+# LaTeX generation for PS and/or PDF:
+if DX_TEST_FEATURE(ps) || DX_TEST_FEATURE(pdf); then
+    DX_ENV_APPEND(GENERATE_LATEX, YES)
+else
+    DX_ENV_APPEND(GENERATE_LATEX, NO)
+fi
+
+# Paper size for PS and/or PDF:
+AC_ARG_VAR(DOXYGEN_PAPER_SIZE,
+           [a4wide (default), a4, letter, legal or executive])
+case "$DOXYGEN_PAPER_SIZE" in
+#(
+"")
+    AC_SUBST(DOXYGEN_PAPER_SIZE, "")
+;; #(
+a4wide|a4|letter|legal|executive)
+    DX_ENV_APPEND(PAPER_SIZE, $DOXYGEN_PAPER_SIZE)
+;; #(
+*)
+    AC_MSG_ERROR([unknown DOXYGEN_PAPER_SIZE='$DOXYGEN_PAPER_SIZE'])
+;;
+esac
+
+# Rules:
+AS_IF([[test $DX_FLAG_html -eq 1]],
+[[DX_SNIPPET_html="## ------------------------------- ##
+## Rules specific for HTML output. ##
+## ------------------------------- ##
+
+DX_CLEAN_HTML = \$(DX_DOCDIR)/html]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+                \$(DX_DOCDIR]DX_i[)/html]])[
+
+"]],
+[[DX_SNIPPET_html=""]])
+AS_IF([[test $DX_FLAG_chi -eq 1]],
+[[DX_SNIPPET_chi="
+DX_CLEAN_CHI = \$(DX_DOCDIR)/\$(PACKAGE).chi]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+               \$(DX_DOCDIR]DX_i[)/\$(PACKAGE).chi]])["]],
+[[DX_SNIPPET_chi=""]])
+AS_IF([[test $DX_FLAG_chm -eq 1]],
+[[DX_SNIPPET_chm="## ------------------------------ ##
+## Rules specific for CHM output. ##
+## ------------------------------ ##
+
+DX_CLEAN_CHM = \$(DX_DOCDIR)/chm]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+               \$(DX_DOCDIR]DX_i[)/chm]])[\
+${DX_SNIPPET_chi}
+
+"]],
+[[DX_SNIPPET_chm=""]])
+AS_IF([[test $DX_FLAG_man -eq 1]],
+[[DX_SNIPPET_man="## ------------------------------ ##
+## Rules specific for MAN output. ##
+## ------------------------------ ##
+
+DX_CLEAN_MAN = \$(DX_DOCDIR)/man]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+               \$(DX_DOCDIR]DX_i[)/man]])[
+
+"]],
+[[DX_SNIPPET_man=""]])
+AS_IF([[test $DX_FLAG_rtf -eq 1]],
+[[DX_SNIPPET_rtf="## ------------------------------ ##
+## Rules specific for RTF output. ##
+## ------------------------------ ##
+
+DX_CLEAN_RTF = \$(DX_DOCDIR)/rtf]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+               \$(DX_DOCDIR]DX_i[)/rtf]])[
+
+"]],
+[[DX_SNIPPET_rtf=""]])
+AS_IF([[test $DX_FLAG_xml -eq 1]],
+[[DX_SNIPPET_xml="## ------------------------------ ##
+## Rules specific for XML output. ##
+## ------------------------------ ##
+
+DX_CLEAN_XML = \$(DX_DOCDIR)/xml]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+               \$(DX_DOCDIR]DX_i[)/xml]])[
+
+"]],
+[[DX_SNIPPET_xml=""]])
+AS_IF([[test $DX_FLAG_ps -eq 1]],
+[[DX_SNIPPET_ps="## ----------------------------- ##
+## Rules specific for PS output. ##
+## ----------------------------- ##
+
+DX_CLEAN_PS = \$(DX_DOCDIR)/\$(PACKAGE).ps]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+              \$(DX_DOCDIR]DX_i[)/\$(PACKAGE).ps]])[
+
+DX_PS_GOAL = doxygen-ps
+
+doxygen-ps: \$(DX_CLEAN_PS)
+
+]m4_foreach([DX_i], [DX_loop],
+[[\$(DX_DOCDIR]DX_i[)/\$(PACKAGE).ps: \$(DX_DOCDIR]DX_i[)/\$(PACKAGE).tag
+	\$(DX_V_LATEX)cd \$(DX_DOCDIR]DX_i[)/latex; \\
+	rm -f *.aux *.toc *.idx *.ind *.ilg *.log *.out; \\
+	\$(DX_LATEX) refman.tex; \\
+	\$(DX_MAKEINDEX) refman.idx; \\
+	\$(DX_LATEX) refman.tex; \\
+	countdown=5; \\
+	while \$(DX_EGREP) 'Rerun (LaTeX|to get cross-references right)' \\
+	                  refman.log > /dev/null 2>&1 \\
+	   && test \$\$countdown -gt 0; do \\
+	    \$(DX_LATEX) refman.tex; \\
+            countdown=\`expr \$\$countdown - 1\`; \\
+	done; \\
+	\$(DX_DVIPS) -o ../\$(PACKAGE).ps refman.dvi
+
+]])["]],
+[[DX_SNIPPET_ps=""]])
+AS_IF([[test $DX_FLAG_pdf -eq 1]],
+[[DX_SNIPPET_pdf="## ------------------------------ ##
+## Rules specific for PDF output. ##
+## ------------------------------ ##
+
+DX_CLEAN_PDF = \$(DX_DOCDIR)/\$(PACKAGE).pdf]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+               \$(DX_DOCDIR]DX_i[)/\$(PACKAGE).pdf]])[
+
+DX_PDF_GOAL = doxygen-pdf
+
+doxygen-pdf: \$(DX_CLEAN_PDF)
+
+]m4_foreach([DX_i], [DX_loop],
+[[\$(DX_DOCDIR]DX_i[)/\$(PACKAGE).pdf: \$(DX_DOCDIR]DX_i[)/\$(PACKAGE).tag
+	\$(DX_V_LATEX)cd \$(DX_DOCDIR]DX_i[)/latex; \\
+	rm -f *.aux *.toc *.idx *.ind *.ilg *.log *.out; \\
+	\$(DX_PDFLATEX) refman.tex; \\
+	\$(DX_MAKEINDEX) refman.idx; \\
+	\$(DX_PDFLATEX) refman.tex; \\
+	countdown=5; \\
+	while \$(DX_EGREP) 'Rerun (LaTeX|to get cross-references right)' \\
+	                  refman.log > /dev/null 2>&1 \\
+	   && test \$\$countdown -gt 0; do \\
+	    \$(DX_PDFLATEX) refman.tex; \\
+	    countdown=\`expr \$\$countdown - 1\`; \\
+	done; \\
+	mv refman.pdf ../\$(PACKAGE).pdf
+
+]])["]],
+[[DX_SNIPPET_pdf=""]])
+AS_IF([[test $DX_FLAG_ps -eq 1 -o $DX_FLAG_pdf -eq 1]],
+[[DX_SNIPPET_latex="## ------------------------------------------------- ##
+## Rules specific for LaTeX (shared for PS and PDF). ##
+## ------------------------------------------------- ##
+
+DX_V_LATEX = \$(_DX_v_LATEX_\$(V))
+_DX_v_LATEX_ = \$(_DX_v_LATEX_\$(AM_DEFAULT_VERBOSITY))
+_DX_v_LATEX_0 = @echo \"  LATEX \" \$][@;
+
+DX_CLEAN_LATEX = \$(DX_DOCDIR)/latex]dnl
+m4_foreach([DX_i], [m4_shift(DX_loop)], [[\\
+                 \$(DX_DOCDIR]DX_i[)/latex]])[
+
+"]],
+[[DX_SNIPPET_latex=""]])
+
+AS_IF([[test $DX_FLAG_doc -eq 1]],
+[[DX_SNIPPET_doc="## --------------------------------- ##
+## Format-independent Doxygen rules. ##
+## --------------------------------- ##
+
+${DX_SNIPPET_html}\
+${DX_SNIPPET_chm}\
+${DX_SNIPPET_man}\
+${DX_SNIPPET_rtf}\
+${DX_SNIPPET_xml}\
+${DX_SNIPPET_ps}\
+${DX_SNIPPET_pdf}\
+${DX_SNIPPET_latex}\
+DX_V_DXGEN = \$(_DX_v_DXGEN_\$(V))
+_DX_v_DXGEN_ = \$(_DX_v_DXGEN_\$(AM_DEFAULT_VERBOSITY))
+_DX_v_DXGEN_0 = @echo \"  DXGEN \" \$<;
+
+.PHONY: doxygen-run doxygen-doc \$(DX_PS_GOAL) \$(DX_PDF_GOAL)
+
+.INTERMEDIATE: doxygen-run \$(DX_PS_GOAL) \$(DX_PDF_GOAL)
+
+doxygen-run:]m4_foreach([DX_i], [DX_loop],
+                         [[ \$(DX_DOCDIR]DX_i[)/\$(PACKAGE).tag]])[
+
+doxygen-doc: doxygen-run \$(DX_PS_GOAL) \$(DX_PDF_GOAL)
+
+]m4_foreach([DX_i], [DX_loop],
+[[\$(DX_DOCDIR]DX_i[)/\$(PACKAGE).tag: \$(DX_CONFIG]DX_i[) \$(pkginclude_HEADERS)
+	\$(A""M_V_at)rm -rf \$(DX_DOCDIR]DX_i[)
+	\$(DX_V_DXGEN)\$(DX_ENV) DOCDIR=\$(DX_DOCDIR]DX_i[) \$(DX_DOXYGEN) \$(DX_CONFIG]DX_i[)
+	\$(A""M_V_at)echo Timestamp >\$][@
+
+]])dnl
+[DX_CLEANFILES = \\]
+m4_foreach([DX_i], [DX_loop],
+[[	\$(DX_DOCDIR]DX_i[)/doxygen_sqlite3.db \\
+	\$(DX_DOCDIR]DX_i[)/\$(PACKAGE).tag \\
+]])dnl
+[	-r \\
+	\$(DX_CLEAN_HTML) \\
+	\$(DX_CLEAN_CHM) \\
+	\$(DX_CLEAN_CHI) \\
+	\$(DX_CLEAN_MAN) \\
+	\$(DX_CLEAN_RTF) \\
+	\$(DX_CLEAN_XML) \\
+	\$(DX_CLEAN_PS) \\
+	\$(DX_CLEAN_PDF) \\
+	\$(DX_CLEAN_LATEX)
+DX_INSTALL_DOCS = \\
+	\$(DX_CLEAN_HTML) \\
+	\$(DX_CLEAN_CHM) \\
+	\$(DX_CLEAN_CHI) \\
+	\$(DX_CLEAN_RTF) \\
+	\$(DX_CLEAN_XML) \\
+	\$(DX_CLEAN_PS) \\
+	\$(DX_CLEAN_PDF) \\
+	\$(DX_CLEAN_LATEX)
+    "]],
+[[DX_SNIPPET_doc=""]])
+AC_SUBST([DX_RULES],
+["${DX_SNIPPET_doc}"])dnl
+AM_SUBST_NOTMAKE([DX_RULES])
+
+#For debugging:
+#echo DX_FLAG_doc=$DX_FLAG_doc
+#echo DX_FLAG_dot=$DX_FLAG_dot
+#echo DX_FLAG_man=$DX_FLAG_man
+#echo DX_FLAG_html=$DX_FLAG_html
+#echo DX_FLAG_chm=$DX_FLAG_chm
+#echo DX_FLAG_chi=$DX_FLAG_chi
+#echo DX_FLAG_rtf=$DX_FLAG_rtf
+#echo DX_FLAG_xml=$DX_FLAG_xml
+#echo DX_FLAG_pdf=$DX_FLAG_pdf
+#echo DX_FLAG_ps=$DX_FLAG_ps
+#echo DX_ENV=$DX_ENV
+])
diff --git a/ipc/chromium/src/third_party/libevent/m4/libevent_openssl.m4 b/ipc/chromium/src/third_party/libevent/m4/libevent_openssl.m4
index c20405950319..a5ea67620067 100644
--- a/ipc/chromium/src/third_party/libevent/m4/libevent_openssl.m4
+++ b/ipc/chromium/src/third_party/libevent/m4/libevent_openssl.m4
@@ -39,10 +39,19 @@ case "$enable_openssl" in
 	done
 	;;
     esac
+    CPPFLAGS_SAVE=$CPPFLAGS
+    CPPFLAGS="$CPPFLAGS $OPENSSL_INCS"
+    AC_CHECK_HEADERS([openssl/ssl.h], [], [have_openssl=no])
+    CPPFLAGS=$CPPFLAGS_SAVE
     AC_SUBST(OPENSSL_INCS)
     AC_SUBST(OPENSSL_LIBS)
     case "$have_openssl" in
      yes)  AC_DEFINE(HAVE_OPENSSL, 1, [Define if the system has openssl]) ;;
+     *) AC_MSG_ERROR([openssl is a must but can not be found. You should add the \
+directory containing `openssl.pc' to the `PKG_CONFIG_PATH' environment variable, \
+or set `CFLAGS' and `LDFLAGS' directly for openssl, or use `--disable-openssl' \
+to disable support for openssl encryption])
+	;;
     esac
     ;;
 esac
diff --git a/ipc/chromium/src/third_party/libevent/mac/event2/event-config.h b/ipc/chromium/src/third_party/libevent/mac/event2/event-config.h
index e4ad1e2edb28..e9a71e476732 100644
--- a/ipc/chromium/src/third_party/libevent/mac/event2/event-config.h
+++ b/ipc/chromium/src/third_party/libevent/mac/event2/event-config.h
@@ -26,9 +26,15 @@
 /* Define to 1 if you have the `accept4' function. */
 /* #undef EVENT__HAVE_ACCEPT4 */
 
+/* Define to 1 if you have the <afunix.h> header file. */
+/* #undef EVENT__HAVE_AFUNIX_H */
+
 /* Define to 1 if you have the `arc4random' function. */
 #define EVENT__HAVE_ARC4RANDOM 1
 
+/* Define to 1 if you have the `arc4random_addrandom' function. */
+#define EVENT__HAVE_ARC4RANDOM_ADDRANDOM 1
+
 /* Define to 1 if you have the `arc4random_buf' function. */
 #define EVENT__HAVE_ARC4RANDOM_BUF 1
 
@@ -46,14 +52,6 @@
    don't. */
 #define EVENT__HAVE_DECL_KERN_ARND 0
 
-/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if you
-   don't. */
-#define EVENT__HAVE_DECL_KERN_RANDOM 0
-
-/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if you
-   don't. */
-#define EVENT__HAVE_DECL_RANDOM_UUID 0
-
 /* Define if /dev/poll is available */
 /* #undef EVENT__HAVE_DEVPOLL */
 
@@ -72,9 +70,6 @@
 /* Define to 1 if you have the <errno.h> header file. */
 #define EVENT__HAVE_ERRNO_H 1
 
-/* Define to 1 if you have ERR_remove_thread_stat(). */
-/* #undef EVENT__HAVE_ERR_REMOVE_THREAD_STATE */
-
 /* Define to 1 if you have the `eventfd' function. */
 /* #undef EVENT__HAVE_EVENTFD */
 
@@ -120,6 +115,9 @@
 /* Define to 1 if you have the `getprotobynumber' function. */
 #define EVENT__HAVE_GETPROTOBYNUMBER 1
 
+/* Define to 1 if you have the `getrandom' function. */
+/* #undef EVENT__HAVE_GETRANDOM */
+
 /* Define to 1 if you have the `getservbyname' function. */
 #define EVENT__HAVE_GETSERVBYNAME 1
 
@@ -144,9 +142,15 @@
 /* Define to 1 if you have the `kqueue' function. */
 #define EVENT__HAVE_KQUEUE 1
 
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef EVENT__HAVE_LIBWS2_32 */
+
 /* Define if the system has zlib */
 #define EVENT__HAVE_LIBZ 1
 
+/* Define to 1 if you have the <mach/mach.h> header file. */
+#define EVENT__HAVE_MACH_MACH_H 1
+
 /* Define to 1 if you have the `mach_absolute_time' function. */
 #define EVENT__HAVE_MACH_ABSOLUTE_TIME 1
 
@@ -177,6 +181,9 @@
 /* Define if the system has openssl */
 /* #undef EVENT__HAVE_OPENSSL */
 
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+/* #undef EVENT__HAVE_OPENSSL_SSL_H */
+
 /* Define to 1 if you have the `pipe' function. */
 #define EVENT__HAVE_PIPE 1
 
@@ -273,6 +280,9 @@
 /* Define to 1 if `s6_addr32' is a member of `struct in6_addr'. */
 /* #undef EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 */
 
+/* Define to 1 if the system has the type `struct linger'. */
+#define EVENT__HAVE_STRUCT_LINGER 1
+
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
 #define EVENT__HAVE_STRUCT_SOCKADDR_IN6 1
 
@@ -291,8 +301,8 @@
 /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
 /* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
 
-/* Define to 1 if the system has the type `struct so_linger'. */
-#define EVENT__HAVE_STRUCT_SO_LINGER 1
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define EVENT__HAVE_STRUCT_SOCKADDR_UN 1
 
 /* Define to 1 if you have the `sysctl' function. */
 #define EVENT__HAVE_SYSCTL 1
@@ -321,6 +331,9 @@
 /* Define to 1 if you have the <sys/queue.h> header file. */
 #define EVENT__HAVE_SYS_QUEUE_H 1
 
+/* Define to 1 if you have the <sys/random.h> header file. */
+/* #undef EVENT__HAVE_SYS_RANDOM_H */
+
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #define EVENT__HAVE_SYS_RESOURCE_H 1
 
@@ -351,6 +364,9 @@
 /* Define to 1 if you have the <sys/uio.h> header file. */
 #define EVENT__HAVE_SYS_UIO_H 1
 
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define EVENT__HAVE_SYS_UN_H 1
+
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #define EVENT__HAVE_SYS_WAIT_H 1
 
@@ -402,20 +418,29 @@
 /* Define to 1 if you have the `vasprintf' function. */
 #define EVENT__HAVE_VASPRINTF 1
 
-/* Define if waitpid() supports WNOWAIT */
-/* #undef EVENT__HAVE_WAITPID_WITH_WNOWAIT */
-
 /* Define if kqueue works correctly with pipes */
 #define EVENT__HAVE_WORKING_KQUEUE 1
 
 /* Define to 1 if you have the <zlib.h> header file. */
 #define EVENT__HAVE_ZLIB_H 1
 
+/* Define to 1 if you have the `_gmtime64' function. */
+/* #undef EVENT__HAVE__GMTIME64 */
+
+/* Define to 1 if you have the `_gmtime64_s' function. */
+/* #undef EVENT__HAVE__GMTIME64_S */
+
+/* Define to 1 if compiler have __FUNCTION__ */
+#define EVENT__HAVE___FUNCTION__ 1
+
+/* Define to 1 if compiler have __func__ */
+#define EVENT__HAVE___func__ 1
+
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define EVENT__LT_OBJDIR ".libs/"
 
 /* Numeric representation of the version */
-#define EVENT__NUMERIC_VERSION 0x02010800
+#define EVENT__NUMERIC_VERSION 0x02010c00
 
 /* Name of package */
 #define EVENT__PACKAGE "libevent"
@@ -427,7 +452,7 @@
 #define EVENT__PACKAGE_NAME "libevent"
 
 /* Define to the full name and version of this package. */
-#define EVENT__PACKAGE_STRING "libevent 2.1.8-stable"
+#define EVENT__PACKAGE_STRING "libevent 2.1.12-stable"
 
 /* Define to the one symbol short name of this package. */
 #define EVENT__PACKAGE_TARNAME "libevent"
@@ -436,7 +461,7 @@
 #define EVENT__PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define EVENT__PACKAGE_VERSION "2.1.8-stable"
+#define EVENT__PACKAGE_VERSION "2.1.12-stable"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -463,83 +488,86 @@
 /* The size of `size_t', as computed by sizeof. */
 #define EVENT__SIZEOF_SIZE_T 8
 
+/* The size of `time_t', as computed by sizeof. */
+#define EVENT__SIZEOF_TIME_T 8
+
 /* The size of `void *', as computed by sizeof. */
 #define EVENT__SIZEOF_VOID_P 8
 
 /* Define to 1 if you have the ANSI C header files. */
-#define EVENT__STDC_HEADERS 1
+#define STDC_HEADERS 1
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #define EVENT__TIME_WITH_SYS_TIME 1
 
 /* Enable extensions on AIX 3, Interix.  */
-#ifndef EVENT___ALL_SOURCE
-# define EVENT___ALL_SOURCE 1
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
 #endif
 /* Enable GNU extensions on systems that have them.  */
-#ifndef EVENT___GNU_SOURCE
-# define EVENT___GNU_SOURCE 1
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
 #endif
 /* Enable threading extensions on Solaris.  */
-#ifndef EVENT___POSIX_PTHREAD_SEMANTICS
-# define EVENT___POSIX_PTHREAD_SEMANTICS 1
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
 #endif
 /* Enable extensions on HP NonStop.  */
-#ifndef EVENT___TANDEM_SOURCE
-# define EVENT___TANDEM_SOURCE 1
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
 #endif
 /* Enable general extensions on Solaris.  */
-#ifndef EVENT____EXTENSIONS__
-# define EVENT____EXTENSIONS__ 1
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
 #endif
 
 
 /* Version number of package */
-#define EVENT__VERSION "2.1.8-stable"
+#define EVENT__VERSION "2.1.12-stable"
 
 /* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef EVENT___DARWIN_USE_64_BIT_INODE
-# define EVENT___DARWIN_USE_64_BIT_INODE 1
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
 #endif
 
 /* Number of bits in a file offset, on hosts where this is settable. */
-/* #undef EVENT___FILE_OFFSET_BITS */
+/* #undef _FILE_OFFSET_BITS */
 
 /* Define for large files, on AIX-style hosts. */
-/* #undef EVENT___LARGE_FILES */
+/* #undef _LARGE_FILES */
 
 /* Define to 1 if on MINIX. */
-/* #undef EVENT___MINIX */
+/* #undef _MINIX */
 
 /* Define to 2 if the system does not provide POSIX.1 features except with
    this defined. */
-/* #undef EVENT___POSIX_1_SOURCE */
+/* #undef _POSIX_1_SOURCE */
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
-/* #undef EVENT___POSIX_SOURCE */
+/* #undef _POSIX_SOURCE */
 
 /* Define to appropriate substitue if compiler doesnt have __func__ */
-/* #undef EVENT____func__ */
+/* #undef __func__ */
 
 /* Define to empty if `const' does not conform to ANSI C. */
-/* #undef EVENT__const */
+/* #undef const */
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef EVENT____cplusplus
-/* #undef EVENT__inline */
+#ifndef __cplusplus
+/* #undef inline */
 #endif
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__pid_t */
+/* #undef pid_t */
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef EVENT__size_t */
+/* #undef size_t */
 
 /* Define to unsigned int if you dont have it */
-/* #undef EVENT__socklen_t */
+/* #undef socklen_t */
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__ssize_t */
+/* #undef ssize_t */
 
 #endif /* event2/event-config.h */
diff --git a/ipc/chromium/src/third_party/libevent/make-event-config.sed b/ipc/chromium/src/third_party/libevent/make-event-config.sed
index e31018a2dd55..3dc404b5cc47 100644
--- a/ipc/chromium/src/third_party/libevent/make-event-config.sed
+++ b/ipc/chromium/src/third_party/libevent/make-event-config.sed
@@ -18,6 +18,10 @@ $a\
 \
 #endif /* event2/event-config.h */
 
-s/#\( *\)define /#\1define EVENT__/
-s/#\( *\)undef /#\1undef EVENT__/
-s/#\( *\)if\(n*\)def /#\1if\2def EVENT__/
+/#\( *\)undef STDC_HEADERS\>/b
+/#\( *\)define STDC_HEADERS\>/b
+
+# Only rewrite symbols starting with capitals
+s/#\( *\)define \([A-Z]\)/#\1define EVENT__\2/
+s/#\( *\)undef \([A-Z]\)/#\1undef EVENT__\2/
+s/#\( *\)if\(n*\)def \([A-Z]\)/#\1if\2def EVENT__\2/
diff --git a/ipc/chromium/src/third_party/libevent/minheap-internal.h b/ipc/chromium/src/third_party/libevent/minheap-internal.h
index b3b6f1fd497e..b3a0eb1fb589 100644
--- a/ipc/chromium/src/third_party/libevent/minheap-internal.h
+++ b/ipc/chromium/src/third_party/libevent/minheap-internal.h
@@ -70,7 +70,7 @@ struct event* min_heap_top_(min_heap_t* s) { return s->n ? *s->p : 0; }
 
 int min_heap_push_(min_heap_t* s, struct event* e)
 {
-	if (min_heap_reserve_(s, s->n + 1))
+	if (s->n == UINT32_MAX || min_heap_reserve_(s, s->n + 1))
 		return -1;
 	min_heap_shift_up_(s, s->n++, e);
 	return 0;
@@ -138,6 +138,10 @@ int min_heap_reserve_(min_heap_t* s, unsigned n)
 		unsigned a = s->a ? s->a * 2 : 8;
 		if (a < n)
 			a = n;
+#if (SIZE_MAX == UINT32_MAX)
+		if (a > SIZE_MAX / sizeof *p)
+			return -1;
+#endif
 		if (!(p = (struct event**)mm_realloc(s->p, a * sizeof *p)))
 			return -1;
 		s->p = p;
diff --git a/ipc/chromium/src/third_party/libevent/mm-internal.h b/ipc/chromium/src/third_party/libevent/mm-internal.h
index 4ba6fce4adaf..7a95c9956120 100644
--- a/ipc/chromium/src/third_party/libevent/mm-internal.h
+++ b/ipc/chromium/src/third_party/libevent/mm-internal.h
@@ -43,6 +43,7 @@ extern "C" {
  *     On failure, set errno to ENOMEM and return NULL.
  *     If the argument sz is 0, simply return NULL.
  */
+EVENT2_EXPORT_SYMBOL
 void *event_mm_malloc_(size_t sz);
 
 /** Allocate memory initialized to zero.
@@ -53,6 +54,7 @@ void *event_mm_malloc_(size_t sz);
  *     set errno to ENOMEM and return NULL.
  *     If either arguments are 0, simply return NULL.
  */
+EVENT2_EXPORT_SYMBOL
 void *event_mm_calloc_(size_t count, size_t size);
 
 /** Duplicate a string.
@@ -63,9 +65,12 @@ void *event_mm_calloc_(size_t count, size_t size);
  *     occurs (or would occur) in the process.
  *     If the argument str is NULL, set errno to EINVAL and return NULL.
  */
+EVENT2_EXPORT_SYMBOL
 char *event_mm_strdup_(const char *str);
 
+EVENT2_EXPORT_SYMBOL
 void *event_mm_realloc_(void *p, size_t sz);
+EVENT2_EXPORT_SYMBOL
 void event_mm_free_(void *p);
 #define mm_malloc(sz) event_mm_malloc_(sz)
 #define mm_calloc(count, size) event_mm_calloc_((count), (size))
diff --git a/ipc/chromium/src/third_party/libevent/openssl-compat.h b/ipc/chromium/src/third_party/libevent/openssl-compat.h
index 69afc716e25e..a23e34251b90 100644
--- a/ipc/chromium/src/third_party/libevent/openssl-compat.h
+++ b/ipc/chromium/src/third_party/libevent/openssl-compat.h
@@ -1,7 +1,11 @@
 #ifndef OPENSSL_COMPAT_H
 #define OPENSSL_COMPAT_H
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#include <openssl/bio.h>
+#include "util-internal.h"
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 
 static inline BIO_METHOD *BIO_meth_new(int type, const char *name)
 {
@@ -30,6 +34,14 @@ static inline BIO_METHOD *BIO_meth_new(int type, const char *name)
 
 #define TLS_method SSLv23_method
 
-#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */
+#define X509_getm_notBefore X509_get_notBefore
+#define X509_getm_notAfter X509_get_notAfter
+
+#endif /* (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L) */
+
+#if defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER >= 0x20700000L
+#define BIO_get_init(b) (b)->init
+#endif
 
 #endif /* OPENSSL_COMPAT_H */
diff --git a/ipc/chromium/src/third_party/libevent/patches/android-api-level.patch b/ipc/chromium/src/third_party/libevent/patches/android-api-level.patch
deleted file mode 100644
index 3bb082db80e0..000000000000
--- a/ipc/chromium/src/third_party/libevent/patches/android-api-level.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-diff --git a/ipc/chromium/src/third_party/libevent/android/event2/event-config.h b/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
---- a/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
-+++ b/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
-@@ -19,23 +19,31 @@
- 
- /* Define if libevent should not allow replacing the mm functions */
- /* #undef EVENT__DISABLE_MM_REPLACEMENT */
- 
- /* Define if libevent should not be compiled with thread support */
- /* #undef EVENT__DISABLE_THREAD_SUPPORT */
- 
- /* Define to 1 if you have the `accept4' function. */
-+#if __ANDROID_API__ >= 21
- #define EVENT__HAVE_ACCEPT4 1
-+#else
-+/* #undef EVENT__HAVE_ACCEPT4 */
-+#endif
- 
- /* Define to 1 if you have the `arc4random' function. */
- #define EVENT__HAVE_ARC4RANDOM 1
- 
- /* Define to 1 if you have the `arc4random_buf' function. */
-+#if __ANDROID_API__ >= 21 || defined(__ANDROID_API_L__)
- #define EVENT__HAVE_ARC4RANDOM_BUF 1
-+#else
-+/* #undef EVENT__HAVE_ARC4RANDOM_BUF */
-+#endif
- 
- /* Define to 1 if you have the <arpa/inet.h> header file. */
- #define EVENT__HAVE_ARPA_INET_H 1
- 
- /* Define to 1 if you have the `clock_gettime' function. */
- #define EVENT__HAVE_CLOCK_GETTIME 1
- 
- /* Define to 1 if you have the declaration of `CTL_KERN', and to 0 if you
diff --git a/ipc/chromium/src/third_party/libevent/patches/dont-use-issetugid-on-android.patch b/ipc/chromium/src/third_party/libevent/patches/dont-use-issetugid-on-android.patch
deleted file mode 100644
index bdadc8447093..000000000000
--- a/ipc/chromium/src/third_party/libevent/patches/dont-use-issetugid-on-android.patch
+++ /dev/null
@@ -1,22 +0,0 @@
-diff --git a/ipc/chromium/src/third_party/libevent/android/event2/event-config.h b/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
---- a/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
-+++ b/ipc/chromium/src/third_party/libevent/android/event2/event-config.h
-@@ -134,17 +134,17 @@
- 
- /* Define to 1 if you have the `inet_pton' function. */
- #define EVENT__HAVE_INET_PTON 1
- 
- /* Define to 1 if you have the <inttypes.h> header file. */
- #define EVENT__HAVE_INTTYPES_H 1
- 
- /* Define to 1 if you have the `issetugid' function. */
--#define EVENT__HAVE_ISSETUGID 1
-+/* #undef EVENT__HAVE_ISSETUGID */
- 
- /* Define to 1 if you have the `kqueue' function. */
- /* #undef EVENT__HAVE_KQUEUE */
- 
- /* Define if the system has zlib */
- #define EVENT__HAVE_LIBZ 1
- 
- /* Define to 1 if you have the `mach_absolute_time' function. */
diff --git a/ipc/chromium/src/third_party/libevent/patches/linux-no-sysctl.patch b/ipc/chromium/src/third_party/libevent/patches/linux-no-sysctl.patch
deleted file mode 100644
index a47132fb926d..000000000000
--- a/ipc/chromium/src/third_party/libevent/patches/linux-no-sysctl.patch
+++ /dev/null
@@ -1,41 +0,0 @@
-diff --git a/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h b/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h
---- a/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h
-+++ b/ipc/chromium/src/third_party/libevent/linux/event2/event-config.h
-@@ -290,17 +290,17 @@
- 
- /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
- /* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
- 
- /* Define to 1 if the system has the type `struct so_linger'. */
- #define EVENT__HAVE_STRUCT_SO_LINGER 1
- 
- /* Define to 1 if you have the `sysctl' function. */
--#define EVENT__HAVE_SYSCTL 1
-+/* #undef EVENT__HAVE_SYSCTL */
- 
- /* Define to 1 if you have the <sys/devpoll.h> header file. */
- /* #undef EVENT__HAVE_SYS_DEVPOLL_H */
- 
- /* Define to 1 if you have the <sys/epoll.h> header file. */
- #define EVENT__HAVE_SYS_EPOLL_H 1
- 
- /* Define to 1 if you have the <sys/eventfd.h> header file. */
-@@ -332,17 +332,17 @@
- 
- /* Define to 1 if you have the <sys/socket.h> header file. */
- #define EVENT__HAVE_SYS_SOCKET_H 1
- 
- /* Define to 1 if you have the <sys/stat.h> header file. */
- #define EVENT__HAVE_SYS_STAT_H 1
- 
- /* Define to 1 if you have the <sys/sysctl.h> header file. */
--#define EVENT__HAVE_SYS_SYSCTL_H 1
-+/* #undef EVENT__HAVE_SYS_SYSCTL_H */
- 
- /* Define to 1 if you have the <sys/timerfd.h> header file. */
- #define EVENT__HAVE_SYS_TIMERFD_H 1
- 
- /* Define to 1 if you have the <sys/time.h> header file. */
- #define EVENT__HAVE_SYS_TIME_H 1
- 
- /* Define to 1 if you have the <sys/types.h> header file. */
diff --git a/ipc/chromium/src/third_party/libevent/patches/openbsd-no-arc4random_addrandom.patch b/ipc/chromium/src/third_party/libevent/patches/openbsd-no-arc4random_addrandom.patch
deleted file mode 100644
index cbb77be7e0e8..000000000000
--- a/ipc/chromium/src/third_party/libevent/patches/openbsd-no-arc4random_addrandom.patch
+++ /dev/null
@@ -1,62 +0,0 @@
-diff --git a/ipc/chromium/src/third_party/libevent/evutil_rand.c b/ipc/chromium/src/third_party/libevent/evutil_rand.c
---- a/ipc/chromium/src/third_party/libevent/evutil_rand.c
-+++ b/ipc/chromium/src/third_party/libevent/evutil_rand.c
-@@ -187,20 +187,22 @@ ev_arc4random_buf(void *buf, size_t n)
- #endif /* } !EVENT__HAVE_ARC4RANDOM */
- 
- void
- evutil_secure_rng_get_bytes(void *buf, size_t n)
- {
- 	ev_arc4random_buf(buf, n);
- }
- 
-+#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(ANDROID)
- void
- evutil_secure_rng_add_bytes(const char *buf, size_t n)
- {
- 	arc4random_addrandom((unsigned char*)buf,
- 	    n>(size_t)INT_MAX ? INT_MAX : (int)n);
- }
-+#endif
- 
- void
- evutil_free_secure_rng_globals_(void)
- {
-     evutil_free_secure_rng_globals_locks();
- }
-diff --git a/ipc/chromium/src/third_party/libevent/include/event2/util.h b/ipc/chromium/src/third_party/libevent/include/event2/util.h
---- a/ipc/chromium/src/third_party/libevent/include/event2/util.h
-+++ b/ipc/chromium/src/third_party/libevent/include/event2/util.h
-@@ -837,30 +837,32 @@ int evutil_secure_rng_init(void);
-  * user of the secure RNG might be running. Don't pass anything other than a
-  * real /dev/...random device file here, or you might lose security.)
-  *
-  * This API is unstable, and might change in a future libevent version.
-  */
- EVENT2_EXPORT_SYMBOL
- int evutil_secure_rng_set_urandom_device_file(char *fname);
- 
-+#if !defined(__OpenBSD__) && !defined(__FreeBSD__) && !defined(ANDROID)
- /** Seed the random number generator with extra random bytes.
- 
-     You should almost never need to call this function; it should be
-     sufficient to invoke evutil_secure_rng_init(), or let Libevent take
-     care of calling evutil_secure_rng_init() on its own.
- 
-     If you call this function as a _replacement_ for the regular
-     entropy sources, then you need to be sure that your input
-     contains a fairly large amount of strong entropy.  Doing so is
-     notoriously hard: most people who try get it wrong.  Watch out!
- 
-     @param dat a buffer full of a strong source of random numbers
-     @param datlen the number of bytes to read from datlen
-  */
- EVENT2_EXPORT_SYMBOL
- void evutil_secure_rng_add_bytes(const char *dat, size_t datlen);
-+#endif
- 
- #ifdef __cplusplus
- }
- #endif
- 
- #endif /* EVENT1_EVUTIL_H_INCLUDED_ */
diff --git a/ipc/chromium/src/third_party/libevent/poll.c b/ipc/chromium/src/third_party/libevent/poll.c
index fe4407117770..c3c9aac52a85 100644
--- a/ipc/chromium/src/third_party/libevent/poll.c
+++ b/ipc/chromium/src/third_party/libevent/poll.c
@@ -53,6 +53,17 @@
 #include "evthread-internal.h"
 #include "time-internal.h"
 
+/* Since Linux 2.6.17, poll is able to report about peer half-closed connection
+   using special POLLRDHUP flag on a read event.
+*/
+#if !defined(POLLRDHUP)
+#define POLLRDHUP 0
+#define EARLY_CLOSE_IF_HAVE_RDHUP 0
+#else
+#define EARLY_CLOSE_IF_HAVE_RDHUP EV_FEATURE_EARLY_CLOSE
+#endif
+
+
 struct pollidx {
 	int idxplus1;
 };
@@ -79,8 +90,8 @@ const struct eventop pollops = {
 	poll_del,
 	poll_dispatch,
 	poll_dealloc,
-	0, /* doesn't need_reinit */
-	EV_FEATURE_FDS,
+	1, /* need_reinit */
+	EV_FEATURE_FDS|EARLY_CLOSE_IF_HAVE_RDHUP,
 	sizeof(struct pollidx),
 };
 
@@ -204,6 +215,8 @@ poll_dispatch(struct event_base *base, struct timeval *tv)
 			res |= EV_READ;
 		if (what & POLLOUT)
 			res |= EV_WRITE;
+		if (what & POLLRDHUP)
+			res |= EV_CLOSED;
 		if (res == 0)
 			continue;
 
@@ -222,7 +235,7 @@ poll_add(struct event_base *base, int fd, short old, short events, void *idx_)
 	int i;
 
 	EVUTIL_ASSERT((events & EV_SIGNAL) == 0);
-	if (!(events & (EV_READ|EV_WRITE)))
+	if (!(events & (EV_READ|EV_WRITE|EV_CLOSED)))
 		return (0);
 
 	poll_check_ok(pop);
@@ -265,6 +278,8 @@ poll_add(struct event_base *base, int fd, short old, short events, void *idx_)
 		pfd->events |= POLLOUT;
 	if (events & EV_READ)
 		pfd->events |= POLLIN;
+	if (events & EV_CLOSED)
+		pfd->events |= POLLRDHUP;
 	poll_check_ok(pop);
 
 	return (0);
@@ -283,7 +298,7 @@ poll_del(struct event_base *base, int fd, short old, short events, void *idx_)
 	int i;
 
 	EVUTIL_ASSERT((events & EV_SIGNAL) == 0);
-	if (!(events & (EV_READ|EV_WRITE)))
+	if (!(events & (EV_READ|EV_WRITE|EV_CLOSED)))
 		return (0);
 
 	poll_check_ok(pop);
@@ -297,6 +312,8 @@ poll_del(struct event_base *base, int fd, short old, short events, void *idx_)
 		pfd->events &= ~POLLIN;
 	if (events & EV_WRITE)
 		pfd->events &= ~POLLOUT;
+	if (events & EV_CLOSED)
+		pfd->events &= ~POLLRDHUP;
 	poll_check_ok(pop);
 	if (pfd->events)
 		/* Another event cares about that fd. */
diff --git a/ipc/chromium/src/third_party/libevent/sample/dns-example.c b/ipc/chromium/src/third_party/libevent/sample/dns-example.c
index fb705664aa81..2d07c3874bca 100644
--- a/ipc/chromium/src/third_party/libevent/sample/dns-example.c
+++ b/ipc/chromium/src/third_party/libevent/sample/dns-example.c
@@ -78,6 +78,8 @@ gai_callback(int err, struct evutil_addrinfo *ai, void *arg)
 {
 	const char *name = arg;
 	int i;
+	struct evutil_addrinfo *first_ai = ai;
+
 	if (err) {
 		printf("%s: %s\n", name, evutil_gai_strerror(err));
 	}
@@ -99,6 +101,9 @@ gai_callback(int err, struct evutil_addrinfo *ai, void *arg)
 			printf("[%d] %s: %s\n",i,name,buf);
 		}
 	}
+
+	if (first_ai)
+		evutil_freeaddrinfo(first_ai);
 }
 
 static void
@@ -154,19 +159,19 @@ main(int c, char **v) {
 		const char *ns;
 	};
 	struct options o;
-	char opt;
+	int opt;
 	struct event_base *event_base = NULL;
 	struct evdns_base *evdns_base = NULL;
 
 	memset(&o, 0, sizeof(o));
-	
+
 	if (c < 2) {
 		fprintf(stderr, "syntax: %s [-x] [-v] [-c resolv.conf] [-s ns] hostname\n", v[0]);
 		fprintf(stderr, "syntax: %s [-T]\n", v[0]);
 		return 1;
 	}
 
-	while ((opt = getopt(c, v, "xvc:Ts:")) != -1) {
+	while ((opt = getopt(c, v, "xvc:Ts:g")) != -1) {
 		switch (opt) {
 			case 'x': o.reverse = 1; break;
 			case 'v': ++verbose; break;
@@ -220,8 +225,8 @@ main(int c, char **v) {
 			res = evdns_base_resolv_conf_parse(evdns_base,
 			    DNS_OPTION_NAMESERVERS, o.resolv_conf);
 
-		if (res < 0) {
-			fprintf(stderr, "Couldn't configure nameservers");
+		if (res) {
+			fprintf(stderr, "Couldn't configure nameservers\n");
 			return 1;
 		}
 	}
@@ -252,6 +257,8 @@ main(int c, char **v) {
 	}
 	fflush(stdout);
 	event_base_dispatch(event_base);
+	evdns_base_free(evdns_base, 1);
+	event_base_free(event_base);
 	return 0;
 }
 
diff --git a/ipc/chromium/src/third_party/libevent/sample/event-read-fifo.c b/ipc/chromium/src/third_party/libevent/sample/event-read-fifo.c
index 27b0b530d5c1..a17b9bd9ae45 100644
--- a/ipc/chromium/src/third_party/libevent/sample/event-read-fifo.c
+++ b/ipc/chromium/src/third_party/libevent/sample/event-read-fifo.c
@@ -129,10 +129,10 @@ main(int argc, char **argv)
 
 	fprintf(stderr, "Write data to %s\n", fifo);
 #endif
-	/* Initalize the event library */
+	/* Initialize the event library */
 	base = event_base_new();
 
-	/* Initalize one event */
+	/* Initialize one event */
 #ifdef _WIN32
 	evfifo = event_new(base, (evutil_socket_t)socket, EV_READ|EV_PERSIST, fifo_read,
                            event_self_cbarg());
diff --git a/ipc/chromium/src/third_party/libevent/sample/hello-world.c b/ipc/chromium/src/third_party/libevent/sample/hello-world.c
index 2023cd6c6aa6..a13e06af612d 100644
--- a/ipc/chromium/src/third_party/libevent/sample/hello-world.c
+++ b/ipc/chromium/src/third_party/libevent/sample/hello-world.c
@@ -42,7 +42,7 @@ main(int argc, char **argv)
 	struct evconnlistener *listener;
 	struct event *signal_event;
 
-	struct sockaddr_in sin;
+	struct sockaddr_in sin = {0};
 #ifdef _WIN32
 	WSADATA wsa_data;
 	WSAStartup(0x0201, &wsa_data);
@@ -54,7 +54,6 @@ main(int argc, char **argv)
 		return 1;
 	}
 
-	memset(&sin, 0, sizeof(sin));
 	sin.sin_family = AF_INET;
 	sin.sin_port = htons(PORT);
 
diff --git a/ipc/chromium/src/third_party/libevent/sample/http-connect.c b/ipc/chromium/src/third_party/libevent/sample/http-connect.c
index a44d001ac71f..53f816d3ae59 100644
--- a/ipc/chromium/src/third_party/libevent/sample/http-connect.c
+++ b/ipc/chromium/src/third_party/libevent/sample/http-connect.c
@@ -11,6 +11,7 @@
 #define VERIFY(cond) do {                       \
 	if (!(cond)) {                              \
 		fprintf(stderr, "[error] %s\n", #cond); \
+		exit(EXIT_FAILURE);                     \
 	}                                           \
 } while (0);                                    \
 
@@ -22,6 +23,38 @@ struct connect_base
 	struct evhttp_uri *location;
 };
 
+static struct evhttp_uri* uri_parse(const char *str)
+{
+	struct evhttp_uri *uri;
+	VERIFY(uri = evhttp_uri_parse(str));
+	VERIFY(evhttp_uri_get_host(uri));
+	VERIFY(evhttp_uri_get_port(uri) > 0);
+	return uri;
+}
+static char* uri_path(struct evhttp_uri *uri, char buffer[URL_MAX])
+{
+	struct evhttp_uri *path;
+
+	VERIFY(evhttp_uri_join(uri, buffer, URL_MAX));
+
+	path = evhttp_uri_parse(buffer);
+	evhttp_uri_set_scheme(path, NULL);
+	evhttp_uri_set_userinfo(path, 0);
+	evhttp_uri_set_host(path, NULL);
+	evhttp_uri_set_port(path, -1);
+	VERIFY(evhttp_uri_join(path, buffer, URL_MAX));
+	return buffer;
+}
+static char* uri_hostport(struct evhttp_uri *uri, char buffer[URL_MAX])
+{
+	VERIFY(evhttp_uri_join(uri, buffer, URL_MAX));
+	VERIFY(evhttp_uri_get_host(uri));
+	VERIFY(evhttp_uri_get_port(uri) > 0);
+	evutil_snprintf(buffer, URL_MAX, "%s:%d",
+		evhttp_uri_get_host(uri), evhttp_uri_get_port(uri));
+	return buffer;
+}
+
 static void get_cb(struct evhttp_request *req, void *arg)
 {
 	ev_ssize_t len;
@@ -37,26 +70,26 @@ static void get_cb(struct evhttp_request *req, void *arg)
 
 static void connect_cb(struct evhttp_request *proxy_req, void *arg)
 {
-	char buffer[URL_MAX];
-
 	struct connect_base *base = arg;
 	struct evhttp_connection *evcon = base->evcon;
 	struct evhttp_uri *location = base->location;
+	struct evhttp_request *req;
+	char buffer[URL_MAX];
 
 	VERIFY(proxy_req);
-	if (evcon) {
-		struct evhttp_request *req = evhttp_request_new(get_cb, NULL);
-		evhttp_add_header(req->output_headers, "Connection", "close");
-		VERIFY(!evhttp_make_request(evcon, req, EVHTTP_REQ_GET,
-			evhttp_uri_join(location, buffer, URL_MAX)));
-	}
+	VERIFY(evcon);
+
+	req = evhttp_request_new(get_cb, NULL);
+	evhttp_add_header(req->output_headers, "Connection", "close");
+	evhttp_add_header(req->output_headers, "Host", evhttp_uri_get_host(location));
+	VERIFY(!evhttp_make_request(evcon, req, EVHTTP_REQ_GET,
+		uri_path(location, buffer)));
 }
 
 int main(int argc, const char **argv)
 {
-	char buffer[URL_MAX];
+	char hostport[URL_MAX];
 
-	struct evhttp_uri *host_port;
 	struct evhttp_uri *location;
 	struct evhttp_uri *proxy;
 
@@ -71,28 +104,8 @@ int main(int argc, const char **argv)
 		return 1;
 	}
 
-	{
-		proxy = evhttp_uri_parse(argv[1]);
-		VERIFY(evhttp_uri_get_host(proxy));
-		VERIFY(evhttp_uri_get_port(proxy) > 0);
-	}
-	{
-		host_port = evhttp_uri_parse(argv[2]);
-		evhttp_uri_set_scheme(host_port, NULL);
-		evhttp_uri_set_userinfo(host_port, NULL);
-		evhttp_uri_set_path(host_port, NULL);
-		evhttp_uri_set_query(host_port, NULL);
-		evhttp_uri_set_fragment(host_port, NULL);
-		VERIFY(evhttp_uri_get_host(host_port));
-		VERIFY(evhttp_uri_get_port(host_port) > 0);
-	}
-	{
-		location = evhttp_uri_parse(argv[2]);
-		evhttp_uri_set_scheme(location, NULL);
-		evhttp_uri_set_userinfo(location, 0);
-		evhttp_uri_set_host(location, NULL);
-		evhttp_uri_set_port(location, -1);
-	}
+	proxy    = uri_parse(argv[1]);
+	location = uri_parse(argv[2]);
 
 	VERIFY(base = event_base_new());
 	VERIFY(evcon = evhttp_connection_base_new(base, NULL,
@@ -101,17 +114,18 @@ int main(int argc, const char **argv)
 	connect_base.location = location;
 	VERIFY(req = evhttp_request_new(connect_cb, &connect_base));
 
+	uri_hostport(location, hostport);
 	evhttp_add_header(req->output_headers, "Connection", "keep-alive");
 	evhttp_add_header(req->output_headers, "Proxy-Connection", "keep-alive");
-	evutil_snprintf(buffer, URL_MAX, "%s:%d",
-		evhttp_uri_get_host(host_port), evhttp_uri_get_port(host_port));
-	evhttp_make_request(evcon, req, EVHTTP_REQ_CONNECT, buffer);
+	evhttp_add_header(req->output_headers, "Host", hostport);
+	evhttp_make_request(evcon, req, EVHTTP_REQ_CONNECT, hostport);
 
 	event_base_dispatch(base);
+
 	evhttp_connection_free(evcon);
 	event_base_free(base);
 	evhttp_uri_free(proxy);
-	evhttp_uri_free(host_port);
 	evhttp_uri_free(location);
+
 	return 0;
 }
diff --git a/ipc/chromium/src/third_party/libevent/sample/http-server.c b/ipc/chromium/src/third_party/libevent/sample/http-server.c
index 579feea6e3e1..049aabc4418e 100644
--- a/ipc/chromium/src/third_party/libevent/sample/http-server.c
+++ b/ipc/chromium/src/third_party/libevent/sample/http-server.c
@@ -20,26 +20,39 @@
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #include <windows.h>
+#include <getopt.h>
 #include <io.h>
 #include <fcntl.h>
 #ifndef S_ISDIR
 #define S_ISDIR(x) (((x) & S_IFMT) == S_IFDIR)
 #endif
-#else
+#else /* !_WIN32 */
 #include <sys/stat.h>
 #include <sys/socket.h>
-#include <signal.h>
 #include <fcntl.h>
 #include <unistd.h>
 #include <dirent.h>
+#endif /* _WIN32 */
+#include <signal.h>
+
+#ifdef EVENT__HAVE_SYS_UN_H
+#include <sys/un.h>
+#endif
+#ifdef EVENT__HAVE_AFUNIX_H
+#include <afunix.h>
 #endif
 
 #include <event2/event.h>
 #include <event2/http.h>
+#include <event2/listener.h>
 #include <event2/buffer.h>
 #include <event2/util.h>
 #include <event2/keyvalq_struct.h>
 
+#ifdef _WIN32
+#include <event2/thread.h>
+#endif /* _WIN32 */
+
 #ifdef EVENT__HAVE_NETINET_IN_H
 #include <netinet/in.h>
 # ifdef _XOPEN_SOURCE_EXTENDED
@@ -63,7 +76,7 @@
 #ifndef O_RDONLY
 #define O_RDONLY _O_RDONLY
 #endif
-#endif
+#endif /* _WIN32 */
 
 char uri_root[512];
 
@@ -86,6 +99,16 @@ static const struct table_entry {
 	{ NULL, NULL },
 };
 
+struct options {
+	int port;
+	int iocp;
+	int verbose;
+
+	int unlink;
+	const char *unixsock;
+	const char *docroot;
+};
+
 /* Try to guess a good content-type for 'path' */
 static const char *
 guess_content_type(const char *path)
@@ -159,7 +182,7 @@ static void
 send_document_cb(struct evhttp_request *req, void *arg)
 {
 	struct evbuffer *evb = NULL;
-	const char *docroot = arg;
+	struct options *o = arg;
 	const char *uri = evhttp_request_get_uri(req);
 	struct evhttp_uri *decoded = NULL;
 	const char *path;
@@ -199,12 +222,12 @@ send_document_cb(struct evhttp_request *req, void *arg)
 	if (strstr(decoded_path, ".."))
 		goto err;
 
-	len = strlen(decoded_path)+strlen(docroot)+2;
+	len = strlen(decoded_path)+strlen(o->docroot)+2;
 	if (!(whole_path = malloc(len))) {
 		perror("malloc");
 		goto err;
 	}
-	evutil_snprintf(whole_path, len, "%s/%s", docroot, decoded_path);
+	evutil_snprintf(whole_path, len, "%s/%s", o->docroot, decoded_path);
 
 	if (stat(whole_path, &st)<0) {
 		goto err;
@@ -321,42 +344,161 @@ done:
 }
 
 static void
-syntax(void)
+print_usage(FILE *out, const char *prog, int exit_code)
+{
+	fprintf(out,
+		"Syntax: %s [ OPTS ] <docroot>\n"
+		" -p      - port\n"
+		" -U      - bind to unix socket\n"
+		" -u      - unlink unix socket before bind\n"
+		" -I      - IOCP\n"
+		" -v      - verbosity, enables libevent debug logging too\n", prog);
+	exit(exit_code);
+}
+static struct options
+parse_opts(int argc, char **argv)
+{
+	struct options o;
+	int opt;
+
+	memset(&o, 0, sizeof(o));
+
+	while ((opt = getopt(argc, argv, "hp:U:uIv")) != -1) {
+		switch (opt) {
+			case 'p': o.port = atoi(optarg); break;
+			case 'U': o.unixsock = optarg; break;
+			case 'u': o.unlink = 1; break;
+			case 'I': o.iocp = 1; break;
+			case 'v': ++o.verbose; break;
+			case 'h': print_usage(stdout, argv[0], 0); break;
+			default : fprintf(stderr, "Unknown option %c\n", opt); break;
+		}
+	}
+
+	if (optind >= argc || (argc - optind) > 1) {
+		print_usage(stdout, argv[0], 1);
+	}
+	o.docroot = argv[optind];
+
+	return o;
+}
+
+static void
+do_term(int sig, short events, void *arg)
+{
+	struct event_base *base = arg;
+	event_base_loopbreak(base);
+	fprintf(stderr, "Got %i, Terminating\n", sig);
+}
+
+static int
+display_listen_sock(struct evhttp_bound_socket *handle)
 {
-	fprintf(stdout, "Syntax: http-server <docroot>\n");
+	struct sockaddr_storage ss;
+	evutil_socket_t fd;
+	ev_socklen_t socklen = sizeof(ss);
+	char addrbuf[128];
+	void *inaddr;
+	const char *addr;
+	int got_port = -1;
+
+	fd = evhttp_bound_socket_get_fd(handle);
+	memset(&ss, 0, sizeof(ss));
+	if (getsockname(fd, (struct sockaddr *)&ss, &socklen)) {
+		perror("getsockname() failed");
+		return 1;
+	}
+
+	if (ss.ss_family == AF_INET) {
+		got_port = ntohs(((struct sockaddr_in*)&ss)->sin_port);
+		inaddr = &((struct sockaddr_in*)&ss)->sin_addr;
+	} else if (ss.ss_family == AF_INET6) {
+		got_port = ntohs(((struct sockaddr_in6*)&ss)->sin6_port);
+		inaddr = &((struct sockaddr_in6*)&ss)->sin6_addr;
+	}
+#ifdef EVENT__HAVE_STRUCT_SOCKADDR_UN
+	else if (ss.ss_family == AF_UNIX) {
+		printf("Listening on <%s>\n", ((struct sockaddr_un*)&ss)->sun_path);
+		return 0;
+	}
+#endif
+	else {
+		fprintf(stderr, "Weird address family %d\n",
+		    ss.ss_family);
+		return 1;
+	}
+
+	addr = evutil_inet_ntop(ss.ss_family, inaddr, addrbuf,
+	    sizeof(addrbuf));
+	if (addr) {
+		printf("Listening on %s:%d\n", addr, got_port);
+		evutil_snprintf(uri_root, sizeof(uri_root),
+		    "http://%s:%d",addr,got_port);
+	} else {
+		fprintf(stderr, "evutil_inet_ntop failed\n");
+		return 1;
+	}
+
+	return 0;
 }
 
 int
 main(int argc, char **argv)
 {
-	struct event_base *base;
-	struct evhttp *http;
-	struct evhttp_bound_socket *handle;
+	struct event_config *cfg = NULL;
+	struct event_base *base = NULL;
+	struct evhttp *http = NULL;
+	struct evhttp_bound_socket *handle = NULL;
+	struct evconnlistener *lev = NULL;
+	struct event *term = NULL;
+	struct options o = parse_opts(argc, argv);
+	int ret = 0;
 
-	ev_uint16_t port = 0;
 #ifdef _WIN32
-	WSADATA WSAData;
-	WSAStartup(0x101, &WSAData);
+	{
+		WORD wVersionRequested;
+		WSADATA wsaData;
+		wVersionRequested = MAKEWORD(2, 2);
+		WSAStartup(wVersionRequested, &wsaData);
+	}
 #else
-	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)
-		return (1);
+	if (signal(SIGPIPE, SIG_IGN) == SIG_ERR) {
+		ret = 1;
+		goto err;
+	}
 #endif
-	if (argc < 2) {
-		syntax();
-		return 1;
+
+	setbuf(stdout, NULL);
+	setbuf(stderr, NULL);
+
+	/** Read env like in regress */
+	if (o.verbose || getenv("EVENT_DEBUG_LOGGING_ALL"))
+		event_enable_debug_logging(EVENT_DBG_ALL);
+
+	cfg = event_config_new();
+#ifdef _WIN32
+	if (o.iocp) {
+#ifdef EVTHREAD_USE_WINDOWS_THREADS_IMPLEMENTED
+		evthread_use_windows_threads();
+		event_config_set_num_cpus_hint(cfg, 8);
+#endif
+		event_config_set_flag(cfg, EVENT_BASE_FLAG_STARTUP_IOCP);
 	}
+#endif
 
-	base = event_base_new();
+	base = event_base_new_with_config(cfg);
 	if (!base) {
 		fprintf(stderr, "Couldn't create an event_base: exiting\n");
-		return 1;
+		ret = 1;
 	}
+	event_config_free(cfg);
+	cfg = NULL;
 
 	/* Create a new evhttp object to handle requests. */
 	http = evhttp_new(base);
 	if (!http) {
 		fprintf(stderr, "couldn't create evhttp. Exiting.\n");
-		return 1;
+		ret = 1;
 	}
 
 	/* The /dump URI will dump all requests to stdout and say 200 ok. */
@@ -364,55 +506,77 @@ main(int argc, char **argv)
 
 	/* We want to accept arbitrary requests, so we need to set a "generic"
 	 * cb.  We can also add callbacks for specific paths. */
-	evhttp_set_gencb(http, send_document_cb, argv[1]);
+	evhttp_set_gencb(http, send_document_cb, &o);
 
-	/* Now we tell the evhttp what port to listen on */
-	handle = evhttp_bind_socket_with_handle(http, "0.0.0.0", port);
-	if (!handle) {
-		fprintf(stderr, "couldn't bind to port %d. Exiting.\n",
-		    (int)port);
-		return 1;
-	}
+	if (o.unixsock) {
+#ifdef EVENT__HAVE_STRUCT_SOCKADDR_UN
+		struct sockaddr_un addr;
 
-	{
-		/* Extract and display the address we're listening on. */
-		struct sockaddr_storage ss;
-		evutil_socket_t fd;
-		ev_socklen_t socklen = sizeof(ss);
-		char addrbuf[128];
-		void *inaddr;
-		const char *addr;
-		int got_port = -1;
-		fd = evhttp_bound_socket_get_fd(handle);
-		memset(&ss, 0, sizeof(ss));
-		if (getsockname(fd, (struct sockaddr *)&ss, &socklen)) {
-			perror("getsockname() failed");
-			return 1;
+		if (o.unlink && (unlink(o.unixsock) && errno != ENOENT)) {
+			perror(o.unixsock);
+			ret = 1;
+			goto err;
+		}
+
+		addr.sun_family = AF_UNIX;
+		strcpy(addr.sun_path, o.unixsock);
+
+		lev = evconnlistener_new_bind(base, NULL, NULL,
+			LEV_OPT_CLOSE_ON_FREE, -1,
+			(struct sockaddr *)&addr, sizeof(addr));
+		if (!lev) {
+			perror("Cannot create listener");
+			ret = 1;
+			goto err;
 		}
-		if (ss.ss_family == AF_INET) {
-			got_port = ntohs(((struct sockaddr_in*)&ss)->sin_port);
-			inaddr = &((struct sockaddr_in*)&ss)->sin_addr;
-		} else if (ss.ss_family == AF_INET6) {
-			got_port = ntohs(((struct sockaddr_in6*)&ss)->sin6_port);
-			inaddr = &((struct sockaddr_in6*)&ss)->sin6_addr;
-		} else {
-			fprintf(stderr, "Weird address family %d\n",
-			    ss.ss_family);
-			return 1;
+
+		handle = evhttp_bind_listener(http, lev);
+		if (!handle) {
+			fprintf(stderr, "couldn't bind to %s. Exiting.\n", o.unixsock);
+			ret = 1;
+			goto err;
 		}
-		addr = evutil_inet_ntop(ss.ss_family, inaddr, addrbuf,
-		    sizeof(addrbuf));
-		if (addr) {
-			printf("Listening on %s:%d\n", addr, got_port);
-			evutil_snprintf(uri_root, sizeof(uri_root),
-			    "http://%s:%d",addr,got_port);
-		} else {
-			fprintf(stderr, "evutil_inet_ntop failed\n");
-			return 1;
+#else /* !EVENT__HAVE_STRUCT_SOCKADDR_UN */
+		fprintf(stderr, "-U is not supported on this platform. Exiting.\n");
+		ret = 1;
+		goto err;
+#endif /* EVENT__HAVE_STRUCT_SOCKADDR_UN */
+	}
+	else {
+		handle = evhttp_bind_socket_with_handle(http, "0.0.0.0", o.port);
+		if (!handle) {
+			fprintf(stderr, "couldn't bind to port %d. Exiting.\n", o.port);
+			ret = 1;
+			goto err;
 		}
 	}
 
+	if (display_listen_sock(handle)) {
+		ret = 1;
+		goto err;
+	}
+
+	term = evsignal_new(base, SIGINT, do_term, base);
+	if (!term)
+		goto err;
+	if (event_add(term, NULL))
+		goto err;
+
 	event_base_dispatch(base);
 
-	return 0;
+#ifdef _WIN32
+	WSACleanup();
+#endif
+
+err:
+	if (cfg)
+		event_config_free(cfg);
+	if (http)
+		evhttp_free(http);
+	if (term)
+		event_free(term);
+	if (base)
+		event_base_free(base);
+
+	return ret;
 }
diff --git a/ipc/chromium/src/third_party/libevent/sample/https-client.c b/ipc/chromium/src/third_party/libevent/sample/https-client.c
index 748395656b2e..5136acebd79a 100644
--- a/ipc/chromium/src/third_party/libevent/sample/https-client.c
+++ b/ipc/chromium/src/third_party/libevent/sample/https-client.c
@@ -45,7 +45,6 @@
 
 #include "openssl_hostname_validation.h"
 
-static struct event_base *base;
 static int ignore_cert = 0;
 
 static void
@@ -54,7 +53,7 @@ http_request_done(struct evhttp_request *req, void *ctx)
 	char buffer[256];
 	int nread;
 
-	if (req == NULL) {
+	if (!req || !evhttp_request_get_response_code(req)) {
 		/* If req is NULL, it means an error occurred, but
 		 * sadly we are mostly left guessing what the error
 		 * might have been.  We'll do our best... */
@@ -119,7 +118,6 @@ err_openssl(const char *func)
 	exit(1);
 }
 
-#ifndef _WIN32
 /* See http://archives.seul.org/libevent/users/Jan-2013/msg00039.html */
 static int cert_verify_callback(X509_STORE_CTX *x509_ctx, void *arg)
 {
@@ -182,16 +180,45 @@ static int cert_verify_callback(X509_STORE_CTX *x509_ctx, void *arg)
 		return 0;
 	}
 }
+
+#ifdef _WIN32
+static int
+add_cert_for_store(X509_STORE *store, const char *name)
+{
+	HCERTSTORE sys_store = NULL;
+	PCCERT_CONTEXT ctx = NULL;
+	int r = 0;
+
+	sys_store = CertOpenSystemStore(0, name);
+	if (!sys_store) {
+		err("failed to open system certificate store");
+		return -1;
+	}
+	while ((ctx = CertEnumCertificatesInStore(sys_store, ctx))) {
+		X509 *x509 = d2i_X509(NULL, (unsigned char const **)&ctx->pbCertEncoded,
+			ctx->cbCertEncoded);
+		if (x509) {
+			X509_STORE_add_cert(store, x509);
+			X509_free(x509);
+		} else {
+			r = -1;
+			err_openssl("d2i_X509");
+			break;
+		}
+	}
+	CertCloseStore(sys_store, 0);
+	return r;
+}
 #endif
 
 int
 main(int argc, char **argv)
 {
 	int r;
-
+	struct event_base *base = NULL;
 	struct evhttp_uri *http_uri = NULL;
 	const char *url = NULL, *data_file = NULL;
-	const char *crt = "/etc/ssl/certs/ca-certificates.crt";
+	const char *crt = NULL;
 	const char *scheme, *host, *path, *query;
 	char uri[256];
 	int port;
@@ -312,7 +339,8 @@ main(int argc, char **argv)
 	}
 	uri[sizeof(uri) - 1] = '\0';
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 	// Initialize OpenSSL
 	SSL_library_init();
 	ERR_load_crypto_strings();
@@ -335,14 +363,27 @@ main(int argc, char **argv)
 		goto error;
 	}
 
-#ifndef _WIN32
-	/* TODO: Add certificate loading on Windows as well */
-
-	/* Attempt to use the system's trusted root certificates.
-	 * (This path is only valid for Debian-based systems.) */
-	if (1 != SSL_CTX_load_verify_locations(ssl_ctx, crt, NULL)) {
-		err_openssl("SSL_CTX_load_verify_locations");
-		goto error;
+	if (crt == NULL) {
+		X509_STORE *store;
+		/* Attempt to use the system's trusted root certificates. */
+		store = SSL_CTX_get_cert_store(ssl_ctx);
+#ifdef _WIN32
+		if (add_cert_for_store(store, "CA") < 0 ||
+		    add_cert_for_store(store, "AuthRoot") < 0 ||
+		    add_cert_for_store(store, "ROOT") < 0) {
+			goto error;
+		}
+#else // _WIN32
+		if (X509_STORE_set_default_paths(store) != 1) {
+			err_openssl("X509_STORE_set_default_paths");
+			goto error;
+		}
+#endif // _WIN32
+	} else {
+		if (SSL_CTX_load_verify_locations(ssl_ctx, crt, NULL) != 1) {
+			err_openssl("SSL_CTX_load_verify_locations");
+			goto error;
+		}
 	}
 	/* Ask OpenSSL to verify the server certificate.  Note that this
 	 * does NOT include verifying that the hostname is correct.
@@ -368,9 +409,6 @@ main(int argc, char **argv)
 	 * "wrapping" OpenSSL's routine, not replacing it. */
 	SSL_CTX_set_cert_verify_callback(ssl_ctx, cert_verify_callback,
 					  (void *) host);
-#else // _WIN32
-	(void)crt;
-#endif // _WIN32
 
 	// Create event base
 	base = event_base_new();
@@ -474,25 +512,29 @@ cleanup:
 		evhttp_connection_free(evcon);
 	if (http_uri)
 		evhttp_uri_free(http_uri);
-	event_base_free(base);
+	if (base)
+		event_base_free(base);
 
 	if (ssl_ctx)
 		SSL_CTX_free(ssl_ctx);
 	if (type == HTTP && ssl)
 		SSL_free(ssl);
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 	EVP_cleanup();
 	ERR_free_strings();
 
-#ifdef EVENT__HAVE_ERR_REMOVE_THREAD_STATE
-	ERR_remove_thread_state(NULL);
-#else
+#if OPENSSL_VERSION_NUMBER < 0x10000000L
 	ERR_remove_state(0);
+#else
+	ERR_remove_thread_state(NULL);
 #endif
+
 	CRYPTO_cleanup_all_ex_data();
 
 	sk_SSL_COMP_free(SSL_COMP_get_compression_methods());
-#endif /*OPENSSL_VERSION_NUMBER < 0x10100000L */
+#endif /* (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L) */
 
 #ifdef _WIN32
 	WSACleanup();
diff --git a/ipc/chromium/src/third_party/libevent/sample/include.am b/ipc/chromium/src/third_party/libevent/sample/include.am
index d1a7242f7caa..b6894d46e5fe 100644
--- a/ipc/chromium/src/third_party/libevent/sample/include.am
+++ b/ipc/chromium/src/third_party/libevent/sample/include.am
@@ -16,16 +16,19 @@ SAMPLES = \
 if OPENSSL
 SAMPLES += sample/le-proxy
 sample_le_proxy_SOURCES = sample/le-proxy.c
-sample_le_proxy_LDADD = libevent.la libevent_openssl.la ${OPENSSL_LIBS} ${OPENSSL_LIBADD}
-sample_le_proxy_INCLUDES = $(OPENSSL_INCS)
+sample_le_proxy_LDADD = libevent.la libevent_openssl.la $(OPENSSL_LIBS) $(OPENSSL_LIBADD)
+sample_le_proxy_CPPFLAGS = $(AM_CPPFLAGS) $(OPENSSL_INCS)
 
 SAMPLES += sample/https-client
 sample_https_client_SOURCES = \
 	sample/https-client.c \
 	sample/hostcheck.c \
 	sample/openssl_hostname_validation.c
-sample_https_client_LDADD = libevent.la libevent_openssl.la ${OPENSSL_LIBS} ${OPENSSL_LIBADD}
-sample_https_client_INCLUDES = $(OPENSSL_INCS)
+sample_https_client_LDADD = libevent.la libevent_openssl.la $(OPENSSL_LIBS) $(OPENSSL_LIBADD)
+if BUILD_WIN32
+sample_https_client_LDADD += -lcrypt32
+endif
+sample_https_client_CPPFLAGS = $(AM_CPPFLAGS) $(OPENSSL_INCS)
 noinst_HEADERS += \
 	sample/hostcheck.h \
 	sample/openssl_hostname_validation.h
diff --git a/ipc/chromium/src/third_party/libevent/sample/le-proxy.c b/ipc/chromium/src/third_party/libevent/sample/le-proxy.c
index 8d9b529ee68d..13e0e2aea918 100644
--- a/ipc/chromium/src/third_party/libevent/sample/le-proxy.c
+++ b/ipc/chromium/src/third_party/libevent/sample/le-proxy.c
@@ -30,6 +30,7 @@
 #include <event2/listener.h>
 #include <event2/util.h>
 
+#include "util-internal.h"
 #include <openssl/ssl.h>
 #include <openssl/err.h>
 #include <openssl/rand.h>
@@ -194,6 +195,7 @@ accept_cb(struct evconnlistener *listener, evutil_socket_t fd,
 			perror("Bufferevent_openssl_new");
 			bufferevent_free(b_out);
 			bufferevent_free(b_in);
+			return;
 		}
 		b_out = b_ssl;
 	}
@@ -214,6 +216,13 @@ main(int argc, char **argv)
 	int use_ssl = 0;
 	struct evconnlistener *listener;
 
+#ifdef _WIN32
+	WORD wVersionRequested;
+	WSADATA wsaData;
+	wVersionRequested = MAKEWORD(2, 2);
+	(void) WSAStartup(wVersionRequested, &wsaData);
+#endif
+
 	if (argc < 3)
 		syntax();
 
@@ -259,7 +268,8 @@ main(int argc, char **argv)
 
 	if (use_ssl) {
 		int r;
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 		SSL_library_init();
 		ERR_load_crypto_strings();
 		SSL_load_error_strings();
@@ -287,5 +297,9 @@ main(int argc, char **argv)
 	evconnlistener_free(listener);
 	event_base_free(base);
 
+#ifdef _WIN32
+	WSACleanup();
+#endif
+
 	return 0;
 }
diff --git a/ipc/chromium/src/third_party/libevent/sample/openssl_hostname_validation.c b/ipc/chromium/src/third_party/libevent/sample/openssl_hostname_validation.c
index 40312f2e9613..4036ccbaabc9 100644
--- a/ipc/chromium/src/third_party/libevent/sample/openssl_hostname_validation.c
+++ b/ipc/chromium/src/third_party/libevent/sample/openssl_hostname_validation.c
@@ -48,7 +48,8 @@ SOFTWARE.
 
 #define HOSTNAME_MAX_SIZE 255
 
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 #define ASN1_STRING_get0_data ASN1_STRING_data
 #endif
 
diff --git a/ipc/chromium/src/third_party/libevent/sample/signal-test.c b/ipc/chromium/src/third_party/libevent/sample/signal-test.c
index 18668350b868..4aef42051574 100644
--- a/ipc/chromium/src/third_party/libevent/sample/signal-test.c
+++ b/ipc/chromium/src/third_party/libevent/sample/signal-test.c
@@ -44,8 +44,9 @@ signal_cb(evutil_socket_t fd, short event, void *arg)
 int
 main(int argc, char **argv)
 {
-	struct event *signal_int;
+	struct event *signal_int = NULL;
 	struct event_base* base;
+	int ret = 0;
 #ifdef _WIN32
 	WORD wVersionRequested;
 	WSADATA wsaData;
@@ -55,18 +56,28 @@ main(int argc, char **argv)
 	(void) WSAStartup(wVersionRequested, &wsaData);
 #endif
 
-	/* Initalize the event library */
+	/* Initialize the event library */
 	base = event_base_new();
+	if (!base) {
+		ret = 1;
+		goto out;
+	}
 
-	/* Initalize one event */
+	/* Initialize one event */
 	signal_int = evsignal_new(base, SIGINT, signal_cb, event_self_cbarg());
-
+	if (!signal_int) {
+		ret = 2;
+		goto out;
+	}
 	event_add(signal_int, NULL);
 
 	event_base_dispatch(base);
-	event_free(signal_int);
-	event_base_free(base);
 
-	return (0);
+out:
+	if (signal_int)
+		event_free(signal_int);
+	if (base)
+		event_base_free(base);
+	return ret;
 }
 
diff --git a/ipc/chromium/src/third_party/libevent/sample/time-test.c b/ipc/chromium/src/third_party/libevent/sample/time-test.c
index c94c18a5004e..671a1d2108e2 100644
--- a/ipc/chromium/src/third_party/libevent/sample/time-test.c
+++ b/ipc/chromium/src/third_party/libevent/sample/time-test.c
@@ -88,10 +88,10 @@ main(int argc, char **argv)
 		flags = 0;
 	}
 
-	/* Initalize the event library */
+	/* Initialize the event library */
 	base = event_base_new();
 
-	/* Initalize one event */
+	/* Initialize one event */
 	event_assign(&timeout, base, -1, flags, timeout_cb, (void*) &timeout);
 
 	evutil_timerclear(&tv);
@@ -100,6 +100,9 @@ main(int argc, char **argv)
 
 	evutil_gettimeofday(&lasttime, NULL);
 
+	setbuf(stdout, NULL);
+	setbuf(stderr, NULL);
+
 	event_base_dispatch(base);
 
 	return (0);
diff --git a/ipc/chromium/src/third_party/libevent/select.c b/ipc/chromium/src/third_party/libevent/select.c
index 8ae53cc11ec5..b1db0e44b605 100644
--- a/ipc/chromium/src/third_party/libevent/select.c
+++ b/ipc/chromium/src/third_party/libevent/select.c
@@ -98,7 +98,7 @@ const struct eventop selectops = {
 	select_del,
 	select_dispatch,
 	select_dealloc,
-	0, /* doesn't need reinit. */
+	1, /* need_reinit. */
 	EV_FEATURE_FDS,
 	0,
 };
diff --git a/ipc/chromium/src/third_party/libevent/signal.c b/ipc/chromium/src/third_party/libevent/signal.c
index 3f46295024e5..89f5fc171763 100644
--- a/ipc/chromium/src/third_party/libevent/signal.c
+++ b/ipc/chromium/src/third_party/libevent/signal.c
@@ -85,8 +85,10 @@
 #ifndef _WIN32
 /* Windows wants us to call our signal handlers as __cdecl.  Nobody else
  * expects you to do anything crazy like this. */
+#ifndef __cdecl
 #define __cdecl
 #endif
+#endif
 
 static int evsig_add(struct event_base *, evutil_socket_t, short, short, void *);
 static int evsig_del(struct event_base *, evutil_socket_t, short, short, void *);
diff --git a/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h b/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h
index 43aedbe8e351..308abc551288 100644
--- a/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h
+++ b/ipc/chromium/src/third_party/libevent/solaris/event2/event-config.h
@@ -24,11 +24,17 @@
 /* #undef EVENT__DISABLE_THREAD_SUPPORT */
 
 /* Define to 1 if you have the `accept4' function. */
-/* #undef EVENT__HAVE_ACCEPT4 */
+#define EVENT__HAVE_ACCEPT4 1
+
+/* Define to 1 if you have the <afunix.h> header file. */
+/* #undef EVENT__HAVE_AFUNIX_H */
 
 /* Define to 1 if you have the `arc4random' function. */
 #define EVENT__HAVE_ARC4RANDOM 1
 
+/* Define to 1 if you have the `arc4random_addrandom' function. */
+#define EVENT__HAVE_ARC4RANDOM_ADDRANDOM 1
+
 /* Define to 1 if you have the `arc4random_buf' function. */
 #define EVENT__HAVE_ARC4RANDOM_BUF 1
 
@@ -46,14 +52,6 @@
    don't. */
 /* #undef EVENT__HAVE_DECL_KERN_ARND */
 
-/* Define to 1 if you have the declaration of `KERN_RANDOM', and to 0 if you
-   don't. */
-/* #undef EVENT__HAVE_DECL_KERN_RANDOM */
-
-/* Define to 1 if you have the declaration of `RANDOM_UUID', and to 0 if you
-   don't. */
-/* #undef EVENT__HAVE_DECL_RANDOM_UUID */
-
 /* Define if /dev/poll is available */
 #define EVENT__HAVE_DEVPOLL 1
 
@@ -72,9 +70,6 @@
 /* Define to 1 if you have the <errno.h> header file. */
 #define EVENT__HAVE_ERRNO_H 1
 
-/* Define to 1 if you have ERR_remove_thread_stat(). */
-#define EVENT__HAVE_ERR_REMOVE_THREAD_STATE 1
-
 /* Define to 1 if you have the `eventfd' function. */
 /* #undef EVENT__HAVE_EVENTFD */
 
@@ -120,6 +115,9 @@
 /* Define to 1 if you have the `getprotobynumber' function. */
 #define EVENT__HAVE_GETPROTOBYNUMBER 1
 
+/* Define to 1 if you have the `getrandom' function. */
+#define EVENT__HAVE_GETRANDOM 1
+
 /* Define to 1 if you have the `getservbyname' function. */
 #define EVENT__HAVE_GETSERVBYNAME 1
 
@@ -144,12 +142,18 @@
 /* Define to 1 if you have the `kqueue' function. */
 /* #undef EVENT__HAVE_KQUEUE */
 
+/* Define to 1 if you have the `ws2_32' library (-lws2_32). */
+/* #undef EVENT__HAVE_LIBWS2_32 */
+
 /* Define if the system has zlib */
 #define EVENT__HAVE_LIBZ 1
 
 /* Define to 1 if you have the `mach_absolute_time' function. */
 /* #undef EVENT__HAVE_MACH_ABSOLUTE_TIME */
 
+/* Define to 1 if you have the <mach/mach.h> header file. */
+/* #undef EVENT__HAVE_MACH_MACH_H */
+
 /* Define to 1 if you have the <mach/mach_time.h> header file. */
 /* #undef EVENT__HAVE_MACH_MACH_TIME_H */
 
@@ -177,11 +181,14 @@
 /* Define if the system has openssl */
 #define EVENT__HAVE_OPENSSL 1
 
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#define EVENT__HAVE_OPENSSL_SSL_H 1
+
 /* Define to 1 if you have the `pipe' function. */
 #define EVENT__HAVE_PIPE 1
 
 /* Define to 1 if you have the `pipe2' function. */
-/* #undef EVENT__HAVE_PIPE2 */
+#define EVENT__HAVE_PIPE2 1
 
 /* Define to 1 if you have the `poll' function. */
 #define EVENT__HAVE_POLL 1
@@ -273,6 +280,9 @@
 /* Define to 1 if `s6_addr32' is a member of `struct in6_addr'. */
 /* #undef EVENT__HAVE_STRUCT_IN6_ADDR_S6_ADDR32 */
 
+/* Define to 1 if the system has the type `struct linger'. */
+#define EVENT__HAVE_STRUCT_LINGER 1
+
 /* Define to 1 if the system has the type `struct sockaddr_in6'. */
 #define EVENT__HAVE_STRUCT_SOCKADDR_IN6 1
 
@@ -291,8 +301,8 @@
 /* Define to 1 if `__ss_family' is a member of `struct sockaddr_storage'. */
 /* #undef EVENT__HAVE_STRUCT_SOCKADDR_STORAGE___SS_FAMILY */
 
-/* Define to 1 if the system has the type `struct so_linger'. */
-/* #undef EVENT__HAVE_STRUCT_SO_LINGER */
+/* Define to 1 if the system has the type `struct sockaddr_un'. */
+#define EVENT__HAVE_STRUCT_SOCKADDR_UN 1
 
 /* Define to 1 if you have the `sysctl' function. */
 /* #undef EVENT__HAVE_SYSCTL */
@@ -321,6 +331,9 @@
 /* Define to 1 if you have the <sys/queue.h> header file. */
 #define EVENT__HAVE_SYS_QUEUE_H 1
 
+/* Define to 1 if you have the <sys/random.h> header file. */
+#define EVENT__HAVE_SYS_RANDOM_H 1
+
 /* Define to 1 if you have the <sys/resource.h> header file. */
 #define EVENT__HAVE_SYS_RESOURCE_H 1
 
@@ -351,6 +364,9 @@
 /* Define to 1 if you have the <sys/uio.h> header file. */
 #define EVENT__HAVE_SYS_UIO_H 1
 
+/* Define to 1 if you have the <sys/un.h> header file. */
+#define EVENT__HAVE_SYS_UN_H 1
+
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #define EVENT__HAVE_SYS_WAIT_H 1
 
@@ -402,20 +418,29 @@
 /* Define to 1 if you have the `vasprintf' function. */
 #define EVENT__HAVE_VASPRINTF 1
 
-/* Define if waitpid() supports WNOWAIT */
-#define EVENT__HAVE_WAITPID_WITH_WNOWAIT 1
-
 /* Define if kqueue works correctly with pipes */
 /* #undef EVENT__HAVE_WORKING_KQUEUE */
 
 /* Define to 1 if you have the <zlib.h> header file. */
 #define EVENT__HAVE_ZLIB_H 1
 
+/* Define to 1 if you have the `_gmtime64' function. */
+/* #undef EVENT__HAVE__GMTIME64 */
+
+/* Define to 1 if you have the `_gmtime64_s' function. */
+/* #undef EVENT__HAVE__GMTIME64_S */
+
+/* Define to 1 if compiler have __FUNCTION__ */
+#define EVENT__HAVE___FUNCTION__ 1
+
+/* Define to 1 if compiler have __func__ */
+#define EVENT__HAVE___func__ 1
+
 /* Define to the sub-directory where libtool stores uninstalled libraries. */
 #define EVENT__LT_OBJDIR ".libs/"
 
 /* Numeric representation of the version */
-#define EVENT__NUMERIC_VERSION 0x02010800
+#define EVENT__NUMERIC_VERSION 0x02010c00
 
 /* Name of package */
 #define EVENT__PACKAGE "libevent"
@@ -427,7 +452,7 @@
 #define EVENT__PACKAGE_NAME "libevent"
 
 /* Define to the full name and version of this package. */
-#define EVENT__PACKAGE_STRING "libevent 2.1.8-stable"
+#define EVENT__PACKAGE_STRING "libevent 2.1.12-stable"
 
 /* Define to the one symbol short name of this package. */
 #define EVENT__PACKAGE_TARNAME "libevent"
@@ -436,7 +461,7 @@
 #define EVENT__PACKAGE_URL ""
 
 /* Define to the version of this package. */
-#define EVENT__PACKAGE_VERSION "2.1.8-stable"
+#define EVENT__PACKAGE_VERSION "2.1.12-stable"
 
 /* Define to necessary symbol if this constant uses a non-standard name on
    your system. */
@@ -476,6 +501,13 @@
 #define EVENT__SIZEOF_SIZE_T 4
 #endif
 
+/* The size of `time_t', as computed by sizeof. */
+#ifdef __LP64__
+#define EVENT__SIZEOF_TIME_T 8
+#else
+#define EVENT__SIZEOF_TIME_T 4
+#endif
+
 /* The size of `void *', as computed by sizeof. */
 #ifdef __LP64__
 #define EVENT__SIZEOF_VOID_P 8
@@ -488,83 +520,83 @@
 /* ------------------------------------------------------------------------ */
 
 /* Define to 1 if you have the ANSI C header files. */
-#define EVENT__STDC_HEADERS 1
+#define STDC_HEADERS 1
 
 /* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
 #define EVENT__TIME_WITH_SYS_TIME 1
 
 /* Enable extensions on AIX 3, Interix.  */
-#ifndef EVENT___ALL_SOURCE
-# define EVENT___ALL_SOURCE 1
+#ifndef _ALL_SOURCE
+# define _ALL_SOURCE 1
 #endif
 /* Enable GNU extensions on systems that have them.  */
-#ifndef EVENT___GNU_SOURCE
-# define EVENT___GNU_SOURCE 1
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE 1
 #endif
 /* Enable threading extensions on Solaris.  */
-#ifndef EVENT___POSIX_PTHREAD_SEMANTICS
-# define EVENT___POSIX_PTHREAD_SEMANTICS 1
+#ifndef _POSIX_PTHREAD_SEMANTICS
+# define _POSIX_PTHREAD_SEMANTICS 1
 #endif
 /* Enable extensions on HP NonStop.  */
-#ifndef EVENT___TANDEM_SOURCE
-# define EVENT___TANDEM_SOURCE 1
+#ifndef _TANDEM_SOURCE
+# define _TANDEM_SOURCE 1
 #endif
 /* Enable general extensions on Solaris.  */
-#ifndef EVENT____EXTENSIONS__
-# define EVENT____EXTENSIONS__ 1
+#ifndef __EXTENSIONS__
+# define __EXTENSIONS__ 1
 #endif
 
 
 /* Version number of package */
-#define EVENT__VERSION "2.1.8-stable"
+#define EVENT__VERSION "2.1.12-stable"
 
 /* Enable large inode numbers on Mac OS X 10.5.  */
-#ifndef EVENT___DARWIN_USE_64_BIT_INODE
-# define EVENT___DARWIN_USE_64_BIT_INODE 1
+#ifndef _DARWIN_USE_64_BIT_INODE
+# define _DARWIN_USE_64_BIT_INODE 1
 #endif
 
 /* Number of bits in a file offset, on hosts where this is settable. */
 #ifdef __LP64__
-/* #undef EVENT___FILE_OFFSET_BITS */
+/* #undef _FILE_OFFSET_BITS */
 #else
-#define EVENT___FILE_OFFSET_BITS 64
+#define _FILE_OFFSET_BITS 64
 #endif
 
 /* Define for large files, on AIX-style hosts. */
-/* #undef EVENT___LARGE_FILES */
+/* #undef _LARGE_FILES */
 
 /* Define to 1 if on MINIX. */
-/* #undef EVENT___MINIX */
+/* #undef _MINIX */
 
 /* Define to 2 if the system does not provide POSIX.1 features except with
    this defined. */
-/* #undef EVENT___POSIX_1_SOURCE */
+/* #undef _POSIX_1_SOURCE */
 
 /* Define to 1 if you need to in order for `stat' and other things to work. */
-/* #undef EVENT___POSIX_SOURCE */
+/* #undef _POSIX_SOURCE */
 
 /* Define to appropriate substitue if compiler doesnt have __func__ */
-/* #undef EVENT____func__ */
+/* #undef __func__ */
 
 /* Define to empty if `const' does not conform to ANSI C. */
-/* #undef EVENT__const */
+/* #undef const */
 
 /* Define to `__inline__' or `__inline' if that's what the C compiler
    calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef EVENT____cplusplus
-/* #undef EVENT__inline */
+#ifndef __cplusplus
+/* #undef inline */
 #endif
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__pid_t */
+/* #undef pid_t */
 
 /* Define to `unsigned int' if <sys/types.h> does not define. */
-/* #undef EVENT__size_t */
+/* #undef size_t */
 
 /* Define to unsigned int if you dont have it */
-/* #undef EVENT__socklen_t */
+/* #undef socklen_t */
 
 /* Define to `int' if <sys/types.h> does not define. */
-/* #undef EVENT__ssize_t */
+/* #undef ssize_t */
 
 #endif /* event2/event-config.h */
diff --git a/ipc/chromium/src/third_party/libevent/strlcpy-internal.h b/ipc/chromium/src/third_party/libevent/strlcpy-internal.h
index cfc27ec66276..4151d601d0b1 100644
--- a/ipc/chromium/src/third_party/libevent/strlcpy-internal.h
+++ b/ipc/chromium/src/third_party/libevent/strlcpy-internal.h
@@ -6,10 +6,12 @@ extern "C" {
 #endif
 
 #include "event2/event-config.h"
+#include "event2/visibility.h"
 #include "evconfig-private.h"
 
 #ifndef EVENT__HAVE_STRLCPY
 #include <string.h>
+EVENT2_EXPORT_SYMBOL
 size_t event_strlcpy_(char *dst, const char *src, size_t siz);
 #define strlcpy event_strlcpy_
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/test-export/CMakeLists.txt b/ipc/chromium/src/third_party/libevent/test-export/CMakeLists.txt
new file mode 100644
index 000000000000..53a1cf527bfc
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/test-export/CMakeLists.txt
@@ -0,0 +1,15 @@
+cmake_minimum_required(VERSION 3.1.2)
+if (POLICY CMP0074)
+    cmake_policy(SET CMP0074 NEW)
+endif()
+project(verify)
+# set(CMAKE_VERBOSE_MAKEFILE 1)
+if(NOT ${EVENT__CODE_COMPONENT} STREQUAL "")
+    string(TOUPPER ${EVENT__CODE_COMPONENT} _UPPER_COMPONENT)
+endif()
+find_package(Libevent 2.1.0 REQUIRED COMPONENTS ${EVENT__LINK_COMPONENT})
+add_definitions(-DEVENT_EXPORT_TEST_COMPONENT_${_UPPER_COMPONENT})
+add_executable(test-export test-export.c)
+target_link_libraries(test-export ${LIBEVENT_LIBRARIES})
+enable_testing()
+add_test(test-export test-export)
diff --git a/ipc/chromium/src/third_party/libevent/test-export/test-export.c b/ipc/chromium/src/third_party/libevent/test-export/test-export.c
new file mode 100644
index 000000000000..909177755475
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/test-export/test-export.c
@@ -0,0 +1,122 @@
+#include <event2/event.h>
+#if defined(EVENT_EXPORT_TEST_COMPONENT_EXTRA)
+#include "event2/http.h"
+#include "event2/rpc.h"
+#include <event2/dns.h>
+#elif defined(EVENT_EXPORT_TEST_COMPONENT_PTHREADS)
+#include <event2/thread.h>
+#elif defined(EVENT_EXPORT_TEST_COMPONENT_OPENSSL)
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+#include <event2/bufferevent_ssl.h>
+#endif
+
+#if defined(EVENT_EXPORT_TEST_COMPONENT_EXTRA)
+static int
+test()
+{
+	struct event_base *base = NULL;
+	struct evhttp *http = NULL;
+	struct evdns_base *dns_base = NULL;
+	struct evrpc_base *rpc_base = NULL;
+
+	base = event_base_new();
+	if (base) {
+		http = evhttp_new(base);
+		dns_base = evdns_base_new(base,
+			EVDNS_BASE_DISABLE_WHEN_INACTIVE);
+	}
+	if (http)
+		rpc_base = evrpc_init(http);
+
+	if (base)
+		event_base_free(base);
+	if (http)
+		evhttp_free(http);
+	if (rpc_base)
+		evrpc_free(rpc_base);
+	if (dns_base)
+		evdns_base_free(dns_base, 0);
+
+	return 0;
+}
+#elif defined(EVENT_EXPORT_TEST_COMPONENT_PTHREADS)
+static int
+test()
+{
+	return evthread_use_pthreads();
+}
+#elif defined(EVENT_EXPORT_TEST_COMPONENT_OPENSSL)
+static int
+test()
+{
+	struct event_base *base = NULL;
+	SSL_CTX *ssl_ctx = NULL;
+	SSL *ssl = NULL;
+	struct bufferevent *bev;
+	int r = 1;
+
+	SSL_library_init();
+	ERR_load_crypto_strings();
+	SSL_load_error_strings();
+	OpenSSL_add_all_algorithms();
+
+	base = event_base_new();
+	if (!base) {
+		goto error;
+	}
+
+	ssl_ctx = SSL_CTX_new(SSLv23_method());
+	if (!ssl_ctx) {
+		goto error;
+	}
+	ssl = SSL_new(ssl_ctx);
+	if (ssl == NULL) {
+		goto error;
+	}
+	bev = bufferevent_openssl_socket_new(base, -1, ssl,
+		BUFFEREVENT_SSL_CONNECTING,
+		BEV_OPT_CLOSE_ON_FREE | BEV_OPT_DEFER_CALLBACKS);
+	if (bev == NULL) {
+		goto error;
+	}
+	r = 0;
+error:
+	if (base)
+		event_base_free(base);
+	if (ssl_ctx)
+		SSL_CTX_free(ssl_ctx);
+	if (ssl)
+		SSL_free(ssl);
+	return r;
+}
+#else
+static int
+test()
+{
+	struct event_base *base = NULL;
+
+	base = event_base_new();
+	if (base)
+		event_base_free(base);
+
+	return 0;
+}
+#endif
+
+int
+main(int argc, char const *argv[])
+{
+	int r = 0;
+#ifdef _WIN32
+	{
+		WSADATA wsaData;
+		WSAStartup(MAKEWORD(2, 2), &wsaData);
+	}
+#endif
+	r = test();
+#ifdef _WIN32
+	WSACleanup();
+#endif
+	return r;
+}
diff --git a/ipc/chromium/src/third_party/libevent/test-export/test-export.py b/ipc/chromium/src/third_party/libevent/test-export/test-export.py
new file mode 100644
index 000000000000..d71e5dbaa194
--- /dev/null
+++ b/ipc/chromium/src/third_party/libevent/test-export/test-export.py
@@ -0,0 +1,199 @@
+#!/usr/bin/env python3
+#
+# Check if find_package(Libevent COMPONENTS xxx) can get the correct library.
+# Note: this script has only been tested on python3.
+# Usage:
+#   cd cmake-build-dir
+#   cmake <options> .. && cmake --build .
+#   python /path/to/test-export.py [static|shared]
+
+import sys
+import os
+import shutil
+import platform
+import subprocess
+import tempfile
+
+results = ("success", "failure")
+FNULL = open(os.devnull, 'wb')
+script_dir = os.path.split(os.path.realpath(sys.argv[0]))[0]
+# working_dir is cmake build dir
+working_dir = os.getcwd()
+if len(sys.argv) > 1 and sys.argv[1] == "static":
+    link_type = sys.argv[1]
+else:
+    link_type = "shared"
+
+
+def exec_cmd(cmd, silent):
+    if silent:
+        p = subprocess.Popen(cmd, stdout=FNULL, stderr=FNULL, shell=True)
+    else:
+        p = subprocess.Popen(cmd, shell=True)
+    p.communicate()
+    return p.poll()
+
+
+def link_and_run(link, code):
+    """Check if the source code matches the library component.
+
+    Compile source code relative to one component and link to another component.
+    Then run the generated executor.
+
+    Args:
+        link: The name of component that the source code will link with.
+        code: The source code related component name.
+
+    Returns:
+        Returns 0 if links and runs successfully, otherwise 1.
+    """
+    exec_cmd("cmake --build . --target clean", True)
+    arch = ''
+    if platform.system() == "Windows":
+        arch = '-A x64'
+    cmd = 'cmake .. %s -DEVENT__LINK_COMPONENT=%s -DEVENT__CODE_COMPONENT=%s' % (
+        arch, link, code)
+    if link_type == "static":
+        cmd = "".join([cmd, " -DLIBEVENT_STATIC_LINK=1"])
+    r = exec_cmd(cmd, True)
+    if r == 0:
+        r = exec_cmd('cmake --build .', True)
+        if r == 0:
+            r = exec_cmd('ctest', True)
+    if r != 0:
+        r = 1
+    return r
+
+# expect  0:success 1:failure
+def testcase(link, code, expect):
+    r = link_and_run(link, code)
+    if link == "":
+        link = "all"
+    if code == "":
+        code = "all"
+    if r != expect:
+        print('[test-export] fail: link %s and run %s expects %s but gets %s.' %
+              (link, code, results[expect], results[r]))
+        sys.exit(1)
+    else:
+        print('[test-export] success: link %s and run %s expects and gets %s.' %
+              (link, code, results[r]))
+
+# Dependency relationships between libevent libraries:
+#   core:        none
+#   extra:       core
+#   pthreads:    core,pthread
+#   openssl:     core,openssl
+def test_group():
+    testcase("core", "core", 0)
+    testcase("extra", "extra", 0)
+    testcase("openssl", "openssl", 0)
+    testcase("", "", 0)
+    testcase("extra", "core", 0)
+    testcase("openssl", "core", 0)
+    testcase("core", "extra", 1)
+    testcase("core", "openssl", 1)
+    testcase("extra", "openssl", 1)
+    testcase("openssl", "extra", 1)
+    if platform.system() != "Windows":
+        testcase("pthreads", "pthreads", 0)
+        testcase("pthreads", "core", 0)
+        testcase("core", "pthreads", 1)
+        testcase("extra", "pthreads", 1)
+        testcase("pthreads", "extra", 1)
+        testcase("pthreads", "openssl", 1)
+        testcase("openssl", "pthreads", 1)
+
+
+def config_restore():
+    if os.path.isfile("tempconfig") and not os.path.isfile("LibeventConfig.cmake"):
+        os.rename("tempconfig", "LibeventConfig.cmake")
+
+
+def config_backup():
+    if os.path.isfile("tempconfig"):
+        os.remove("tempconfig")
+    if os.path.isfile("LibeventConfig.cmake"):
+        os.rename("LibeventConfig.cmake", "tempconfig")
+
+
+shutil.rmtree(os.path.join(script_dir, "build"), ignore_errors=True)
+
+
+def run_test_group():
+    os.chdir(script_dir)
+    if not os.path.isdir("build"):
+        os.mkdir("build")
+    os.chdir("build")
+    test_group()
+    os.chdir(working_dir)
+
+
+need_exportdll = False
+if link_type == "shared" and platform.system() == "Windows":
+    need_exportdll = True
+
+# On Windows, we need to add the directory containing the dll to the
+# 'PATH' environment variable so that the program can call it.
+def export_dll(dir):
+    if need_exportdll:
+        os.environ["PATH"] += os.pathsep + dir
+
+
+def unexport_dll(dir):
+    if need_exportdll:
+        paths = os.environ["PATH"].split(os.pathsep)
+        paths = list(set(paths))
+        if dir in paths:
+            paths.remove(dir)
+        os.environ["PATH"] = os.pathsep.join(paths)
+
+
+print("[test-export] use %s library" % link_type)
+
+# Test for build tree.
+print("[test-export] test for build tree")
+dllpath = os.path.join(working_dir, "bin", "Debug")
+config_restore()
+os.environ["CMAKE_PREFIX_PATH"] = working_dir
+export_dll(dllpath)
+run_test_group()
+del os.environ["CMAKE_PREFIX_PATH"]
+unexport_dll(dllpath)
+
+# Install libevent libraries to system path. Remove LibeventConfig.cmake
+# from build directory to avoid confusion when using find_package().
+print("[test-export] test for install tree(in system-wide path)")
+if platform.system() == "Windows":
+    prefix = "C:\\Program Files\\libevent"
+    dllpath = os.path.join(prefix, "lib")
+else:
+    prefix = "/usr/local"
+exec_cmd('cmake -DCMAKE_INSTALL_PREFIX="%s" ..' % prefix, True)
+exec_cmd('cmake --build . --target install', True)
+config_backup()
+os.environ["CMAKE_PREFIX_PATH"] = os.path.join(prefix, "lib/cmake/libevent")
+export_dll(dllpath)
+run_test_group()
+unexport_dll(dllpath)
+del os.environ["CMAKE_PREFIX_PATH"]
+
+# Uninstall the libraries installed in the above steps. Install the libraries
+# into a temporary directory. Same as above, remove LibeventConfig.cmake from
+# build directory to avoid confusion when using find_package().
+print("[test-export] test for install tree(in non-system-wide path)")
+exec_cmd("cmake --build . --target uninstall", True)
+tempdir = tempfile.TemporaryDirectory()
+cmd = 'cmake -DCMAKE_INSTALL_PREFIX="%s" ..' % tempdir.name
+exec_cmd(cmd, True)
+exec_cmd("cmake --build . --target install", True)
+config_backup()
+os.environ["CMAKE_PREFIX_PATH"] = os.path.join(tempdir.name, "lib/cmake/libevent")
+dllpath = os.path.join(tempdir.name, "lib")
+export_dll(dllpath)
+run_test_group()
+unexport_dll(dllpath)
+del os.environ["CMAKE_PREFIX_PATH"]
+config_restore()
+
+print("[test-export] all testcases have run successfully")
diff --git a/ipc/chromium/src/third_party/libevent/test/bench.c b/ipc/chromium/src/third_party/libevent/test/bench.c
index 214479c1ff31..f2af4d3f30d1 100644
--- a/ipc/chromium/src/third_party/libevent/test/bench.c
+++ b/ipc/chromium/src/third_party/libevent/test/bench.c
@@ -34,6 +34,7 @@
  */
 
 #include "event2/event-config.h"
+#include "../util-internal.h"
 
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -64,10 +65,12 @@
 #include <event.h>
 #include <evutil.h>
 
-static int count, writes, fired, failures;
+static ev_ssize_t count, fired;
+static int writes, failures;
 static evutil_socket_t *pipes;
 static int num_pipes, num_active, num_writes;
 static struct event *events;
+static struct event_base *base;
 
 
 static void
@@ -103,11 +106,11 @@ run_once(void)
 	for (cp = pipes, i = 0; i < num_pipes; i++, cp += 2) {
 		if (event_initialized(&events[i]))
 			event_del(&events[i]);
-		event_set(&events[i], cp[0], EV_READ | EV_PERSIST, read_cb, (void *)(ev_intptr_t) i);
+		event_assign(&events[i], base, cp[0], EV_READ | EV_PERSIST, read_cb, (void *)(ev_intptr_t) i);
 		event_add(&events[i], NULL);
 	}
 
-	event_loop(EVLOOP_ONCE | EVLOOP_NONBLOCK);
+	event_base_loop(base, EVLOOP_ONCE | EVLOOP_NONBLOCK);
 
 	fired = 0;
 	space = num_pipes / num_active;
@@ -117,15 +120,18 @@ run_once(void)
 
 	count = 0;
 	writes = num_writes;
-	{ int xcount = 0;
-	evutil_gettimeofday(&ts, NULL);
-	do {
-		event_loop(EVLOOP_ONCE | EVLOOP_NONBLOCK);
-		xcount++;
-	} while (count != fired);
-	evutil_gettimeofday(&te, NULL);
-
-	if (xcount != count) fprintf(stderr, "Xcount: %d, Rcount: %d\n", xcount, count);
+	{
+		int xcount = 0;
+		evutil_gettimeofday(&ts, NULL);
+		do {
+			event_base_loop(base, EVLOOP_ONCE | EVLOOP_NONBLOCK);
+			xcount++;
+		} while (count != fired);
+		evutil_gettimeofday(&te, NULL);
+
+		if (xcount != count)
+			fprintf(stderr, "Xcount: %d, Rcount: " EV_SSIZE_FMT "\n",
+				xcount, count);
 	}
 
 	evutil_timersub(&te, &ts, &te);
@@ -136,12 +142,15 @@ run_once(void)
 int
 main(int argc, char **argv)
 {
-#ifdef HAVE_SETRLIMIT 
+#ifdef EVENT__HAVE_SETRLIMIT
 	struct rlimit rl;
 #endif
 	int i, c;
 	struct timeval *tv;
 	evutil_socket_t *cp;
+	const char **methods;
+	const char *method = NULL;
+	struct event_config *cfg = NULL;
 
 #ifdef _WIN32
 	WSADATA WSAData;
@@ -150,7 +159,7 @@ main(int argc, char **argv)
 	num_pipes = 100;
 	num_active = 1;
 	num_writes = num_pipes;
-	while ((c = getopt(argc, argv, "n:a:w:")) != -1) {
+	while ((c = getopt(argc, argv, "n:a:w:m:l")) != -1) {
 		switch (c) {
 		case 'n':
 			num_pipes = atoi(optarg);
@@ -161,13 +170,23 @@ main(int argc, char **argv)
 		case 'w':
 			num_writes = atoi(optarg);
 			break;
+		case 'm':
+			method = optarg;
+			break;
+		case 'l':
+			methods = event_get_supported_methods();
+			fprintf(stdout, "Using Libevent %s. Available methods are:\n",
+				event_get_version());
+			for (i = 0; methods[i] != NULL; ++i)
+				printf("    %s\n", methods[i]);
+			exit(0);
 		default:
 			fprintf(stderr, "Illegal argument \"%c\"\n", c);
 			exit(1);
 		}
 	}
 
-#ifdef HAVE_SETRLIMIT
+#ifdef EVENT__HAVE_SETRLIMIT
 	rl.rlim_cur = rl.rlim_max = num_pipes * 2 + 50;
 	if (setrlimit(RLIMIT_NOFILE, &rl) == -1) {
 		perror("setrlimit");
@@ -182,7 +201,16 @@ main(int argc, char **argv)
 		exit(1);
 	}
 
-	event_init();
+	if (method != NULL) {
+		cfg = event_config_new();
+		methods = event_get_supported_methods();
+		for (i = 0; methods[i] != NULL; ++i)
+			if (strcmp(methods[i], method))
+				event_config_avoid_method(cfg, methods[i]);
+		base = event_base_new_with_config(cfg);
+		event_config_free(cfg);
+	} else
+		base = event_base_new();
 
 	for (cp = pipes, i = 0; i < num_pipes; i++, cp += 2) {
 #ifdef USE_PIPES
diff --git a/ipc/chromium/src/third_party/libevent/test/bench_cascade.c b/ipc/chromium/src/third_party/libevent/test/bench_cascade.c
index 2d85cc1f1038..29a3203ecdd6 100644
--- a/ipc/chromium/src/third_party/libevent/test/bench_cascade.c
+++ b/ipc/chromium/src/third_party/libevent/test/bench_cascade.c
@@ -35,7 +35,8 @@
 #ifdef _WIN32
 #define WIN32_LEAN_AND_MEAN
 #include <windows.h>
-#else
+#include <getopt.h>
+#else /* _WIN32 */
 #include <sys/socket.h>
 #include <sys/resource.h>
 #endif
@@ -48,7 +49,6 @@
 #include <unistd.h>
 #endif
 #include <errno.h>
-#include <getopt.h>
 #include <event.h>
 #include <evutil.h>
 
@@ -139,7 +139,7 @@ run_once(int num_pipes)
 int
 main(int argc, char **argv)
 {
-#ifdef HAVE_SETRLIMIT
+#ifdef EVENT__HAVE_SETRLIMIT
 	struct rlimit rl;
 #endif
 	int i, c;
@@ -162,7 +162,7 @@ main(int argc, char **argv)
 		}
 	}
 
-#ifdef HAVE_SETRLIMIT 
+#ifdef EVENT__HAVE_SETRLIMIT
 	rl.rlim_cur = rl.rlim_max = num_pipes * 2 + 50;
 	if (setrlimit(RLIMIT_NOFILE, &rl) == -1) {
 		perror("setrlimit");
diff --git a/ipc/chromium/src/third_party/libevent/test/bench_http.c b/ipc/chromium/src/third_party/libevent/test/bench_http.c
index d20d3bc79010..80377ee60583 100644
--- a/ipc/chromium/src/third_party/libevent/test/bench_http.c
+++ b/ipc/chromium/src/third_party/libevent/test/bench_http.c
@@ -101,6 +101,9 @@ main(int argc, char **argv)
 		return (1);
 #endif
 
+	setbuf(stdout, NULL);
+	setbuf(stderr, NULL);
+
 	for (i = 1; i < argc; ++i) {
 		if (*argv[i] != '-')
 			continue;
diff --git a/ipc/chromium/src/third_party/libevent/test/bench_httpclient.c b/ipc/chromium/src/third_party/libevent/test/bench_httpclient.c
index e15929519dcc..7c7ee470a307 100644
--- a/ipc/chromium/src/third_party/libevent/test/bench_httpclient.c
+++ b/ipc/chromium/src/third_party/libevent/test/bench_httpclient.c
@@ -113,13 +113,13 @@ errorcb(struct bufferevent *b, short what, void *arg)
 static void
 frob_socket(evutil_socket_t sock)
 {
-#ifdef HAVE_SO_LINGER
+#ifdef EVENT__HAVE_STRUCT_LINGER
 	struct linger l;
 #endif
 	int one = 1;
 	if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void*)&one, sizeof(one))<0)
 		perror("setsockopt(SO_REUSEADDR)");
-#ifdef HAVE_SO_LINGER
+#ifdef EVENT__HAVE_STRUCT_LINGER
 	l.l_onoff = 1;
 	l.l_linger = 0;
 	if (setsockopt(sock, SOL_SOCKET, SO_LINGER, (void*)&l, sizeof(l))<0)
diff --git a/ipc/chromium/src/third_party/libevent/test/check-dumpevents.py b/ipc/chromium/src/third_party/libevent/test/check-dumpevents.py
index 16fe9bc92fdf..3e1df30c4f40 100755
--- a/ipc/chromium/src/third_party/libevent/test/check-dumpevents.py
+++ b/ipc/chromium/src/third_party/libevent/test/check-dumpevents.py
@@ -1,4 +1,4 @@
-#!/usr/bin/python2
+#!/usr/bin/env python
 #
 # Post-process the output of test-dumpevents and check it for correctness.
 #
@@ -15,12 +15,12 @@ try:
     got_inserted_pos = text.index("Inserted events:\n")
     got_active_pos = text.index("Active events:\n")
 except ValueError:
-    print >>sys.stderr, "Missing expected dividing line in dumpevents output"
+    sys.stderr.write("Missing expected dividing line in dumpevents output")
     sys.exit(1)
 
 if not (expect_inserted_pos < expect_active_pos <
         got_inserted_pos < got_active_pos):
-    print >>sys.stderr, "Sections out of order in dumpevents output"
+    sys.stderr.write("Sections out of order in dumpevents output")
     sys.exit(1)
 
 now,T= text[1].split()
@@ -45,10 +45,10 @@ cleaned_inserted = set( pat.sub(replace_time, s) for s in got_inserted
                         if "Internal" not in s)
 
 if cleaned_inserted != want_inserted:
-    print >>sys.stderr, "Inserted event lists were not as expected!"
+    sys.stderr.write("Inserted event lists were not as expected!")
     sys.exit(1)
 
 if set(got_active) != set(want_active):
-    print >>sys.stderr, "Active event lists were not as expected!"
+    sys.stderr.write("Active event lists were not as expected!")
     sys.exit(1)
 
diff --git a/ipc/chromium/src/third_party/libevent/test/include.am b/ipc/chromium/src/third_party/libevent/test/include.am
index eea249f80229..043752471aed 100644
--- a/ipc/chromium/src/third_party/libevent/test/include.am
+++ b/ipc/chromium/src/third_party/libevent/test/include.am
@@ -12,6 +12,7 @@ EXTRA_DIST+=					\
 	test/regress.gen.h				\
 	test/regress.rpc				\
 	test/rpcgen_wrapper.sh			\
+	test/print-winsock-errors.c			\
 	test/test.sh
 
 TESTPROGRAMS = \
@@ -56,26 +57,26 @@ TESTS = \
 LOG_COMPILER = true
 TESTS_COMPILER = true
 
-test_runner_epoll: test/test.sh
-	test/test.sh -b EPOLL
-test_runner_select: test/test.sh
-	test/test.sh -b SELECT
-test_runner_kqueue: test/test.sh
-	test/test.sh -b KQUEUE
-test_runner_evport: test/test.sh
-	test/test.sh -b EVPORT
-test_runner_devpoll: test/test.sh
-	test/test.sh -b DEVPOLL
-test_runner_poll: test/test.sh
-	test/test.sh -b POLL
-test_runner_win32: test/test.sh
-	test/test.sh -b WIN32
-test_runner_timerfd: test/test.sh
-	test/test.sh -b "" -t
-test_runner_changelist: test/test.sh
-	test/test.sh -b "" -c
-test_runner_timerfd_changelist: test/test.sh
-	test/test.sh -b "" -T
+test_runner_epoll: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b EPOLL
+test_runner_select: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b SELECT
+test_runner_kqueue: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b KQUEUE
+test_runner_evport: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b EVPORT
+test_runner_devpoll: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b DEVPOLL
+test_runner_poll: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b POLL
+test_runner_win32: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b WIN32
+test_runner_timerfd: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b "" -t
+test_runner_changelist: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b "" -c
+test_runner_timerfd_changelist: $(top_srcdir)/test/test.sh
+	$(top_srcdir)/test/test.sh -b "" -T
 
 DISTCLEANFILES += test/regress.gen.c test/regress.gen.h
 
@@ -139,7 +140,7 @@ if BUILD_WIN32
 test_regress_SOURCES += test/regress_iocp.c
 endif
 
-test_regress_LDADD = $(LIBEVENT_GC_SECTIONS) libevent.la $(PTHREAD_LIBS) $(ZLIB_LIBS)
+test_regress_LDADD = $(LIBEVENT_GC_SECTIONS) libevent_core.la libevent_extra.la $(PTHREAD_LIBS) $(ZLIB_LIBS)
 test_regress_CPPFLAGS = $(AM_CPPFLAGS) $(PTHREAD_CFLAGS) $(ZLIB_CFLAGS) -Itest
 test_regress_LDFLAGS = $(PTHREAD_CFLAGS)
 
diff --git a/ipc/chromium/src/third_party/libevent/test/regress.c b/ipc/chromium/src/third_party/libevent/test/regress.c
index d8a6b9b85485..08c30fab9b9b 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress.c
@@ -31,10 +31,6 @@
 #include <windows.h>
 #endif
 
-#ifdef EVENT__HAVE_PTHREADS
-#include <pthread.h>
-#endif
-
 #include "event2/event-config.h"
 
 #include <sys/types.h>
@@ -46,6 +42,7 @@
 #ifndef _WIN32
 #include <sys/socket.h>
 #include <sys/wait.h>
+#include <limits.h>
 #include <signal.h>
 #include <unistd.h>
 #include <netdb.h>
@@ -72,6 +69,7 @@
 #include "time-internal.h"
 
 #include "regress.h"
+#include "regress_thread.h"
 
 #ifndef _WIN32
 #include "regress.gen.h"
@@ -389,7 +387,7 @@ record_event_cb(evutil_socket_t s, short what, void *ptr)
 }
 
 static void
-test_simpleclose(void *ptr)
+test_simpleclose_rw(void *ptr)
 {
 	/* Test that a close of FD is detected as a read and as a write. */
 	struct event_base *base = event_base_new();
@@ -471,6 +469,56 @@ end:
 		event_base_free(base);
 }
 
+static void
+test_simpleclose(void *ptr)
+{
+	struct basic_test_data *data = ptr;
+	struct event_base *base      = data->base;
+	evutil_socket_t *pair        = data->pair;
+	const char *flags            = (const char *)data->setup_data;
+	int et                       = !!strstr(flags, "ET");
+	int persist                  = !!strstr(flags, "persist");
+	short events                 = EV_CLOSED | (et ? EV_ET : 0) | (persist ? EV_PERSIST : 0);
+	struct event *ev = NULL;
+	short got_event;
+
+	if (!(event_base_get_features(data->base) & EV_FEATURE_EARLY_CLOSE))
+		tt_skip();
+
+	/* XXX: should this code moved to regress_et.c ? */
+	if (et && !(event_base_get_features(data->base) & EV_FEATURE_ET))
+		tt_skip();
+
+	ev = event_new(base, pair[0], events, record_event_cb, &got_event);
+	tt_assert(ev);
+	tt_assert(!event_add(ev, NULL));
+
+	got_event = 0;
+	if (strstr(flags, "close")) {
+		tt_assert(!evutil_closesocket(pair[1]));
+		/* avoid closing in setup routines */
+		pair[1] = -1;
+	} else if (strstr(flags, "shutdown")) {
+		tt_assert(!shutdown(pair[1], EVUTIL_SHUT_WR));
+	} else {
+		tt_abort_msg("unknown flags");
+	}
+
+	/* w/o edge-triggerd but w/ persist it will not stop */
+	if (!et && persist) {
+		struct timeval tv;
+		tv.tv_sec = 0;
+		tv.tv_usec = 10000;
+		tt_assert(!event_base_loopexit(base, &tv));
+	}
+
+	tt_int_op(event_base_loop(base, EVLOOP_NONBLOCK), ==, !persist);
+	tt_int_op(got_event, ==, (events & ~EV_PERSIST));
+
+end:
+	if (ev)
+		event_free(ev);
+}
 
 static void
 test_multiple(void)
@@ -848,18 +896,36 @@ simple_child_read_cb(evutil_socket_t fd, short event, void *arg)
 
 	called++;
 }
+
+#define TEST_FORK_EXIT_SUCCESS 76
+static void fork_wait_check(int pid)
+{
+	int status;
+
+	TT_BLATHER(("Before waitpid"));
+
+#ifdef WNOWAIT
+	if ((waitpid(pid, &status, WNOWAIT) == -1 && errno == EINVAL) &&
+#else
+	if (
+#endif
+	    waitpid(pid, &status, 0) == -1) {
+		perror("waitpid");
+		exit(1);
+	}
+	TT_BLATHER(("After waitpid"));
+
+	if (WEXITSTATUS(status) != TEST_FORK_EXIT_SUCCESS) {
+		fprintf(stdout, "FAILED (exit): %d\n", WEXITSTATUS(status));
+		exit(1);
+	}
+}
 static void
 test_fork(void)
 {
 	char c;
-	int status;
 	struct event ev, sig_ev, usr_ev, existing_ev;
 	pid_t pid;
-	int wait_flags = 0;
-
-#ifdef EVENT__HAVE_WAITPID_WITH_WNOWAIT
-	wait_flags |= WNOWAIT;
-#endif
 
 	setup_test("After fork: ");
 
@@ -910,8 +976,8 @@ test_fork(void)
 
 		evsignal_set(&usr_ev, SIGUSR1, fork_signal_cb, &usr_ev);
 		evsignal_add(&usr_ev, NULL);
-		raise(SIGUSR1);
-		raise(SIGUSR2);
+		kill(getpid(), SIGUSR1);
+		kill(getpid(), SIGUSR2);
 
 		called = 0;
 
@@ -922,7 +988,7 @@ test_fork(void)
 		/* we do not send an EOF; simple_read_cb requires an EOF
 		 * to set test_ok.  we just verify that the callback was
 		 * called. */
-		exit(test_ok != 0 || called != 2 ? -2 : 76);
+		exit(test_ok != 0 || called != 2 ? -2 : TEST_FORK_EXIT_SUCCESS);
 	}
 
 	/** wait until client read first message */
@@ -933,17 +999,7 @@ test_fork(void)
 		tt_fail_perror("write");
 	}
 
-	TT_BLATHER(("Before waitpid"));
-	if (waitpid(pid, &status, wait_flags) == -1) {
-		perror("waitpid");
-		exit(1);
-	}
-	TT_BLATHER(("After waitpid"));
-
-	if (WEXITSTATUS(status) != 76) {
-		fprintf(stdout, "FAILED (exit): %d\n", WEXITSTATUS(status));
-		exit(1);
-	}
+	fork_wait_check(pid);
 
 	/* test that the current event loop still works */
 	if (write(pair[0], TEST1, strlen(TEST1)+1) < 0) {
@@ -954,8 +1010,8 @@ test_fork(void)
 
 	evsignal_set(&usr_ev, SIGUSR1, fork_signal_cb, &usr_ev);
 	evsignal_add(&usr_ev, NULL);
-	raise(SIGUSR1);
-	raise(SIGUSR2);
+	kill(getpid(), SIGUSR1);
+	kill(getpid(), SIGUSR2);
 
 	event_dispatch();
 
@@ -970,7 +1026,7 @@ test_fork(void)
 		evutil_closesocket(child_pair[1]);
 }
 
-#ifdef EVENT__HAVE_PTHREADS
+#ifdef EVTHREAD_USE_PTHREADS_IMPLEMENTED
 static void* del_wait_thread(void *arg)
 {
 	struct timeval tv_start, tv_end;
@@ -989,23 +1045,23 @@ static void
 del_wait_cb(evutil_socket_t fd, short event, void *arg)
 {
 	struct timeval delay = { 0, 300*1000 };
-	TT_BLATHER(("Sleeping"));
+	TT_BLATHER(("Sleeping: %i", test_ok));
 	evutil_usleep_(&delay);
-	test_ok = 1;
+	++test_ok;
 }
 
 static void
 test_del_wait(void)
 {
 	struct event ev;
-	pthread_t thread;
+	THREAD_T thread;
 
 	setup_test("event_del will wait: ");
 
-	event_set(&ev, pair[1], EV_READ, del_wait_cb, &ev);
+	event_set(&ev, pair[1], EV_READ|EV_PERSIST, del_wait_cb, &ev);
 	event_add(&ev, NULL);
 
-	pthread_create(&thread, NULL, del_wait_thread, NULL);
+	THREAD_START(thread, del_wait_thread, NULL);
 
 	if (write(pair[0], TEST1, strlen(TEST1)+1) < 0) {
 		tt_fail_perror("write");
@@ -1024,11 +1080,41 @@ test_del_wait(void)
 		test_timeval_diff_eq(&tv_start, &tv_end, 270);
 	}
 
-	pthread_join(thread, NULL);
+	THREAD_JOIN(thread);
+
+	tt_int_op(test_ok, ==, 1);
 
 	end:
 	;
 }
+
+static void null_cb(evutil_socket_t fd, short what, void *arg) {}
+static void* test_del_notify_thread(void *arg)
+{
+	event_dispatch();
+	return NULL;
+}
+static void
+test_del_notify(void)
+{
+	struct event ev;
+	THREAD_T thread;
+
+	test_ok = 1;
+
+	event_set(&ev, -1, EV_READ, null_cb, &ev);
+	event_add(&ev, NULL);
+
+	THREAD_START(thread, test_del_notify_thread, NULL);
+
+	{
+		struct timeval delay = { 0, 1000 };
+		evutil_usleep_(&delay);
+	}
+
+	event_del(&ev);
+	THREAD_JOIN(thread);
+}
 #endif
 
 static void
@@ -1127,7 +1213,7 @@ test_immediatesignal(void)
 	test_ok = 0;
 	evsignal_set(&ev, SIGUSR1, signal_cb, &ev);
 	evsignal_add(&ev, NULL);
-	raise(SIGUSR1);
+	kill(getpid(), SIGUSR1);
 	event_loop(EVLOOP_NONBLOCK);
 	evsignal_del(&ev);
 	cleanup_test();
@@ -1200,7 +1286,7 @@ test_signal_switchbase(void)
 
 	test_ok = 0;
 	/* can handle signal before loop is called */
-	raise(SIGUSR1);
+	kill(getpid(), SIGUSR1);
 	event_base_loop(base2, EVLOOP_NONBLOCK);
 	if (is_kqueue) {
 		if (!test_ok)
@@ -1213,7 +1299,7 @@ test_signal_switchbase(void)
 
 		/* set base1 to handle signals */
 		event_base_loop(base1, EVLOOP_NONBLOCK);
-		raise(SIGUSR1);
+		kill(getpid(), SIGUSR1);
 		event_base_loop(base1, EVLOOP_NONBLOCK);
 		event_base_loop(base2, EVLOOP_NONBLOCK);
 	}
@@ -1242,7 +1328,7 @@ test_signal_assert(void)
 	 */
 	evsignal_del(&ev);
 
-	raise(SIGCONT);
+	kill(getpid(), SIGCONT);
 #if 0
 	/* only way to verify we were in evsig_handler() */
 	/* XXXX Now there's no longer a good way. */
@@ -1286,7 +1372,7 @@ test_signal_restore(void)
 	evsignal_add(&ev, NULL);
 	evsignal_del(&ev);
 
-	raise(SIGUSR1);
+	kill(getpid(), SIGUSR1);
 	/* 1 == signal_cb, 2 == signal_cb_sa, we want our previous handler */
 	if (test_ok != 2)
 		test_ok = 0;
@@ -1301,7 +1387,7 @@ signal_cb_swp(int sig, short event, void *arg)
 {
 	called++;
 	if (called < 5)
-		raise(sig);
+		kill(getpid(), sig);
 	else
 		event_loopexit(NULL);
 }
@@ -1313,7 +1399,7 @@ timeout_cb_swp(evutil_socket_t fd, short event, void *arg)
 
 		called = 0;
 		evtimer_add((struct event *)arg, &tv);
-		raise(SIGUSR1);
+		kill(getpid(), SIGUSR1);
 		return;
 	}
 	test_ok = 0;
@@ -1351,18 +1437,14 @@ test_free_active_base(void *ptr)
 	struct event ev1;
 
 	base1 = event_init();
-	if (base1) {
-		event_assign(&ev1, base1, data->pair[1], EV_READ,
-			     dummy_read_cb, NULL);
-		event_add(&ev1, NULL);
-		event_base_free(base1);	 /* should not crash */
-	} else {
-		tt_fail_msg("failed to create event_base for test");
-	}
+	tt_assert(base1);
+	event_assign(&ev1, base1, data->pair[1], EV_READ, dummy_read_cb, NULL);
+	event_add(&ev1, NULL);
+	event_base_free(base1);	 /* should not crash */
 
 	base1 = event_init();
 	tt_assert(base1);
-	event_assign(&ev1, base1, 0, 0, dummy_read_cb, NULL);
+	event_assign(&ev1, base1, data->pair[0], 0, dummy_read_cb, NULL);
 	event_active(&ev1, EV_READ, 1);
 	event_base_free(base1);
 end:
@@ -1840,7 +1922,8 @@ static void send_a_byte_cb(evutil_socket_t fd, short what, void *arg)
 {
 	evutil_socket_t *sockp = arg;
 	(void) fd; (void) what;
-	(void) write(*sockp, "A", 1);
+	if (write(*sockp, "A", 1) < 0)
+		tt_fail_perror("write");
 }
 struct read_not_timeout_param
 {
@@ -2070,60 +2153,48 @@ re_add_read_cb(evutil_socket_t fd, short event, void *arg)
 	if (n_read < 0) {
 		tt_fail_perror("read");
 		event_base_loopbreak(event_get_base(ev_other));
-		return;
 	} else {
 		event_add(ev_other, NULL);
 		++test_ok;
 	}
 }
-
 static void
-test_nonpersist_readd(void)
+test_nonpersist_readd(void *_data)
 {
 	struct event ev1, ev2;
+	struct basic_test_data *data = _data;
 
-	setup_test("Re-add nonpersistent events: ");
-	event_set(&ev1, pair[0], EV_READ, re_add_read_cb, &ev2);
-	event_set(&ev2, pair[1], EV_READ, re_add_read_cb, &ev1);
+	memset(&ev1, 0, sizeof(ev1));
+	memset(&ev2, 0, sizeof(ev2));
 
-	if (write(pair[0], "Hello", 5) < 0) {
-		tt_fail_perror("write(pair[0])");
-	}
+	tt_assert(!event_assign(&ev1, data->base, data->pair[0], EV_READ, re_add_read_cb, &ev2));
+	tt_assert(!event_assign(&ev2, data->base, data->pair[1], EV_READ, re_add_read_cb, &ev1));
 
-	if (write(pair[1], "Hello", 5) < 0) {
-		tt_fail_perror("write(pair[1])\n");
-	}
+	tt_int_op(write(data->pair[0], "Hello", 5), ==, 5);
+	tt_int_op(write(data->pair[1], "Hello", 5), ==, 5);
+
+	tt_int_op(event_add(&ev1, NULL), ==, 0);
+	tt_int_op(event_add(&ev2, NULL), ==, 0);
+	tt_int_op(event_base_loop(data->base, EVLOOP_ONCE), ==, 0);
+	tt_int_op(test_ok, ==, 2);
 
-	if (event_add(&ev1, NULL) == -1 ||
-	    event_add(&ev2, NULL) == -1) {
-		test_ok = 0;
-	}
-	if (test_ok != 0)
-		exit(1);
-	event_loop(EVLOOP_ONCE);
-	if (test_ok != 2)
-		exit(1);
 	/* At this point, we executed both callbacks.  Whichever one got
 	 * called first added the second, but the second then immediately got
 	 * deleted before its callback was called.  At this point, though, it
 	 * re-added the first.
 	 */
-	if (!readd_test_event_last_added) {
-		test_ok = 0;
-	} else if (readd_test_event_last_added == &ev1) {
-		if (!event_pending(&ev1, EV_READ, NULL) ||
-		    event_pending(&ev2, EV_READ, NULL))
-			test_ok = 0;
+	tt_assert(readd_test_event_last_added);
+	if (readd_test_event_last_added == &ev1) {
+		tt_assert(event_pending(&ev1, EV_READ, NULL) && !event_pending(&ev2, EV_READ, NULL));
 	} else {
-		if (event_pending(&ev1, EV_READ, NULL) ||
-		    !event_pending(&ev2, EV_READ, NULL))
-			test_ok = 0;
+		tt_assert(event_pending(&ev2, EV_READ, NULL) && !event_pending(&ev1, EV_READ, NULL));
 	}
 
-	event_del(&ev1);
-	event_del(&ev2);
-
-	cleanup_test();
+end:
+	if (event_initialized(&ev1))
+		event_del(&ev1);
+	if (event_initialized(&ev2))
+		event_del(&ev2);
 }
 
 struct test_pri_event {
@@ -3041,6 +3112,7 @@ test_many_events(void *arg)
 		 * instance of that. */
 		sock[i] = socket(AF_INET, SOCK_DGRAM, 0);
 		tt_assert(sock[i] >= 0);
+		tt_assert(!evutil_make_socket_nonblocking(sock[i]));
 		called[i] = 0;
 		ev[i] = event_new(base, sock[i], EV_WRITE|evflags,
 		    many_event_cb, &called[i]);
@@ -3094,7 +3166,7 @@ test_get_assignment(void *arg)
 	event_get_assignment(ev1, &b, &s, &what, &cb, &cb_arg);
 
 	tt_ptr_op(b, ==, base);
-	tt_int_op(s, ==, data->pair[1]);
+	tt_fd_op(s, ==, data->pair[1]);
 	tt_int_op(what, ==, EV_READ);
 	tt_ptr_op(cb, ==, dummy_read_cb);
 	tt_ptr_op(cb_arg, ==, str);
@@ -3279,6 +3351,46 @@ tabf_cb(evutil_socket_t fd, short what, void *arg)
 	*ptr += 0x10000;
 }
 
+static void
+test_evmap_invalid_slots(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+	struct event *ev1 = NULL, *ev2 = NULL;
+	int e1, e2;
+#ifndef _WIN32
+	struct event *ev3 = NULL, *ev4 = NULL;
+	int e3, e4;
+#endif
+
+	ev1 = evsignal_new(base, -1, dummy_read_cb, (void *)base);
+	ev2 = evsignal_new(base, NSIG, dummy_read_cb, (void *)base);
+	tt_assert(ev1);
+	tt_assert(ev2);
+	e1 = event_add(ev1, NULL);
+	e2 = event_add(ev2, NULL);
+	tt_int_op(e1, !=, 0);
+	tt_int_op(e2, !=, 0);
+#ifndef _WIN32
+	ev3 = event_new(base, INT_MAX, EV_READ, dummy_read_cb, (void *)base);
+	ev4 = event_new(base, INT_MAX / 2, EV_READ, dummy_read_cb, (void *)base);
+	tt_assert(ev3);
+	tt_assert(ev4);
+	e3 = event_add(ev3, NULL);
+	e4 = event_add(ev4, NULL);
+	tt_int_op(e3, !=, 0);
+	tt_int_op(e4, !=, 0);
+#endif
+
+end:
+	event_free(ev1);
+	event_free(ev2);
+#ifndef _WIN32
+	event_free(ev3);
+	event_free(ev4);
+#endif
+}
+
 static void
 test_active_by_fd(void *arg)
 {
@@ -3330,6 +3442,7 @@ test_active_by_fd(void *arg)
 	/* Trigger 2, 3, 4 */
 	event_base_active_by_fd(base, data->pair[0], EV_WRITE);
 	event_base_active_by_fd(base, data->pair[1], EV_READ);
+	event_base_active_by_fd(base, data->pair[1], EV_TIMEOUT);
 #ifndef _WIN32
 	event_base_active_by_signal(base, SIGHUP);
 #endif
@@ -3342,7 +3455,7 @@ test_active_by_fd(void *arg)
 	tt_int_op(e2, ==, EV_WRITE | 0x10000);
 	tt_int_op(e3, ==, EV_READ | 0x10000);
 	/* Mask out EV_WRITE here, since it could be genuinely writeable. */
-	tt_int_op((e4 & ~EV_WRITE), ==, EV_READ | 0x10000);
+	tt_int_op((e4 & ~EV_WRITE), ==, EV_READ | EV_TIMEOUT | 0x10000);
 #ifndef _WIN32
 	tt_int_op(es, ==, EV_SIGNAL | 0x10000);
 #endif
@@ -3377,17 +3490,18 @@ struct testcase_t main_testcases[] = {
 	BASIC(event_assign_selfarg, TT_FORK|TT_NEED_BASE),
 	BASIC(event_base_get_num_events, TT_FORK|TT_NEED_BASE),
 	BASIC(event_base_get_max_events, TT_FORK|TT_NEED_BASE),
+	BASIC(evmap_invalid_slots, TT_FORK|TT_NEED_BASE),
 
 	BASIC(bad_assign, TT_FORK|TT_NEED_BASE|TT_NO_LOGS),
 	BASIC(bad_reentrant, TT_FORK|TT_NEED_BASE|TT_NO_LOGS),
-	BASIC(active_later, TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR),
+	BASIC(active_later, TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR|TT_RETRIABLE),
 	BASIC(event_remove_timeout, TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR),
 
 	/* These are still using the old API */
 	LEGACY(persistent_timeout, TT_FORK|TT_NEED_BASE),
 	{ "persistent_timeout_jump", test_persistent_timeout_jump, TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
 	{ "persistent_active_timeout", test_persistent_active_timeout,
-	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+	  TT_FORK|TT_NEED_BASE|TT_RETRIABLE, &basic_setup, NULL },
 	LEGACY(priorities, TT_FORK|TT_NEED_BASE),
 	BASIC(priority_active_inversion, TT_FORK|TT_NEED_BASE),
 	{ "common_timeout", test_common_timeout, TT_FORK|TT_NEED_BASE,
@@ -3397,8 +3511,35 @@ struct testcase_t main_testcases[] = {
 	LEGACY(simpleread, TT_ISOLATED),
 	LEGACY(simpleread_multiple, TT_ISOLATED),
 	LEGACY(simplewrite, TT_ISOLATED),
-	{ "simpleclose", test_simpleclose, TT_FORK, &basic_setup,
-	  NULL },
+	{ "simpleclose_rw", test_simpleclose_rw, TT_FORK, &basic_setup, NULL },
+	/* simpleclose */
+	{ "simpleclose_close", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"close" },
+	{ "simpleclose_shutdown", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"shutdown" },
+	/* simpleclose_*_persist */
+	{ "simpleclose_close_persist", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"close_persist" },
+	{ "simpleclose_shutdown_persist", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"shutdown_persist" },
+	/* simpleclose_*_et */
+	{ "simpleclose_close_et", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"close_ET" },
+	{ "simpleclose_shutdown_et", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"shutdown_ET" },
+	/* simpleclose_*_persist_et */
+	{ "simpleclose_close_persist_et", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"close_persist_ET" },
+	{ "simpleclose_shutdown_persist_et", test_simpleclose,
+	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE,
+	  &basic_setup, (void *)"shutdown_persist_ET" },
 	LEGACY(multiple, TT_ISOLATED),
 	LEGACY(persistent, TT_ISOLATED),
 	LEGACY(combined, TT_ISOLATED),
@@ -3406,7 +3547,7 @@ struct testcase_t main_testcases[] = {
 	LEGACY(loopbreak, TT_ISOLATED),
 	LEGACY(loopexit, TT_ISOLATED),
 	LEGACY(loopexit_multiple, TT_ISOLATED),
-	LEGACY(nonpersist_readd, TT_ISOLATED),
+	{ "nonpersist_readd", test_nonpersist_readd, TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE, &basic_setup, NULL },
 	LEGACY(multiple_events_for_same_fd, TT_ISOLATED),
 	LEGACY(want_only_once, TT_ISOLATED),
 	{ "event_once", test_event_once, TT_ISOLATED, &basic_setup, NULL },
@@ -3438,9 +3579,10 @@ struct testcase_t main_testcases[] = {
 #ifndef _WIN32
 	LEGACY(fork, TT_ISOLATED),
 #endif
-#ifdef EVENT__HAVE_PTHREADS
-	/** TODO: support win32 */
-	LEGACY(del_wait, TT_ISOLATED|TT_NEED_THREADS),
+
+#ifdef EVTHREAD_USE_PTHREADS_IMPLEMENTED
+	LEGACY(del_wait, TT_ISOLATED|TT_NEED_THREADS|TT_RETRIABLE),
+	LEGACY(del_notify, TT_ISOLATED|TT_NEED_THREADS),
 #endif
 
 	END_OF_TESTCASES
diff --git a/ipc/chromium/src/third_party/libevent/test/regress.h b/ipc/chromium/src/third_party/libevent/test/regress.h
index de1aed30895b..43cb4eaf1e69 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress.h
+++ b/ipc/chromium/src/third_party/libevent/test/regress.h
@@ -43,6 +43,7 @@ extern struct testcase_t bufferevent_iocp_testcases[];
 extern struct testcase_t util_testcases[];
 extern struct testcase_t signal_testcases[];
 extern struct testcase_t http_testcases[];
+extern struct testcase_t http_iocp_testcases[];
 extern struct testcase_t dns_testcases[];
 extern struct testcase_t rpc_testcases[];
 extern struct testcase_t edgetriggered_testcases[];
@@ -94,6 +95,7 @@ extern int libevent_tests_running_in_debug_mode;
 #define TT_NO_LOGS		(TT_FIRST_USER_FLAG<<5)
 #define TT_ENABLE_IOCP_FLAG	(TT_FIRST_USER_FLAG<<6)
 #define TT_ENABLE_IOCP		(TT_ENABLE_IOCP_FLAG|TT_NEED_THREADS)
+#define TT_ENABLE_DEBUG_MODE	(TT_ENABLE_IOCP_FLAG<<7)
 
 /* All the flags that a legacy test needs. */
 #define TT_ISOLATED TT_FORK|TT_NEED_SOCKETPAIR|TT_NEED_BASE
@@ -132,11 +134,14 @@ pid_t regress_fork(void);
 #ifdef EVENT__HAVE_OPENSSL
 #include <openssl/ssl.h>
 EVP_PKEY *ssl_getkey(void);
-X509 *ssl_getcert(void);
+X509 *ssl_getcert(EVP_PKEY *key);
 SSL_CTX *get_ssl_ctx(void);
 void init_ssl(void);
 #endif
 
+void * basic_test_setup(const struct testcase_t *testcase);
+int    basic_test_cleanup(const struct testcase_t *testcase, void *ptr);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_buffer.c b/ipc/chromium/src/third_party/libevent/test/regress_buffer.c
index 1af75f537118..f259b924bff0 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_buffer.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_buffer.c
@@ -63,6 +63,8 @@
 
 #include "regress.h"
 
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
 /* Validates that an evbuffer is good. Returns false if it isn't, true if it
  * is*/
 static int
@@ -294,33 +296,39 @@ no_cleanup(const void *data, size_t datalen, void *extra)
 static void
 test_evbuffer_remove_buffer_with_empty(void *ptr)
 {
-    struct evbuffer *src = evbuffer_new();
-    struct evbuffer *dst = evbuffer_new();
-    char buf[2];
+	struct evbuffer *src = evbuffer_new();
+	struct evbuffer *dst = evbuffer_new();
+	char buf[2] = { 'A', 'A' };
+
+	evbuffer_validate(src);
+	evbuffer_validate(dst);
 
-    evbuffer_validate(src);
-    evbuffer_validate(dst);
+	/* setup the buffers */
+	/* we need more data in src than we will move later */
+	evbuffer_add_reference(src, buf, sizeof(buf), no_cleanup, NULL);
+	evbuffer_add_reference(src, buf, sizeof(buf), no_cleanup, NULL);
+	/* we need one buffer in dst and one empty buffer at the end */
+	evbuffer_add(dst, buf, sizeof(buf));
+	evbuffer_add_reference(dst, buf, 0, no_cleanup, NULL);
 
-    /* setup the buffers */
-    /* we need more data in src than we will move later */
-    evbuffer_add_reference(src, buf, sizeof(buf), no_cleanup, NULL);
-    evbuffer_add_reference(src, buf, sizeof(buf), no_cleanup, NULL);
-    /* we need one buffer in dst and one empty buffer at the end */
-    evbuffer_add(dst, buf, sizeof(buf));
-    evbuffer_add_reference(dst, buf, 0, no_cleanup, NULL);
+	evbuffer_validate(src);
+	evbuffer_validate(dst);
+
+	tt_mem_op(evbuffer_pullup(src, -1), ==, "AAAA", 4);
+	tt_mem_op(evbuffer_pullup(dst, -1), ==, "AA", 2);
 
-    evbuffer_validate(src);
-    evbuffer_validate(dst);
+	/* move three bytes over */
+	evbuffer_remove_buffer(src, dst, 3);
 
-    /* move three bytes over */
-    evbuffer_remove_buffer(src, dst, 3);
+	evbuffer_validate(src);
+	evbuffer_validate(dst);
 
-    evbuffer_validate(src);
-    evbuffer_validate(dst);
+	tt_mem_op(evbuffer_pullup(src, -1), ==, "A", 1);
+	tt_mem_op(evbuffer_pullup(dst, -1), ==, "AAAAA", 5);
 
-end:
-    evbuffer_free(src);
-    evbuffer_free(dst);
+ end:
+	evbuffer_free(src);
+	evbuffer_free(dst);
 }
 
 static void
@@ -350,6 +358,9 @@ test_evbuffer_remove_buffer_with_empty2(void *ptr)
 	evbuffer_validate(src);
 	evbuffer_validate(dst);
 
+	tt_mem_op(evbuffer_pullup(src, -1), ==, "foofoofoo", 9);
+	tt_mem_op(evbuffer_pullup(dst, -1), ==, "foofoofoo", 9);
+
 	evbuffer_remove_buffer(src, dst, 8);
 
 	evbuffer_validate(src);
@@ -358,6 +369,9 @@ test_evbuffer_remove_buffer_with_empty2(void *ptr)
 	tt_int_op(evbuffer_get_length(src), ==, 1);
 	tt_int_op(evbuffer_get_length(dst), ==, 17);
 
+	tt_mem_op(evbuffer_pullup(src, -1), ==, "o", 1);
+	tt_mem_op(evbuffer_pullup(dst, -1), ==, "foofoofoofoofoofo", 17);
+
  end:
 	evbuffer_free(src);
 	evbuffer_free(dst);
@@ -391,6 +405,9 @@ test_evbuffer_remove_buffer_with_empty3(void *ptr)
 	evbuffer_validate(src);
 	evbuffer_validate(dst);
 
+	tt_mem_op(evbuffer_pullup(src, -1), ==, "foofoo", 6);
+	tt_mem_op(evbuffer_pullup(dst, -1), ==, "foofoo", 6);
+
 	evbuffer_remove_buffer(src, dst, 5);
 
 	evbuffer_validate(src);
@@ -399,12 +416,128 @@ test_evbuffer_remove_buffer_with_empty3(void *ptr)
 	tt_int_op(evbuffer_get_length(src), ==, 1);
 	tt_int_op(evbuffer_get_length(dst), ==, 11);
 
+	tt_mem_op(evbuffer_pullup(src, -1), ==, "o", 1);
+	tt_mem_op(evbuffer_pullup(dst, -1), ==, "foofoofoofo", 11);
+
  end:
 	evbuffer_free(src);
 	evbuffer_free(dst);
 	evbuffer_free(buf);
 }
 
+static void
+test_evbuffer_pullup_with_empty(void *ptr)
+{
+	struct evbuffer *buf = NULL;
+
+	buf = evbuffer_new();
+	evbuffer_add(buf, "foo", 3);
+	evbuffer_add_reference(buf, NULL, 0, NULL, NULL);
+	evbuffer_validate(buf);
+	tt_int_op(evbuffer_get_length(buf), ==, 3);
+	tt_mem_op(evbuffer_pullup(buf, -1), ==, "foo", 3);
+
+	evbuffer_free(buf);
+	buf = evbuffer_new();
+	evbuffer_validate(buf);
+	tt_int_op(evbuffer_get_length(buf), ==, 0);
+	tt_int_op(evbuffer_pullup(buf, -1), ==, NULL);
+
+	evbuffer_free(buf);
+	buf = evbuffer_new();
+	evbuffer_add(buf, "foo", 3);
+	evbuffer_add_reference(buf, NULL, 0, NULL, NULL);
+	evbuffer_validate(buf);
+	tt_mem_op(evbuffer_pullup(buf, 3), ==, "foo", 3);
+
+ end:
+	if (buf)
+		evbuffer_free(buf);
+}
+
+static void
+test_evbuffer_remove_buffer_with_empty_front(void *ptr)
+{
+	struct evbuffer *buf1 = NULL, *buf2 = NULL;
+
+	buf1 = evbuffer_new();
+	tt_assert(buf1);
+
+	buf2 = evbuffer_new();
+	tt_assert(buf2);
+
+	tt_int_op(evbuffer_add_reference(buf1, "foo", 3, NULL, NULL), ==, 0);
+	tt_int_op(evbuffer_prepend(buf1, "", 0), ==, 0);
+	tt_int_op(evbuffer_remove_buffer(buf1, buf2, 1), ==, 1);
+	tt_int_op(evbuffer_add(buf1, "bar", 3), ==, 0);
+	tt_mem_op(evbuffer_pullup(buf1, -1), ==, "oobar", 5);
+
+	evbuffer_validate(buf1);
+	evbuffer_validate(buf2);
+
+ end:
+	if (buf1)
+		evbuffer_free(buf1);
+	if (buf2)
+		evbuffer_free(buf2);
+}
+
+static void
+test_evbuffer_remove_buffer_adjust_last_with_datap_with_empty(void *ptr)
+{
+	struct evbuffer *buf1 = NULL, *buf2 = NULL;
+
+	buf1 = evbuffer_new();
+	tt_assert(buf1);
+
+	buf2 = evbuffer_new();
+	tt_assert(buf2);
+
+	tt_int_op(evbuffer_add(buf1, "aaaaaa", 6), ==, 0);
+
+	// buf1: aaaaaab
+	// buf2:
+	{
+		struct evbuffer_iovec iovecs[2];
+		/** we want two chains, to leave one chain empty */
+		tt_int_op(evbuffer_reserve_space(buf1, 971, iovecs, 2), ==, 2);
+		tt_int_op(iovecs[0].iov_len, >=, 1);
+		tt_int_op(iovecs[1].iov_len, >=, 1);
+		tt_assert(*(char *)(iovecs[0].iov_base) = 'b');
+		tt_assert(iovecs[0].iov_len = 1);
+		tt_int_op(evbuffer_commit_space(buf1, iovecs, 1), ==, 0);
+	}
+
+	// buf1: aaaaaab
+	// buf2: dddcc
+	tt_int_op(evbuffer_add(buf2, "cc", 2), ==, 0);
+	tt_int_op(evbuffer_prepend(buf2, "ddd", 3), ==, 0);
+
+	// buf1:
+	// buf2: aaaaaabdddcc
+	tt_int_op(evbuffer_prepend_buffer(buf2, buf1), ==, 0);
+
+	// buf1: aaaaaabdddcc
+	// buf2:
+	tt_int_op(evbuffer_add_buffer(buf1, buf2), ==, 0);
+
+	// buf1: c
+	// buf2: aaaaaabdddc
+	tt_int_op(evbuffer_remove_buffer(buf1, buf2, 11), ==, 11);
+
+	// This fails today, we observe "aaaaaabcddd" instead!
+	tt_mem_op(evbuffer_pullup(buf2, -1), ==, "aaaaaabdddc", 11);
+
+	evbuffer_validate(buf1);
+	evbuffer_validate(buf2);
+
+ end:
+	if (buf1)
+		evbuffer_free(buf1);
+	if (buf2)
+		evbuffer_free(buf2);
+}
+
 static void
 test_evbuffer_add_buffer_with_empty(void *ptr)
 {
@@ -634,6 +767,63 @@ end:
 	evbuffer_free(buf);
 }
 
+static void
+test_evbuffer_reserve_with_empty(void *ptr)
+{
+	struct evbuffer *buf;
+	struct evbuffer_iovec v[2];
+
+	tt_assert(buf = evbuffer_new());
+	evbuffer_add(buf, "a", 1);
+	tt_int_op(evbuffer_reserve_space(buf, 1<<12, v, 2), ==, 2);
+	v[0].iov_len = 1;
+	*(char *)v[0].iov_base = 'b';
+	tt_int_op(evbuffer_commit_space(buf, v, 1), ==, 0);
+	evbuffer_add(buf, "c", 1);
+	tt_mem_op(evbuffer_pullup(buf, -1), ==, "abc", 2);
+
+	evbuffer_validate(buf);
+
+ end:
+	if (buf)
+		evbuffer_free(buf);
+}
+
+/* regression for evbuffer_expand_fast_() with invalid last_with_datap that has
+ * been left after evbuffer_prepend() with empty chain in it */
+static void
+test_evbuffer_reserve_invalid_last_with_datap(void *ptr)
+{
+	struct evbuffer *buf = NULL;
+	struct evbuffer_iovec vec[2];
+	const int nvec = ARRAY_SIZE(vec);
+	int i, avec;
+
+	buf = evbuffer_new();
+	tt_assert(buf);
+
+	/* prepend with an empty chain */
+	evbuffer_add_reference(buf, "", 0, NULL, NULL);
+	evbuffer_prepend(buf, "foo", 3);
+	/* after invalid last_with_datap will create new chain */
+	evbuffer_add(buf, "", 0);
+	/* we need to create at least 2 "used" (in evbuffer_expand_fast_()) chains */
+	tt_int_op(avec = evbuffer_reserve_space(buf, 1<<12, vec, nvec), >=, 1);
+	for (i = 0; i < avec; ++i)
+		vec[i].iov_len = 0;
+	tt_int_op(evbuffer_commit_space(buf, vec, avec), ==, 0);
+
+	/* and an actual problem, that triggers an assert(chain == buf->first) in
+	 * evbuffer_expand_fast_() */
+	tt_int_op(evbuffer_reserve_space(buf, 1<<13, vec, nvec), >=, 1);
+
+	evbuffer_validate(buf);
+
+end:
+	if (buf)
+		evbuffer_free(buf);
+}
+
 static void
 test_evbuffer_expand(void *ptr)
 {
@@ -1796,12 +1986,12 @@ test_evbuffer_callbacks(void *ptr)
 	tt_assert(cb1 != NULL);
 	cb2 = evbuffer_add_cb(buf, log_change_callback, buf_out2);
 	tt_assert(cb2 != NULL);
-	evbuffer_setcb(buf, self_draining_callback, NULL);
+	tt_int_op(evbuffer_setcb(buf, self_draining_callback, NULL), ==, 0);
 	evbuffer_add_printf(buf, "This should get drained right away.");
 	tt_uint_op(evbuffer_get_length(buf), ==, 0);
 	tt_uint_op(evbuffer_get_length(buf_out1), ==, 0);
 	tt_uint_op(evbuffer_get_length(buf_out2), ==, 0);
-	evbuffer_setcb(buf, NULL, NULL);
+	tt_int_op(evbuffer_setcb(buf, NULL, NULL), ==, 0);
 	evbuffer_add_printf(buf, "This will not.");
 	tt_str_op((const char *) evbuffer_pullup(buf, -1), ==, "This will not.");
 	evbuffer_validate(buf);
@@ -1827,6 +2017,14 @@ test_evbuffer_callbacks(void *ptr)
 		  "0->15; 15->11; 11->0; ");
 #endif
 
+	/* the next call to readline should fail */
+#ifndef EVENT__DISABLE_MM_REPLACEMENT
+	event_set_mem_functions(failing_malloc, realloc, free);
+	tt_int_op(evbuffer_setcb(buf, self_draining_callback, NULL), ==, -1);
+	evbuffer_validate(buf);
+	event_set_mem_functions(malloc, realloc, free);
+#endif
+
  end:
 	if (buf)
 		evbuffer_free(buf);
@@ -2117,6 +2315,58 @@ end:
 
 }
 
+static void
+test_evbuffer_empty_reference_prepend(void *ptr)
+{
+	struct evbuffer *buf = NULL;
+
+	buf = evbuffer_new();
+	tt_assert(buf);
+
+	/** empty chain could leave invalid last_with_datap */
+	evbuffer_add_reference(buf, "", 0, NULL, NULL);
+	evbuffer_validate(buf);
+	evbuffer_prepend(buf, "foo", 3);
+
+	evbuffer_validate(buf);
+	tt_assert(!strncmp((char *)evbuffer_pullup(buf, -1), "foo", 3));
+	evbuffer_validate(buf);
+
+end:
+	if (buf)
+		evbuffer_free(buf);
+}
+static void
+test_evbuffer_empty_reference_prepend_buffer(void *ptr)
+{
+	struct evbuffer *buf1 = NULL, *buf2 = NULL;
+
+	buf1 = evbuffer_new();
+	tt_assert(buf1);
+	buf2 = evbuffer_new();
+	tt_assert(buf2);
+
+	/** empty chain could leave invalid last_with_datap */
+	evbuffer_add_reference(buf1, "", 0, NULL, NULL);
+	evbuffer_validate(buf1);
+	evbuffer_add(buf2, "foo", 3);
+	evbuffer_validate(buf2);
+	evbuffer_prepend_buffer(buf2, buf1);
+	evbuffer_validate(buf2);
+
+	tt_assert(!strncmp((char *)evbuffer_pullup(buf2, -1), "foo", 3));
+	evbuffer_validate(buf2);
+
+	tt_assert(evbuffer_pullup(buf1, -1) == NULL);
+	evbuffer_validate(buf2);
+
+end:
+	if (buf1)
+		evbuffer_free(buf1);
+	if (buf2)
+		evbuffer_free(buf2);
+}
+
 static void
 test_evbuffer_peek_first_gt(void *info)
 {
@@ -2274,28 +2524,37 @@ end:
 static void
 test_evbuffer_freeze(void *ptr)
 {
-	struct evbuffer *buf = NULL, *tmp_buf=NULL;
+	struct basic_test_data *testdata = ptr;
+	evutil_socket_t *pair = testdata->pair;
+	struct evbuffer *buf = NULL, *buf_two = NULL, *tmp_buf = NULL;
 	const char string[] = /* Year's End, Richard Wilbur */
 	    "I've known the wind by water banks to shake\n"
 	    "The late leaves down, which frozen where they fell\n"
 	    "And held in ice as dancers in a spell\n"
 	    "Fluttered all winter long into a lake...";
-	const int start = !strcmp(ptr, "start");
+	const int start = !strcmp(testdata->setup_data, "start");
+	const char tmpfilecontent[] = "file_freeze_test_file";
 	char *cp;
 	char charbuf[128];
+	char *tmpfilename = NULL;
+	int fd = -1;
 	int r;
-	size_t orig_length;
+	size_t orig_length, len;
 	struct evbuffer_iovec v[1];
 
 	if (!start)
-		tt_str_op(ptr, ==, "end");
+		tt_str_op(testdata->setup_data, ==, "end");
 
 	buf = evbuffer_new();
+	buf_two = evbuffer_new();
 	tmp_buf = evbuffer_new();
 	tt_assert(tmp_buf);
 
 	evbuffer_add(buf, string, strlen(string));
+	evbuffer_add(buf_two, "abc", 3);
+	evbuffer_add(tmp_buf, "xyz", 3);
 	evbuffer_freeze(buf, start); /* Freeze the start or the end.*/
+	evbuffer_freeze(buf_two, start);
 
 #define FREEZE_EQ(a, startcase, endcase)		\
 	do {						\
@@ -2324,7 +2583,22 @@ test_evbuffer_freeze(void *ptr)
 	FREEZE_EQ(r, 0, -1);
 	r = evbuffer_add_printf(buf, "Hello %s", "world");
 	FREEZE_EQ(r, 11, -1);
-	/* TODO: test add_buffer, add_file, read */
+
+	r = evbuffer_add_buffer(buf, tmp_buf);
+	FREEZE_EQ(r, 0, -1);
+	len = strlen(tmpfilecontent);
+	fd = regress_make_tmpfile(tmpfilecontent, len, &tmpfilename);
+	r = evbuffer_add_file(buf, fd, 0, len);
+	FREEZE_EQ(r, 0, -1);
+
+	if (start)
+		evbuffer_add(tmp_buf, "xyz", 3);
+
+	tt_assert(evbuffer_get_length(tmp_buf));
+	len = evbuffer_get_length(tmp_buf);
+	evbuffer_write(tmp_buf, pair[0]);
+	r = evbuffer_read(buf, pair[1], -1);
+	FREEZE_EQ(r, len, -1);
 
 	if (!start)
 		tt_int_op(orig_length, ==, evbuffer_get_length(buf));
@@ -2342,7 +2616,24 @@ test_evbuffer_freeze(void *ptr)
 	FREEZE_EQ(cp==NULL, 1, 0);
 	if (cp)
 		free(cp);
-	/* TODO: Test remove_buffer, add_buffer, write, prepend_buffer */
+
+	evbuffer_add(tmp_buf, "xyz", 3);
+	tt_assert(evbuffer_get_length(tmp_buf));
+	r = evbuffer_remove_buffer(buf, tmp_buf, 3);
+	FREEZE_EQ(r, -1, 3);
+	r = evbuffer_drain(buf, 3);
+	FREEZE_EQ(r, -1, 0);
+	r = evbuffer_prepend_buffer(buf, tmp_buf);
+	FREEZE_EQ(r, -1, 0);
+
+	len = evbuffer_get_length(buf);
+	r = evbuffer_write(buf, pair[0]);
+	evbuffer_read(tmp_buf, pair[1], -1);
+	FREEZE_EQ(r, -1, len);
+	len = evbuffer_get_length(buf_two);
+	r = evbuffer_write_atmost(buf_two, pair[0], -1);
+	evbuffer_read(tmp_buf, pair[1], -1);
+	FREEZE_EQ(r, -1, len);
 
 	if (start)
 		tt_int_op(orig_length, ==, evbuffer_get_length(buf));
@@ -2351,8 +2642,16 @@ end:
 	if (buf)
 		evbuffer_free(buf);
 
+	if (buf_two)
+		evbuffer_free(buf_two);
+
 	if (tmp_buf)
 		evbuffer_free(tmp_buf);
+
+	if (tmpfilename) {
+		unlink(tmpfilename);
+		free(tmpfilename);
+	}
 }
 
 static void
@@ -2504,12 +2803,17 @@ struct testcase_t evbuffer_testcases[] = {
 	{ "remove_buffer_with_empty", test_evbuffer_remove_buffer_with_empty, 0, NULL, NULL },
 	{ "remove_buffer_with_empty2", test_evbuffer_remove_buffer_with_empty2, 0, NULL, NULL },
 	{ "remove_buffer_with_empty3", test_evbuffer_remove_buffer_with_empty3, 0, NULL, NULL },
+	{ "remove_buffer_with_empty_front", test_evbuffer_remove_buffer_with_empty_front, 0, NULL, NULL },
+	{ "remove_buffer_adjust_last_with_datap_with_empty",
+	  test_evbuffer_remove_buffer_adjust_last_with_datap_with_empty, 0, NULL, NULL },
 	{ "add_buffer_with_empty", test_evbuffer_add_buffer_with_empty, 0, NULL, NULL },
 	{ "add_buffer_with_empty2", test_evbuffer_add_buffer_with_empty2, 0, NULL, NULL },
 	{ "reserve2", test_evbuffer_reserve2, 0, NULL, NULL },
 	{ "reserve_many", test_evbuffer_reserve_many, 0, NULL, NULL },
 	{ "reserve_many2", test_evbuffer_reserve_many, 0, &nil_setup, (void*)"add" },
 	{ "reserve_many3", test_evbuffer_reserve_many, 0, &nil_setup, (void*)"fill" },
+	{ "reserve_with_empty", test_evbuffer_reserve_with_empty, 0, NULL, NULL },
+	{ "reserve_invalid_last_with_datap", test_evbuffer_reserve_invalid_last_with_datap, TT_FORK, NULL, NULL },
 	{ "expand", test_evbuffer_expand, 0, NULL, NULL },
 	{ "expand_overflow", test_evbuffer_expand_overflow, 0, NULL, NULL },
 	{ "add1", test_evbuffer_add1, 0, NULL, NULL },
@@ -2527,13 +2831,16 @@ struct testcase_t evbuffer_testcases[] = {
 	{ "multicast", test_evbuffer_multicast, 0, NULL, NULL },
 	{ "multicast_drain", test_evbuffer_multicast_drain, 0, NULL, NULL },
 	{ "prepend", test_evbuffer_prepend, TT_FORK, NULL, NULL },
+	{ "empty_reference_prepend", test_evbuffer_empty_reference_prepend, TT_FORK, NULL, NULL },
+	{ "empty_reference_prepend_buffer", test_evbuffer_empty_reference_prepend_buffer, TT_FORK, NULL, NULL },
 	{ "peek", test_evbuffer_peek, 0, NULL, NULL },
 	{ "peek_first_gt", test_evbuffer_peek_first_gt, 0, NULL, NULL },
-	{ "freeze_start", test_evbuffer_freeze, 0, &nil_setup, (void*)"start" },
-	{ "freeze_end", test_evbuffer_freeze, 0, &nil_setup, (void*)"end" },
+	{ "freeze_start", test_evbuffer_freeze, TT_NEED_SOCKETPAIR, &basic_setup, (void*)"start" },
+	{ "freeze_end", test_evbuffer_freeze, TT_NEED_SOCKETPAIR, &basic_setup, (void*)"end" },
 	{ "add_iovec", test_evbuffer_add_iovec, 0, NULL, NULL},
 	{ "copyout", test_evbuffer_copyout, 0, NULL, NULL},
 	{ "file_segment_add_cleanup_cb", test_evbuffer_file_segment_add_cleanup_cb, 0, NULL, NULL },
+	{ "pullup_with_empty", test_evbuffer_pullup_with_empty, 0, NULL, NULL },
 
 #define ADDFILE_TEST(name, parameters)					\
 	{ name, test_evbuffer_add_file, TT_FORK|TT_NEED_BASE,		\
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_bufferevent.c b/ipc/chromium/src/third_party/libevent/test/regress_bufferevent.c
index 249985e99a19..c276a0e5d1c3 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_bufferevent.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_bufferevent.c
@@ -29,6 +29,19 @@
 /* The old tests here need assertions to work. */
 #undef NDEBUG
 
+/**
+ * - clang supports __has_feature
+ * - gcc supports __SANITIZE_ADDRESS__
+ *
+ * Let's set __SANITIZE_ADDRESS__ if __has_feature(address_sanitizer)
+ */
+#ifndef __has_feature
+#define __has_feature(x) 0
+#endif
+#if !defined(__SANITIZE_ADDRESS__) && __has_feature(address_sanitizer)
+#define __SANITIZE_ADDRESS__
+#endif
+
 #ifdef _WIN32
 #include <winsock2.h>
 #include <windows.h>
@@ -137,14 +150,14 @@ test_bufferevent_impl(int use_pair, int flush)
 		bev2 = pair[1];
 		bufferevent_setcb(bev1, readcb, writecb, errorcb, bev1);
 		bufferevent_setcb(bev2, readcb, writecb, errorcb, NULL);
-		tt_int_op(bufferevent_getfd(bev1), ==, -1);
+		tt_fd_op(bufferevent_getfd(bev1), ==, EVUTIL_INVALID_SOCKET);
 		tt_ptr_op(bufferevent_get_underlying(bev1), ==, NULL);
 		tt_ptr_op(bufferevent_pair_get_partner(bev1), ==, bev2);
 		tt_ptr_op(bufferevent_pair_get_partner(bev2), ==, bev1);
 	} else {
 		bev1 = bufferevent_new(pair[0], readcb, writecb, errorcb, NULL);
 		bev2 = bufferevent_new(pair[1], readcb, writecb, errorcb, NULL);
-		tt_int_op(bufferevent_getfd(bev1), ==, pair[0]);
+		tt_fd_op(bufferevent_getfd(bev1), ==, pair[0]);
 		tt_ptr_op(bufferevent_get_underlying(bev1), ==, NULL);
 		tt_ptr_op(bufferevent_pair_get_partner(bev1), ==, NULL);
 		tt_ptr_op(bufferevent_pair_get_partner(bev2), ==, NULL);
@@ -203,7 +216,7 @@ static void test_bufferevent_pair_flush_normal(void) { test_bufferevent_impl(1,
 static void test_bufferevent_pair_flush_flush(void) { test_bufferevent_impl(1, BEV_FLUSH); }
 static void test_bufferevent_pair_flush_finished(void) { test_bufferevent_impl(1, BEV_FINISHED); }
 
-#if defined(EVTHREAD_USE_PTHREADS_IMPLEMENTED)
+#if defined(EVTHREAD_USE_PTHREADS_IMPLEMENTED) && !defined(__SANITIZE_ADDRESS__)
 /**
  * Trace lock/unlock/alloc/free for locks.
  * (More heavier then evthread_debug*)
@@ -569,8 +582,8 @@ test_bufferevent_filters_impl(int use_pair, int disable)
 
 	tt_ptr_op(bufferevent_get_underlying(bev1), ==, bev1_base);
 	tt_ptr_op(bufferevent_get_underlying(bev2), ==, bev2_base);
-	tt_int_op(bufferevent_getfd(bev1), ==, -1);
-	tt_int_op(bufferevent_getfd(bev2), ==, -1);
+	tt_fd_op(bufferevent_getfd(bev1), ==, bufferevent_getfd(bev1_base));
+	tt_fd_op(bufferevent_getfd(bev2), ==, bufferevent_getfd(bev2_base));
 
 	bufferevent_disable(bev1, EV_READ);
 	bufferevent_enable(bev2, EV_READ);
@@ -640,7 +653,7 @@ end:
 	;
 }
 
-static int
+static evutil_socket_t
 fake_listener_create(struct sockaddr_in *localhost)
 {
 	struct sockaddr *sa = (struct sockaddr *)localhost;
@@ -787,16 +800,29 @@ end:
 		bufferevent_free(bev2);
 }
 
+static void
+close_socket_cb(evutil_socket_t fd, short what, void *arg)
+{
+	evutil_socket_t *fdp = arg;
+	if (*fdp >= 0) {
+		evutil_closesocket(*fdp);
+		*fdp = -1;
+	}
+}
+
 static void
 test_bufferevent_connect_fail_eventcb(void *arg)
 {
 	struct basic_test_data *data = arg;
 	int flags = BEV_OPT_CLOSE_ON_FREE | (long)data->setup_data;
+	struct event close_listener_event;
 	struct bufferevent *bev = NULL;
 	struct evconnlistener *lev = NULL;
 	struct sockaddr_in localhost;
+	struct timeval close_timeout = { 0, 300000 };
 	ev_socklen_t slen = sizeof(localhost);
 	evutil_socket_t fake_listener = -1;
+	int r;
 
 	fake_listener = fake_listener_create(&localhost);
 
@@ -809,10 +835,22 @@ test_bufferevent_connect_fail_eventcb(void *arg)
 	bufferevent_enable(bev, EV_READ|EV_WRITE);
 	tt_int_op(n_events_invoked, ==, 0);
 	tt_int_op(n_reads_invoked, ==, 0);
+
 	/** @see also test_bufferevent_connect_fail() */
-	bufferevent_socket_connect(bev, (struct sockaddr *)&localhost, slen);
+	r = bufferevent_socket_connect(bev, (struct sockaddr *)&localhost, slen);
+	/* XXXX we'd like to test the '0' case everywhere, but FreeBSD tells
+	 * detects the error immediately, which is not really wrong of it. */
+	tt_want(r == 0 || r == -1);
+
 	tt_int_op(n_events_invoked, ==, 0);
 	tt_int_op(n_reads_invoked, ==, 0);
+
+	/* Close the listener socket after a delay. This should trigger
+	   "connection refused" on some other platforms, including OSX. */
+	evtimer_assign(&close_listener_event, data->base, close_socket_cb,
+	    &fake_listener);
+	event_add(&close_listener_event, &close_timeout);
+
 	event_base_dispatch(data->base);
 	tt_int_op(n_events_invoked, ==, 1);
 	tt_int_op(n_reads_invoked, ==, 0);
@@ -846,16 +884,6 @@ want_fail_eventcb(struct bufferevent *bev, short what, void *ctx)
 	event_base_loopexit(base, NULL);
 }
 
-static void
-close_socket_cb(evutil_socket_t fd, short what, void *arg)
-{
-	evutil_socket_t *fdp = arg;
-	if (*fdp >= 0) {
-		evutil_closesocket(*fdp);
-		*fdp = -1;
-	}
-}
-
 static void
 test_bufferevent_connect_fail(void *arg)
 {
@@ -863,7 +891,7 @@ test_bufferevent_connect_fail(void *arg)
 	struct bufferevent *bev=NULL;
 	struct event close_listener_event;
 	int close_listener_event_added = 0;
-	struct timeval one_second = { 1, 0 };
+	struct timeval close_timeout = { 0, 300000 };
 	struct sockaddr_in localhost;
 	ev_socklen_t slen = sizeof(localhost);
 	evutil_socket_t fake_listener = -1;
@@ -882,11 +910,11 @@ test_bufferevent_connect_fail(void *arg)
 	 * detects the error immediately, which is not really wrong of it. */
 	tt_want(r == 0 || r == -1);
 
-	/* Close the listener socket after a second. This should trigger
+	/* Close the listener socket after a delay. This should trigger
 	   "connection refused" on some other platforms, including OSX. */
 	evtimer_assign(&close_listener_event, data->base, close_socket_cb,
 	    &fake_listener);
-	event_add(&close_listener_event, &one_second);
+	event_add(&close_listener_event, &close_timeout);
 	close_listener_event_added = 1;
 
 	event_base_dispatch(data->base);
@@ -908,18 +936,24 @@ struct timeout_cb_result {
 	struct timeval read_timeout_at;
 	struct timeval write_timeout_at;
 	struct timeval last_wrote_at;
+	struct timeval last_read_at;
 	int n_read_timeouts;
 	int n_write_timeouts;
 	int total_calls;
 };
 
+static void
+bev_timeout_read_cb(struct bufferevent *bev, void *arg)
+{
+	struct timeout_cb_result *res = arg;
+	evutil_gettimeofday(&res->last_read_at, NULL);
+}
 static void
 bev_timeout_write_cb(struct bufferevent *bev, void *arg)
 {
 	struct timeout_cb_result *res = arg;
 	evutil_gettimeofday(&res->last_wrote_at, NULL);
 }
-
 static void
 bev_timeout_event_cb(struct bufferevent *bev, short what, void *arg)
 {
@@ -947,7 +981,6 @@ test_bufferevent_timeouts(void *arg)
 	int use_pair = 0, use_filter = 0;
 	struct timeval tv_w, tv_r, started_at;
 	struct timeout_cb_result res1, res2;
-	char buf[1024];
 
 	memset(&res1, 0, sizeof(res1));
 	memset(&res2, 0, sizeof(res2));
@@ -966,7 +999,6 @@ test_bufferevent_timeouts(void *arg)
 		bev1 = bufferevent_socket_new(data->base, data->pair[0], 0);
 		bev2 = bufferevent_socket_new(data->base, data->pair[1], 0);
 	}
-
 	tt_assert(bev1);
 	tt_assert(bev2);
 
@@ -990,30 +1022,14 @@ test_bufferevent_timeouts(void *arg)
 	tv_w.tv_sec = tv_r.tv_sec = 0;
 	tv_w.tv_usec = 100*1000;
 	tv_r.tv_usec = 150*1000;
-	bufferevent_setcb(bev1, NULL, bev_timeout_write_cb,
+	bufferevent_setcb(bev1, bev_timeout_read_cb, bev_timeout_write_cb,
 	    bev_timeout_event_cb, &res1);
-	bufferevent_setwatermark(bev1, EV_WRITE, 1024*1024+10, 0);
 	bufferevent_set_timeouts(bev1, &tv_r, &tv_w);
-	if (use_pair) {
-		/* For a pair, the fact that the other side isn't reading
-		 * makes the writer stall */
-		bufferevent_write(bev1, "ABCDEFG", 7);
-	} else {
-		/* For a real socket, the kernel's TCP buffers can eat a
-		 * fair number of bytes; make sure that at some point we
-		 * have some bytes that will stall. */
-		struct evbuffer *output = bufferevent_get_output(bev1);
-		int i;
-		memset(buf, 0xbb, sizeof(buf));
-		for (i=0;i<1024;++i) {
-			evbuffer_add_reference(output, buf, sizeof(buf),
-			    NULL, NULL);
-		}
-	}
+	bufferevent_write(bev1, "ABCDEFG", 7);
 	bufferevent_enable(bev1, EV_READ|EV_WRITE);
 
 	/* bev2 has nothing to say, and isn't listening. */
-	bufferevent_setcb(bev2, NULL,  bev_timeout_write_cb,
+	bufferevent_setcb(bev2, bev_timeout_read_cb, bev_timeout_write_cb,
 	    bev_timeout_event_cb, &res2);
 	tv_w.tv_sec = tv_r.tv_sec = 0;
 	tv_w.tv_usec = 200*1000;
@@ -1030,15 +1046,26 @@ test_bufferevent_timeouts(void *arg)
 	/* XXXX Test that actually reading or writing a little resets the
 	 * timeouts. */
 
-	/* Each buf1 timeout happens, and happens only once. */
-	tt_want(res1.n_read_timeouts);
-	tt_want(res1.n_write_timeouts);
+	tt_want(res1.total_calls == 2);
 	tt_want(res1.n_read_timeouts == 1);
 	tt_want(res1.n_write_timeouts == 1);
+	tt_want(res2.total_calls == !(use_pair && !use_filter));
+	tt_want(res2.n_write_timeouts == !(use_pair && !use_filter));
+	tt_want(!res2.n_read_timeouts);
 
 	test_timeval_diff_eq(&started_at, &res1.read_timeout_at, 150);
 	test_timeval_diff_eq(&started_at, &res1.write_timeout_at, 100);
 
+#define tt_assert_timeval_empty(tv) do {  \
+	tt_int_op((tv).tv_sec, ==, 0);   \
+	tt_int_op((tv).tv_usec, ==, 0);  \
+} while(0)
+	tt_assert_timeval_empty(res1.last_read_at);
+	tt_assert_timeval_empty(res2.last_read_at);
+	tt_assert_timeval_empty(res2.last_wrote_at);
+	tt_assert_timeval_empty(res2.last_wrote_at);
+#undef tt_assert_timeval_empty
+
 end:
 	if (bev1)
 		bufferevent_free(bev1);
@@ -1337,9 +1364,9 @@ struct testcase_t bufferevent_testcases[] = {
 	LEGACY(bufferevent_pair_flush_normal, TT_ISOLATED),
 	LEGACY(bufferevent_pair_flush_flush, TT_ISOLATED),
 	LEGACY(bufferevent_pair_flush_finished, TT_ISOLATED),
-#if defined(EVTHREAD_USE_PTHREADS_IMPLEMENTED)
+#if defined(EVTHREAD_USE_PTHREADS_IMPLEMENTED) && !defined(__SANITIZE_ADDRESS__)
 	{ "bufferevent_pair_release_lock", test_bufferevent_pair_release_lock,
-	  TT_FORK|TT_ISOLATED|TT_NEED_THREADS|TT_NEED_BASE|TT_LEGACY,
+	  TT_FORK|TT_ISOLATED|TT_NEED_THREADS|TT_NEED_BASE|TT_LEGACY|TT_NO_LOGS,
 	  &basic_setup, NULL },
 #endif
 	LEGACY(bufferevent_watermarks, TT_ISOLATED),
@@ -1363,7 +1390,7 @@ struct testcase_t bufferevent_testcases[] = {
 	{ "bufferevent_connect_fail", test_bufferevent_connect_fail,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
 	{ "bufferevent_timeout", test_bufferevent_timeouts,
-	  TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR, &basic_setup, (void*)"" },
+	  TT_FORK|TT_NEED_BASE, &basic_setup, (void*)"" },
 	{ "bufferevent_timeout_pair", test_bufferevent_timeouts,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, (void*)"pair" },
 	{ "bufferevent_timeout_filter", test_bufferevent_timeouts,
@@ -1406,38 +1433,35 @@ struct testcase_t bufferevent_testcases[] = {
 	END_OF_TESTCASES,
 };
 
+#define TT_IOCP (TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP)
+#define TT_IOCP_LEGACY (TT_ISOLATED|TT_ENABLE_IOCP)
 struct testcase_t bufferevent_iocp_testcases[] = {
-
-	LEGACY(bufferevent, TT_ISOLATED|TT_ENABLE_IOCP),
+	LEGACY(bufferevent, TT_IOCP_LEGACY),
 	LEGACY(bufferevent_flush_normal, TT_ISOLATED),
 	LEGACY(bufferevent_flush_flush, TT_ISOLATED),
 	LEGACY(bufferevent_flush_finished, TT_ISOLATED),
-	LEGACY(bufferevent_watermarks, TT_ISOLATED|TT_ENABLE_IOCP),
-	LEGACY(bufferevent_filters, TT_ISOLATED|TT_ENABLE_IOCP),
-	LEGACY(bufferevent_filters_disable, TT_ISOLATED|TT_ENABLE_IOCP),
+	LEGACY(bufferevent_watermarks, TT_IOCP_LEGACY),
+	LEGACY(bufferevent_filters, TT_IOCP_LEGACY),
+	LEGACY(bufferevent_filters_disable, TT_IOCP_LEGACY),
+
 	{ "bufferevent_connect", test_bufferevent_connect,
-	  TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup, (void*)"" },
+	  TT_IOCP, &basic_setup, (void*)"" },
 	{ "bufferevent_connect_defer", test_bufferevent_connect,
-	  TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup, (void*)"defer" },
+	  TT_IOCP, &basic_setup, (void*)"defer" },
 	{ "bufferevent_connect_lock", test_bufferevent_connect,
-	  TT_FORK|TT_NEED_BASE|TT_NEED_THREADS|TT_ENABLE_IOCP, &basic_setup,
-	  (void*)"lock" },
+	  TT_IOCP, &basic_setup, (void*)"lock" },
 	{ "bufferevent_connect_lock_defer", test_bufferevent_connect,
-	  TT_FORK|TT_NEED_BASE|TT_NEED_THREADS|TT_ENABLE_IOCP, &basic_setup,
-	  (void*)"defer lock" },
+	  TT_IOCP, &basic_setup, (void*)"defer lock" },
 	{ "bufferevent_connect_fail", test_bufferevent_connect_fail,
-	  TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup, NULL },
+	  TT_IOCP, &basic_setup, NULL },
 	{ "bufferevent_connect_nonblocking", test_bufferevent_connect,
-	  TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup,
-	  (void*)"unset_connectex" },
+	  TT_IOCP, &basic_setup, (void*)"unset_connectex" },
 
 	{ "bufferevent_connect_fail_eventcb_defer",
 	  test_bufferevent_connect_fail_eventcb,
-	  TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup,
-	  (void*)BEV_OPT_DEFER_CALLBACKS },
+	  TT_IOCP, &basic_setup, (void*)BEV_OPT_DEFER_CALLBACKS },
 	{ "bufferevent_connect_fail_eventcb",
-	  test_bufferevent_connect_fail_eventcb,
-	  TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup, NULL },
+	  test_bufferevent_connect_fail_eventcb, TT_IOCP, &basic_setup, NULL },
 
 	END_OF_TESTCASES,
 };
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_dns.c b/ipc/chromium/src/third_party/libevent/test/regress_dns.c
index 8950440f9731..9a8bff4f1526 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_dns.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_dns.c
@@ -59,6 +59,10 @@
 #include <string.h>
 #include <errno.h>
 
+#ifdef EVENT__HAVE_SYS_RESOURCE_H
+#include <sys/resource.h>
+#endif
+
 #include "event2/dns.h"
 #include "event2/dns_compat.h"
 #include "event2/dns_struct.h"
@@ -68,9 +72,12 @@
 #include "event2/util.h"
 #include "event2/listener.h"
 #include "event2/bufferevent.h"
+#include <event2/thread.h>
 #include "log-internal.h"
+#include "evthread-internal.h"
 #include "regress.h"
 #include "regress_testutils.h"
+#include "regress_thread.h"
 
 #define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
 
@@ -197,7 +204,7 @@ dns_resolve_reverse(void *ptr)
 {
 	struct in_addr in;
 	struct event_base *base = event_base_new();
-	struct evdns_base *dns = evdns_base_new(base, 1/* init name servers */);
+	struct evdns_base *dns = evdns_base_new(base, EVDNS_BASE_INITIALIZE_NAMESERVERS);
 	struct evdns_request *req = NULL;
 
 	tt_assert(base);
@@ -612,16 +619,8 @@ end:
 	if (dns)
 		evdns_base_free(dns, 0);
 }
-static void
-dns_search_test(void *arg)
-{
-	return dns_search_test_impl(arg, 0);
-}
-static void
-dns_search_lower_test(void *arg)
-{
-	return dns_search_test_impl(arg, 1);
-}
+static void dns_search_test(void *arg) { dns_search_test_impl(arg, 0); }
+static void dns_search_lower_test(void *arg) { dns_search_test_impl(arg, 1); }
 
 static int request_count = 0;
 static struct evdns_request *current_req = NULL;
@@ -1005,6 +1004,59 @@ end:
 		event_base_free(inactive_base);
 }
 
+static void
+dns_initialize_nameservers_test(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+	struct evdns_base *dns = NULL;
+
+	dns = evdns_base_new(base, 0);
+	tt_assert(dns);
+	tt_int_op(evdns_base_get_nameserver_addr(dns, 0, NULL, 0), ==, -1);
+	evdns_base_free(dns, 0);
+
+	dns = evdns_base_new(base, EVDNS_BASE_INITIALIZE_NAMESERVERS);
+	tt_assert(dns);
+	tt_int_op(evdns_base_get_nameserver_addr(dns, 0, NULL, 0), ==, sizeof(struct sockaddr));
+
+end:
+	if (dns)
+		evdns_base_free(dns, 0);
+}
+#ifndef _WIN32
+#define RESOLV_FILE "empty-resolv.conf"
+static void
+dns_nameservers_no_default_test(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+	struct evdns_base *dns = NULL;
+	int ok = access(RESOLV_FILE, R_OK);
+
+	tt_assert(ok);
+
+	dns = evdns_base_new(base, 0);
+	tt_assert(dns);
+	tt_int_op(evdns_base_get_nameserver_addr(dns, 0, NULL, 0), ==, -1);
+
+	/* We cannot test
+	 * EVDNS_BASE_INITIALIZE_NAMESERVERS|EVDNS_BASE_NAMESERVERS_NO_DEFAULT
+	 * because we cannot mock "/etc/resolv.conf" (yet). */
+
+	evdns_base_resolv_conf_parse(dns,
+		DNS_OPTIONS_ALL|DNS_OPTION_NAMESERVERS_NO_DEFAULT, RESOLV_FILE);
+	tt_int_op(evdns_base_get_nameserver_addr(dns, 0, NULL, 0), ==, -1);
+
+	evdns_base_resolv_conf_parse(dns, DNS_OPTIONS_ALL, RESOLV_FILE);
+	tt_int_op(evdns_base_get_nameserver_addr(dns, 0, NULL, 0), ==, sizeof(struct sockaddr));
+
+end:
+	if (dns)
+		evdns_base_free(dns, 0);
+}
+#endif
+
 /* === Test for bufferevent_socket_connect_hostname */
 
 static int total_connected_or_failed = 0;
@@ -1021,7 +1073,7 @@ be_getaddrinfo_server_cb(struct evdns_server_request *req, void *data)
 	int added_any=0;
 	++*n_got_p;
 
-	for (i=0;i<req->nquestions;++i) {
+	for (i = 0; i < req->nquestions; ++i) {
 		const int qtype = req->questions[i]->type;
 		const int qclass = req->questions[i]->dns_question_class;
 		const char *qname = req->questions[i]->name;
@@ -1165,27 +1217,36 @@ static void
 be_connect_hostname_event_cb(struct bufferevent *bev, short what, void *ctx)
 {
 	struct be_conn_hostname_result *got = ctx;
-	if (!got->what) {
-		TT_BLATHER(("Got a bufferevent event %d", what));
-		got->what = what;
-
-		if ((what & BEV_EVENT_CONNECTED) || (what & BEV_EVENT_ERROR)) {
-			int r;
-			if ((r = bufferevent_socket_get_dns_error(bev))) {
-				got->dnserr = r;
-				TT_BLATHER(("DNS error %d: %s", r,
-					   evutil_gai_strerror(r)));
-			}			++total_connected_or_failed;
-			TT_BLATHER(("Got %d connections or errors.", total_connected_or_failed));
-
-			if (total_n_accepted >= 3 && total_connected_or_failed >= 5)
-				event_base_loopexit(be_connect_hostname_base,
-				    NULL);
-		}
-	} else {
+
+	if (got->what) {
 		TT_FAIL(("Two events on one bufferevent. %d,%d",
 			got->what, (int)what));
 	}
+
+	TT_BLATHER(("Got a bufferevent event %d", what));
+	got->what = what;
+
+	if ((what & BEV_EVENT_CONNECTED) || (what & BEV_EVENT_ERROR)) {
+		int expected = 3;
+		int r = bufferevent_socket_get_dns_error(bev);
+
+		if (r) {
+			got->dnserr = r;
+			TT_BLATHER(("DNS error %d: %s", r,
+				   evutil_gai_strerror(r)));
+		}
+		++total_connected_or_failed;
+		TT_BLATHER(("Got %d connections or errors.", total_connected_or_failed));
+
+		/** emfile test */
+		if (errno == EMFILE) {
+			expected = 0;
+		}
+
+		if (total_n_accepted >= expected && total_connected_or_failed >= 5)
+			event_base_loopexit(be_connect_hostname_base,
+			    NULL);
+	}
 }
 
 static void
@@ -1193,10 +1254,9 @@ test_bufferevent_connect_hostname(void *arg)
 {
 	struct basic_test_data *data = arg;
 	struct evconnlistener *listener = NULL;
-	struct bufferevent *be1=NULL, *be2=NULL, *be3=NULL, *be4=NULL, *be5=NULL;
-	struct be_conn_hostname_result be1_outcome={0,0}, be2_outcome={0,0},
-	       be3_outcome={0,0}, be4_outcome={0,0}, be5_outcome={0,0};
-	int expect_err5;
+	struct bufferevent *be[5];
+	struct be_conn_hostname_result be_outcome[ARRAY_SIZE(be)];
+	int expect_err;
 	struct evdns_base *dns=NULL;
 	struct evdns_server_port *port=NULL;
 	struct sockaddr_in sin;
@@ -1204,6 +1264,9 @@ test_bufferevent_connect_hostname(void *arg)
 	ev_uint16_t dns_port=0;
 	int n_accept=0, n_dns=0;
 	char buf[128];
+	int emfile = data->setup_data && !strcmp(data->setup_data, "emfile");
+	unsigned i;
+	int ret;
 
 	be_connect_hostname_base = data->base;
 
@@ -1230,32 +1293,34 @@ test_bufferevent_connect_hostname(void *arg)
 	evutil_snprintf(buf, sizeof(buf), "127.0.0.1:%d", (int)dns_port);
 	evdns_base_nameserver_ip_add(dns, buf);
 
+#ifdef EVENT__HAVE_SETRLIMIT
+	if (emfile) {
+		int fd = socket(AF_INET, SOCK_STREAM, 0);
+		struct rlimit file = { fd, fd };
+
+		tt_int_op(fd, >=, 0);
+		tt_assert(!close(fd));
+
+		tt_assert(!setrlimit(RLIMIT_NOFILE, &file));
+	}
+#endif
+
 	/* Now, finally, at long last, launch the bufferevents.	 One should do
 	 * a failing lookup IP, one should do a successful lookup by IP,
 	 * and one should do a successful lookup by hostname. */
-	be1 = bufferevent_socket_new(data->base, -1, BEV_OPT_CLOSE_ON_FREE);
-	be2 = bufferevent_socket_new(data->base, -1, BEV_OPT_CLOSE_ON_FREE);
-	be3 = bufferevent_socket_new(data->base, -1, BEV_OPT_CLOSE_ON_FREE);
-	be4 = bufferevent_socket_new(data->base, -1, BEV_OPT_CLOSE_ON_FREE);
-	be5 = bufferevent_socket_new(data->base, -1, BEV_OPT_CLOSE_ON_FREE);
-
-	bufferevent_setcb(be1, NULL, NULL, be_connect_hostname_event_cb,
-	    &be1_outcome);
-	bufferevent_setcb(be2, NULL, NULL, be_connect_hostname_event_cb,
-	    &be2_outcome);
-	bufferevent_setcb(be3, NULL, NULL, be_connect_hostname_event_cb,
-	    &be3_outcome);
-	bufferevent_setcb(be4, NULL, NULL, be_connect_hostname_event_cb,
-	    &be4_outcome);
-	bufferevent_setcb(be5, NULL, NULL, be_connect_hostname_event_cb,
-	    &be5_outcome);
+	for (i = 0; i < ARRAY_SIZE(be); ++i) {
+		memset(&be_outcome[i], 0, sizeof(be_outcome[i]));
+		be[i] = bufferevent_socket_new(data->base, -1, BEV_OPT_CLOSE_ON_FREE);
+		bufferevent_setcb(be[i], NULL, NULL, be_connect_hostname_event_cb,
+			&be_outcome[i]);
+	}
 
 	/* Use the blocking resolver.  This one will fail if your resolver
 	 * can't resolve localhost to 127.0.0.1 */
-	tt_assert(!bufferevent_socket_connect_hostname(be4, NULL, AF_INET,
+	tt_assert(!bufferevent_socket_connect_hostname(be[3], NULL, AF_INET,
 		"localhost", listener_port));
 	/* Use the blocking resolver with a nonexistent hostname. */
-	tt_assert(!bufferevent_socket_connect_hostname(be5, NULL, AF_INET,
+	tt_assert(!bufferevent_socket_connect_hostname(be[4], NULL, AF_INET,
 		"nonesuch.nowhere.example.com", 80));
 	{
 		/* The blocking resolver will use the system nameserver, which
@@ -1266,35 +1331,53 @@ test_bufferevent_connect_hostname(void *arg)
 		hints.ai_family = AF_INET;
 		hints.ai_socktype = SOCK_STREAM;
 		hints.ai_protocol = IPPROTO_TCP;
-		expect_err5 = evutil_getaddrinfo(
+		expect_err = evutil_getaddrinfo(
 			"nonesuch.nowhere.example.com", "80", &hints, &ai);
 	}
 	/* Launch an async resolve that will fail. */
-	tt_assert(!bufferevent_socket_connect_hostname(be1, dns, AF_INET,
+	tt_assert(!bufferevent_socket_connect_hostname(be[0], dns, AF_INET,
 		"nosuchplace.example.com", listener_port));
 	/* Connect to the IP without resolving. */
-	tt_assert(!bufferevent_socket_connect_hostname(be2, dns, AF_INET,
+	tt_assert(!bufferevent_socket_connect_hostname(be[1], dns, AF_INET,
 		"127.0.0.1", listener_port));
 	/* Launch an async resolve that will succeed. */
-	tt_assert(!bufferevent_socket_connect_hostname(be3, dns, AF_INET,
+	tt_assert(!bufferevent_socket_connect_hostname(be[2], dns, AF_INET,
 		"nobodaddy.example.com", listener_port));
 
-	event_base_dispatch(data->base);
+	ret = event_base_dispatch(data->base);
+#ifdef __sun__
+	if (emfile && !strcmp(event_base_get_method(data->base), "devpoll")) {
+		tt_int_op(ret, ==, -1);
+		/** DP_POLL failed */
+		tt_skip();
+	} else
+#endif
+	{
+		tt_int_op(ret, ==, 0);
+	}
 
-	tt_int_op(be1_outcome.what, ==, BEV_EVENT_ERROR);
-	tt_int_op(be1_outcome.dnserr, ==, EVUTIL_EAI_NONAME);
-	tt_int_op(be2_outcome.what, ==, BEV_EVENT_CONNECTED);
-	tt_int_op(be2_outcome.dnserr, ==, 0);
-	tt_int_op(be3_outcome.what, ==, BEV_EVENT_CONNECTED);
-	tt_int_op(be3_outcome.dnserr, ==, 0);
-	tt_int_op(be4_outcome.what, ==, BEV_EVENT_CONNECTED);
-	tt_int_op(be4_outcome.dnserr, ==, 0);
-	if (expect_err5) {
-		tt_int_op(be5_outcome.what, ==, BEV_EVENT_ERROR);
-		tt_int_op(be5_outcome.dnserr, ==, expect_err5);
+	tt_int_op(be_outcome[0].what, ==, BEV_EVENT_ERROR);
+	tt_int_op(be_outcome[0].dnserr, ==, EVUTIL_EAI_NONAME);
+	tt_int_op(be_outcome[1].what, ==, !emfile ? BEV_EVENT_CONNECTED : BEV_EVENT_ERROR);
+	tt_int_op(be_outcome[1].dnserr, ==, 0);
+	tt_int_op(be_outcome[2].what, ==, !emfile ? BEV_EVENT_CONNECTED : BEV_EVENT_ERROR);
+	tt_int_op(be_outcome[2].dnserr, ==, 0);
+	tt_int_op(be_outcome[3].what, ==, !emfile ? BEV_EVENT_CONNECTED : BEV_EVENT_ERROR);
+	if (!emfile) {
+		tt_int_op(be_outcome[3].dnserr, ==, 0);
+	} else {
+		tt_int_op(be_outcome[3].dnserr, !=, 0);
+	}
+	if (expect_err) {
+		tt_int_op(be_outcome[4].what, ==, BEV_EVENT_ERROR);
+		tt_int_op(be_outcome[4].dnserr, ==, expect_err);
 	}
 
-	tt_int_op(n_accept, ==, 3);
+	if (emfile) {
+		tt_int_op(n_accept, ==, 0);
+	} else {
+		tt_int_op(n_accept, ==, 3);
+	}
 	tt_int_op(n_dns, ==, 2);
 
 end:
@@ -1304,16 +1387,10 @@ end:
 		evdns_close_server_port(port);
 	if (dns)
 		evdns_base_free(dns, 0);
-	if (be1)
-		bufferevent_free(be1);
-	if (be2)
-		bufferevent_free(be2);
-	if (be3)
-		bufferevent_free(be3);
-	if (be4)
-		bufferevent_free(be4);
-	if (be5)
-		bufferevent_free(be5);
+	for (i = 0; i < ARRAY_SIZE(be); ++i) {
+		if (be[i])
+			bufferevent_free(be[i]);
+	}
 }
 
 
@@ -1352,7 +1429,7 @@ test_getaddrinfo_async(void *arg)
 	struct evutil_addrinfo hints, *a;
 	struct gai_outcome local_outcome;
 	struct gai_outcome a_out[12];
-	int i;
+	unsigned i;
 	struct evdns_getaddrinfo_request *r;
 	char buf[128];
 	struct evdns_server_port *port = NULL;
@@ -1710,7 +1787,7 @@ test_getaddrinfo_async(void *arg)
 end:
 	if (local_outcome.ai)
 		evutil_freeaddrinfo(local_outcome.ai);
-	for (i=0;i<(int)ARRAY_SIZE(a_out);++i) {
+	for (i = 0; i < ARRAY_SIZE(a_out); ++i) {
 		if (a_out[i].ai)
 			evutil_freeaddrinfo(a_out[i].ai);
 	}
@@ -1731,7 +1808,8 @@ struct gaic_request_status {
 
 #define GAIC_MAGIC 0x1234abcd
 
-static int pending = 0;
+static int gaic_pending = 0;
+static int gaic_freed = 0;
 
 static void
 gaic_cancel_request_cb(evutil_socket_t fd, short what, void *arg)
@@ -1776,7 +1854,13 @@ gaic_getaddrinfo_cb(int result, struct evutil_addrinfo *res, void *arg)
 	free(status);
 
 end:
-	if (--pending <= 0)
+	if (res)
+	{
+		TT_BLATHER(("evutil_freeaddrinfo(%p)", res));
+		evutil_freeaddrinfo(res);
+		++gaic_freed;
+	}
+	if (--gaic_pending <= 0)
 		event_base_loopexit(base, NULL);
 }
 
@@ -1794,7 +1878,7 @@ gaic_launch(struct event_base *base, struct evdns_base *dns_base)
 	    "foobar.bazquux.example.com", "80", NULL, gaic_getaddrinfo_cb,
 	    status);
 	event_add(&status->cancel_event, &tv);
-	++pending;
+	++gaic_pending;
 }
 
 #ifdef EVENT_SET_MEM_FUNCTIONS_IMPLEMENTED
@@ -1984,7 +2068,7 @@ test_getaddrinfo_async_cancel_stress(void *ptr)
 	struct sockaddr_in sin;
 	struct sockaddr_storage ss;
 	ev_socklen_t slen;
-	int i;
+	unsigned i;
 
 	base = event_base_new();
 	dns_base = evdns_base_new(base, 0);
@@ -2017,6 +2101,9 @@ test_getaddrinfo_async_cancel_stress(void *ptr)
 
 	event_base_dispatch(base);
 
+	// at least some was canceled via external event
+	tt_int_op(gaic_freed, !=, 1000);
+
 end:
 	if (dns_base)
 		evdns_base_free(dns_base, 1);
@@ -2033,13 +2120,14 @@ dns_client_fail_requests_test(void *arg)
 {
 	struct basic_test_data *data = arg;
 	struct event_base *base = data->base;
+	int limit_inflight = data->setup_data && !strcmp(data->setup_data, "limit-inflight");
 	struct evdns_base *dns = NULL;
 	struct evdns_server_port *dns_port = NULL;
 	ev_uint16_t portnum = 0;
 	char buf[64];
 
 	struct generic_dns_callback_result r[20];
-	int i;
+	unsigned i;
 
 	dns_port = regress_get_dnsserver(base, &portnum, NULL,
 		regress_dns_server_cb, reissue_table);
@@ -2050,6 +2138,9 @@ dns_client_fail_requests_test(void *arg)
 	dns = evdns_base_new(base, EVDNS_BASE_DISABLE_WHEN_INACTIVE);
 	tt_assert(!evdns_base_nameserver_ip_add(dns, buf));
 
+	if (limit_inflight)
+		tt_assert(!evdns_base_set_option(dns, "max-inflight:", "11"));
+
 	for (i = 0; i < 20; ++i)
 		evdns_base_resolve_ipv4(dns, "foof.example.com", 0, generic_dns_callback, &r[i]);
 
@@ -2096,7 +2187,7 @@ dns_client_fail_requests_getaddrinfo_test(void *arg)
 	tt_assert(!evdns_base_nameserver_ip_add(dns, buf));
 
 	for (i = 0; i < 20; ++i)
-		tt_assert(evdns_getaddrinfo(dns, "foof.example.com", "ssh", NULL, getaddrinfo_cb, &r[i]));
+		tt_assert(evdns_getaddrinfo(dns, "foof.example.com", "80", NULL, getaddrinfo_cb, &r[i]));
 
 	n_replies_left = 20;
 	exit_base = base;
@@ -2113,6 +2204,238 @@ end:
 	evdns_close_server_port(dns_port);
 }
 
+#ifdef EVTHREAD_USE_PTHREADS_IMPLEMENTED
+struct race_param
+{
+	void *lock;
+	void *reqs_cmpl_cond;
+	int bw_threads;
+	void *bw_threads_exited_cond;
+	volatile int stopping;
+	void *base;
+	void *dns;
+
+	int locked;
+};
+static void *
+race_base_run(void *arg)
+{
+	struct race_param *rp = (struct race_param *)arg;
+	event_base_loop(rp->base, EVLOOP_NO_EXIT_ON_EMPTY);
+	THREAD_RETURN();
+}
+static void *
+race_busywait_run(void *arg)
+{
+	struct race_param *rp = (struct race_param *)arg;
+	struct sockaddr_storage ss;
+	while (!rp->stopping)
+		evdns_base_get_nameserver_addr(rp->dns, 0, (struct sockaddr *)&ss, sizeof(ss));
+	EVLOCK_LOCK(rp->lock, 0);
+	if (--rp->bw_threads == 0)
+		EVTHREAD_COND_SIGNAL(rp->bw_threads_exited_cond);
+	EVLOCK_UNLOCK(rp->lock, 0);
+	THREAD_RETURN();
+}
+static void
+race_gai_cb(int result, struct evutil_addrinfo *res, void *arg)
+{
+	struct race_param *rp = arg;
+	(void)result;
+	(void)res;
+
+	--n_replies_left;
+	if (n_replies_left == 0) {
+		EVLOCK_LOCK(rp->lock, 0);
+		EVTHREAD_COND_SIGNAL(rp->reqs_cmpl_cond);
+		EVLOCK_UNLOCK(rp->lock, 0);
+	}
+}
+static void
+getaddrinfo_race_gotresolve_test(void *arg)
+{
+	struct race_param rp;
+	struct evdns_server_port *dns_port = NULL;
+	ev_uint16_t portnum = 0;
+	char buf[64];
+	int i;
+
+	// Some stress is needed to yield inside getaddrinfo between resolve_ipv4 and resolve_ipv6
+	int n_reqs = 16384;
+#ifdef _SC_NPROCESSORS_ONLN
+	int n_threads = sysconf(_SC_NPROCESSORS_ONLN) + 1;
+#else
+	int n_threads = 17;
+#endif
+	THREAD_T thread[n_threads];
+	struct timeval tv;
+
+	(void)arg;
+
+	evthread_use_pthreads();
+
+	rp.base = event_base_new();
+	tt_assert(rp.base);
+	if (evthread_make_base_notifiable(rp.base) < 0)
+		tt_abort_msg("Couldn't make base notifiable!");
+
+	dns_port = regress_get_dnsserver(rp.base, &portnum, NULL,
+									 regress_dns_server_cb, reissue_table);
+	tt_assert(dns_port);
+
+	evutil_snprintf(buf, sizeof(buf), "127.0.0.1:%d", (int)portnum);
+
+	rp.dns = evdns_base_new(rp.base, 0);
+	tt_assert(!evdns_base_nameserver_ip_add(rp.dns, buf));
+
+	n_replies_left = n_reqs;
+
+	EVTHREAD_ALLOC_LOCK(rp.lock, 0);
+	EVTHREAD_ALLOC_COND(rp.reqs_cmpl_cond);
+	EVTHREAD_ALLOC_COND(rp.bw_threads_exited_cond);
+	tt_assert(rp.lock);
+	tt_assert(rp.reqs_cmpl_cond);
+	tt_assert(rp.bw_threads_exited_cond);
+	rp.bw_threads = 0;
+	rp.stopping = 0;
+
+	// Run resolver thread
+	THREAD_START(thread[0], race_base_run, &rp);
+	// Run busy-wait threads used to force yield this thread
+	for (i = 1; i < n_threads; i++) {
+		rp.bw_threads++;
+		THREAD_START(thread[i], race_busywait_run, &rp);
+	}
+
+	EVLOCK_LOCK(rp.lock, 0);
+	rp.locked = 1;
+
+	for (i = 0; i < n_reqs; ++i) {
+		tt_assert(evdns_getaddrinfo(rp.dns, "foof.example.com", "80", NULL, race_gai_cb, &rp));
+		// This magic along with busy-wait threads make this thread yield frequently
+		if (i % 100 == 0) {
+			tv.tv_sec = 0;
+			tv.tv_usec = 10000;
+			evutil_usleep_(&tv);
+		}
+	}
+
+	exit_base = rp.base;
+
+	// Wait for some time
+	tv.tv_sec = 5;
+	tv.tv_usec = 0;
+	EVTHREAD_COND_WAIT_TIMED(rp.reqs_cmpl_cond, rp.lock, &tv);
+
+	// Stop busy-wait threads
+	tv.tv_sec = 1;
+	tv.tv_usec = 0;
+	rp.stopping = 1;
+	tt_assert(EVTHREAD_COND_WAIT_TIMED(rp.bw_threads_exited_cond, rp.lock, &tv) == 0);
+
+	EVLOCK_UNLOCK(rp.lock, 0);
+	rp.locked = 0;
+
+	evdns_base_free(rp.dns, 1 /** fail requests */);
+
+	tt_int_op(n_replies_left, ==, 0);
+
+end:
+	if (rp.locked)
+		EVLOCK_UNLOCK(rp.lock, 0);
+	EVTHREAD_FREE_LOCK(rp.lock, 0);
+	EVTHREAD_FREE_COND(rp.reqs_cmpl_cond);
+	EVTHREAD_FREE_COND(rp.bw_threads_exited_cond);
+	evdns_close_server_port(dns_port);
+	event_base_loopbreak(rp.base);
+	event_base_free(rp.base);
+}
+#endif
+
+static void
+test_set_so_rcvbuf_so_sndbuf(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct evdns_base *dns_base;
+
+	dns_base = evdns_base_new(data->base, 0);
+	tt_assert(dns_base);
+
+	tt_assert(!evdns_base_set_option(dns_base, "so-rcvbuf", "10240"));
+	tt_assert(!evdns_base_set_option(dns_base, "so-sndbuf", "10240"));
+
+	/* actually check SO_RCVBUF/SO_SNDBUF not fails */
+	tt_assert(!evdns_base_nameserver_ip_add(dns_base, "127.0.0.1"));
+
+end:
+	if (dns_base)
+		evdns_base_free(dns_base, 0);
+}
+
+static void
+test_set_option(void *arg)
+{
+#define SUCCESS 0
+#define FAIL -1
+	struct basic_test_data *data = arg;
+	struct evdns_base *dns_base;
+	size_t i;
+	/* Option names are allowed to have ':' at the end.
+	 * So all test option names come in pairs.
+	 */
+	const char *int_options[] = {
+		"ndots", "ndots:",
+		"max-timeouts", "max-timeouts:",
+		"max-inflight", "max-inflight:",
+		"attempts", "attempts:",
+		"randomize-case", "randomize-case:",
+		"so-rcvbuf", "so-rcvbuf:",
+		"so-sndbuf", "so-sndbuf:",
+	};
+	const char *timeval_options[] = {
+		"timeout", "timeout:",
+		"getaddrinfo-allow-skew", "getaddrinfo-allow-skew:",
+		"initial-probe-timeout", "initial-probe-timeout:",
+	};
+	const char *addr_port_options[] = {
+		"bind-to", "bind-to:",
+	};
+
+	dns_base = evdns_base_new(data->base, 0);
+	tt_assert(dns_base);
+
+	for (i = 0; i < ARRAY_SIZE(int_options); ++i) {
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, int_options[i], "0"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, int_options[i], "1"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, int_options[i], "10000"));
+		tt_assert(FAIL == evdns_base_set_option(dns_base, int_options[i], "foo"));
+		tt_assert(FAIL == evdns_base_set_option(dns_base, int_options[i], "3.14"));
+	}
+
+	for (i = 0; i < ARRAY_SIZE(timeval_options); ++i) {
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, timeval_options[i], "1"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, timeval_options[i], "0.001"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, timeval_options[i], "3.14"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, timeval_options[i], "10000"));
+		tt_assert(FAIL == evdns_base_set_option(dns_base, timeval_options[i], "0"));
+		tt_assert(FAIL == evdns_base_set_option(dns_base, timeval_options[i], "foo"));
+	}
+
+	for (i = 0; i < ARRAY_SIZE(addr_port_options); ++i) {
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, addr_port_options[i], "8.8.8.8:80"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, addr_port_options[i], "1.2.3.4"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, addr_port_options[i], "::1:82"));
+		tt_assert(SUCCESS == evdns_base_set_option(dns_base, addr_port_options[i], "3::4"));
+		tt_assert(FAIL == evdns_base_set_option(dns_base, addr_port_options[i], "3.14"));
+		tt_assert(FAIL == evdns_base_set_option(dns_base, addr_port_options[i], "foo"));
+	}
+
+#undef SUCCESS
+#undef FAIL
+end:
+	if (dns_base)
+		evdns_base_free(dns_base, 0);
+}
 
 #define DNS_LEGACY(name, flags)					       \
 	{ #name, run_legacy_test_fn, flags|TT_LEGACY, &legacy_setup,   \
@@ -2138,10 +2461,21 @@ struct testcase_t dns_testcases[] = {
 	{ "inflight", dns_inflight_test, TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
 	{ "bufferevent_connect_hostname", test_bufferevent_connect_hostname,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+#ifdef EVENT__HAVE_SETRLIMIT
+	{ "bufferevent_connect_hostname_emfile", test_bufferevent_connect_hostname,
+	  TT_FORK|TT_NEED_BASE, &basic_setup, (char*)"emfile" },
+#endif
 	{ "disable_when_inactive", dns_disable_when_inactive_test,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
 	{ "disable_when_inactive_no_ns", dns_disable_when_inactive_no_ns_test,
+	  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, NULL },
+
+	{ "initialize_nameservers", dns_initialize_nameservers_test,
+	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+#ifndef _WIN32
+	{ "nameservers_no_default", dns_nameservers_no_default_test,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+#endif
 
 	{ "getaddrinfo_async", test_getaddrinfo_async,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, (char*)"" },
@@ -2162,9 +2496,21 @@ struct testcase_t dns_testcases[] = {
 #endif
 
 	{ "client_fail_requests", dns_client_fail_requests_test,
-	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+	  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, NULL },
+	{ "client_fail_waiting_requests", dns_client_fail_requests_test,
+	  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, (char*)"limit-inflight" },
 	{ "client_fail_requests_getaddrinfo",
 	  dns_client_fail_requests_getaddrinfo_test,
+	  TT_FORK|TT_NEED_BASE|TT_NO_LOGS, &basic_setup, NULL },
+#ifdef EVTHREAD_USE_PTHREADS_IMPLEMENTED
+	{ "getaddrinfo_race_gotresolve",
+	  getaddrinfo_race_gotresolve_test,
+	  TT_FORK|TT_OFF_BY_DEFAULT, NULL, NULL },
+#endif
+
+	{ "set_SO_RCVBUF_SO_SNDBUF", test_set_so_rcvbuf_so_sndbuf,
+	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+	{ "set_options", test_set_option,
 	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
 
 	END_OF_TESTCASES
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_et.c b/ipc/chromium/src/third_party/libevent/test/regress_et.c
index f75c59b3b7a7..1b1f819eda19 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_et.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_et.c
@@ -51,6 +51,14 @@
 
 static int was_et = 0;
 
+static int base_supports_et(struct event_base *base)
+{
+	return
+		(!strcmp(event_base_get_method(base), "epoll") ||
+		!strcmp(event_base_get_method(base), "epoll (with changelist)") ||
+		!strcmp(event_base_get_method(base), "kqueue"));
+}
+
 static void
 read_cb(evutil_socket_t fd, short event, void *arg)
 {
@@ -67,19 +75,14 @@ read_cb(evutil_socket_t fd, short event, void *arg)
 		event_del(arg);
 }
 
-#ifdef _WIN32
-#define LOCAL_SOCKETPAIR_AF AF_INET
-#else
-#define LOCAL_SOCKETPAIR_AF AF_UNIX
-#endif
-
 static void
-test_edgetriggered(void *et)
+test_edgetriggered(void *data_)
 {
+	struct basic_test_data *data = data_;
+	struct event_base *base = data->base;
+	evutil_socket_t *pair = data->pair;
 	struct event *ev = NULL;
-	struct event_base *base = NULL;
 	const char *test = "test string";
-	evutil_socket_t pair[2] = {-1,-1};
 	int supports_et;
 
 	/* On Linux 3.2.1 (at least, as patched by Fedora and tested by Nick),
@@ -88,39 +91,21 @@ test_edgetriggered(void *et)
 	 * get edge-triggered behavior.  Yuck!  Linux 3.1.9 didn't have this
 	 * problem.
 	 */
-#ifdef __linux__
-	if (evutil_ersatz_socketpair_(AF_INET, SOCK_STREAM, 0, pair) == -1) {
-		tt_abort_perror("socketpair");
-	}
-#else
-	if (evutil_socketpair(LOCAL_SOCKETPAIR_AF, SOCK_STREAM, 0, pair) == -1) {
-		tt_abort_perror("socketpair");
-	}
-#endif
 
 	called = was_et = 0;
 
 	tt_int_op(send(pair[0], test, (int)strlen(test)+1, 0), >, 0);
-	shutdown(pair[0], EVUTIL_SHUT_WR);
-
-	/* Initalize the event library */
-	base = event_base_new();
-
-	if (!strcmp(event_base_get_method(base), "epoll") ||
-	    !strcmp(event_base_get_method(base), "epoll (with changelist)") ||
-	    !strcmp(event_base_get_method(base), "kqueue"))
-		supports_et = 1;
-	else
-		supports_et = 0;
+	tt_int_op(shutdown(pair[0], EVUTIL_SHUT_WR), ==, 0);
 
+	supports_et = base_supports_et(base);
 	TT_BLATHER(("Checking for edge-triggered events with %s, which should %s"
 				"support edge-triggering", event_base_get_method(base),
 				supports_et?"":"not "));
 
-	/* Initalize one event */
+	/* Initialize one event */
 	ev = event_new(base, pair[1], EV_READ|EV_ET|EV_PERSIST, read_cb, &ev);
-
-	event_add(ev, NULL);
+	tt_assert(ev != NULL);
+	tt_int_op(event_add(ev, NULL), ==, 0);
 
 	/* We're going to call the dispatch function twice.  The first invocation
 	 * will read a single byte from pair[1] in either case.  If we're edge
@@ -129,8 +114,8 @@ test_edgetriggered(void *et)
 	 * do nothing.  If we're level triggered, the second invocation of
 	 * event_base_loop will also activate the event (because there's still
 	 * data to read). */
-	event_base_loop(base,EVLOOP_NONBLOCK|EVLOOP_ONCE);
-	event_base_loop(base,EVLOOP_NONBLOCK|EVLOOP_ONCE);
+	tt_int_op(event_base_loop(base,EVLOOP_NONBLOCK|EVLOOP_ONCE), ==, 0);
+	tt_int_op(event_base_loop(base,EVLOOP_NONBLOCK|EVLOOP_ONCE), ==, 0);
 
 	if (supports_et) {
 		tt_int_op(called, ==, 1);
@@ -140,15 +125,11 @@ test_edgetriggered(void *et)
 		tt_assert(!was_et);
 	}
 
- end:
+end:
 	if (ev) {
 		event_del(ev);
 		event_free(ev);
 	}
-	if (base)
-		event_base_free(base);
-	evutil_closesocket(pair[0]);
-	evutil_closesocket(pair[1]);
 }
 
 static void
@@ -196,9 +177,94 @@ end:
 		event_base_free(base);
 }
 
+static int read_notification_count;
+static int last_read_notification_was_et;
+static void
+read_notification_cb(evutil_socket_t fd, short event, void *arg)
+{
+	read_notification_count++;
+	last_read_notification_was_et = (event & EV_ET);
+}
+
+static int write_notification_count;
+static int last_write_notification_was_et;
+static void
+write_notification_cb(evutil_socket_t fd, short event, void *arg)
+{
+	write_notification_count++;
+	last_write_notification_was_et = (event & EV_ET);
+}
+
+/* After two or more events have been registered for the same
+ * file descriptor using EV_ET, if one of the events is
+ * deleted, then the epoll_ctl() call issued by libevent drops
+ * the EPOLLET flag resulting in level triggered
+ * notifications.
+ */
+static void
+test_edge_triggered_multiple_events(void *data_)
+{
+	struct basic_test_data *data = data_;
+	struct event *read_ev = NULL;
+	struct event *write_ev = NULL;
+	const char c = 'A';
+	struct event_base *base = data->base;
+	evutil_socket_t *pair = data->pair;
+
+	if (!base_supports_et(base)) {
+		tt_skip();
+		return;
+	}
+
+	read_notification_count = 0;
+	last_read_notification_was_et = 0;
+	write_notification_count = 0;
+	last_write_notification_was_et = 0;
+
+	/* Make pair[1] readable */
+	tt_int_op(send(pair[0], &c, 1, 0), >, 0);
+
+	read_ev = event_new(base, pair[1], EV_READ|EV_ET|EV_PERSIST,
+		read_notification_cb, NULL);
+	write_ev = event_new(base, pair[1], EV_WRITE|EV_ET|EV_PERSIST,
+		write_notification_cb, NULL);
+
+	event_add(read_ev, NULL);
+	event_add(write_ev, NULL);
+	event_base_loop(base, EVLOOP_NONBLOCK|EVLOOP_ONCE);
+	event_base_loop(base, EVLOOP_NONBLOCK|EVLOOP_ONCE);
+
+	tt_assert(last_read_notification_was_et);
+	tt_int_op(read_notification_count, ==, 1);
+	tt_assert(last_write_notification_was_et);
+	tt_int_op(write_notification_count, ==, 1);
+
+	event_del(read_ev);
+
+	/* trigger acitivity second time for the backend that can have multiple
+	 * events for one fd (like kqueue) */
+	close(pair[0]);
+	pair[0] = -1;
+
+	/* Verify that we are still edge-triggered for write notifications */
+	event_base_loop(base, EVLOOP_NONBLOCK|EVLOOP_ONCE);
+	event_base_loop(base, EVLOOP_NONBLOCK|EVLOOP_ONCE);
+	tt_assert(last_write_notification_was_et);
+	tt_int_op(write_notification_count, ==, 2);
+
+end:
+	if (read_ev)
+		event_free(read_ev);
+	if (write_ev)
+		event_free(write_ev);
+}
+
 struct testcase_t edgetriggered_testcases[] = {
-	{ "et", test_edgetriggered, TT_FORK, NULL, NULL },
+	{ "et", test_edgetriggered,
+	  TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR, &basic_setup, NULL },
 	{ "et_mix_error", test_edgetriggered_mix_error,
 	  TT_FORK|TT_NEED_SOCKETPAIR|TT_NO_LOGS, &basic_setup, NULL },
+	{ "et_multiple_events", test_edge_triggered_multiple_events,
+	  TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR, &basic_setup, NULL },
 	END_OF_TESTCASES
 };
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_finalize.c b/ipc/chromium/src/third_party/libevent/test/regress_finalize.c
index 552210fe9d01..9e57188121d1 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_finalize.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_finalize.c
@@ -290,6 +290,53 @@ end:
 	;
 }
 
+static void
+event_finalize_callback_free(struct event *ev, void *arg)
+{
+	struct event_base *base = arg;
+	int err;
+	if (base) {
+		err = event_assign(ev, base, -1, EV_TIMEOUT, NULL, NULL);
+		tt_int_op(err, ==, 0);
+		test_ok += 1;
+	} else {
+		free(ev);
+		test_ok += 1;
+	}
+
+end:
+	;
+}
+static void
+test_fin_debug_use_after_free(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+	struct event *ev;
+
+	tt_ptr_op(ev = event_new(base, -1, EV_TIMEOUT, NULL, base), !=, NULL);
+	tt_int_op(event_add(ev, NULL), ==, 0);
+	tt_int_op(event_finalize(0, ev, event_finalize_callback_free), ==, 0);
+
+	// Dispatch base to trigger callbacks
+	event_base_dispatch(base);
+	event_base_assert_ok_(base);
+	tt_int_op(test_ok, ==, 1);
+
+	// Now add again, since we did event_assign in event_finalize_callback_free
+	// This used to fail in event_debug_assert_is_setup_
+	tt_int_op(event_add(ev, NULL), ==, 0);
+
+	// Finalize and dispatch again
+	tt_int_op(event_finalize(0, ev, event_finalize_callback_free), ==, 0);
+	event_base_dispatch(base);
+	event_base_assert_ok_(base);
+	tt_int_op(test_ok, ==, 2);
+
+end:
+	;
+}
+
 #if 0
 static void
 timer_callback_3(evutil_socket_t *fd, short what, void *arg)
@@ -339,6 +386,7 @@ struct testcase_t finalize_testcases[] = {
 	TEST(cb_invoked, TT_FORK|TT_NEED_BASE),
 	TEST(free_finalize, TT_FORK),
 	TEST(within_cb, TT_FORK|TT_NEED_BASE),
+	TEST(debug_use_after_free, TT_FORK|TT_NEED_BASE|TT_ENABLE_DEBUG_MODE),
 //	TEST(many, TT_FORK|TT_NEED_BASE),
 
 
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_http.c b/ipc/chromium/src/third_party/libevent/test/regress_http.c
index 80100500e204..4493907163e2 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_http.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_http.c
@@ -66,12 +66,15 @@
 #include "regress.h"
 #include "regress_testutils.h"
 
+#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
+
 /* set if a test needs to call loopexit on a base */
 static struct event_base *exit_base;
 
 static char const BASIC_REQUEST_BODY[] = "This is funny";
 
 static void http_basic_cb(struct evhttp_request *req, void *arg);
+static void http_timeout_cb(struct evhttp_request *req, void *arg);
 static void http_large_cb(struct evhttp_request *req, void *arg);
 static void http_chunked_cb(struct evhttp_request *req, void *arg);
 static void http_post_cb(struct evhttp_request *req, void *arg);
@@ -119,7 +122,7 @@ https_bev(struct event_base *base, void *arg)
 {
 	SSL *ssl = SSL_new(get_ssl_ctx());
 
-	SSL_use_certificate(ssl, ssl_getcert());
+	SSL_use_certificate(ssl, ssl_getcert(ssl_getkey()));
 	SSL_use_PrivateKey(ssl, ssl_getkey());
 
 	return bufferevent_openssl_socket_new(
@@ -128,7 +131,8 @@ https_bev(struct event_base *base, void *arg)
 }
 #endif
 static struct evhttp *
-http_setup(ev_uint16_t *pport, struct event_base *base, int mask)
+http_setup_gencb(ev_uint16_t *pport, struct event_base *base, int mask,
+	void (*cb)(struct evhttp_request *, void *), void *cbarg)
 {
 	struct evhttp *myhttp;
 
@@ -144,8 +148,12 @@ http_setup(ev_uint16_t *pport, struct event_base *base, int mask)
 	}
 #endif
 
+	evhttp_set_gencb(myhttp, cb, cbarg);
+
 	/* Register a callback for certain types of requests */
 	evhttp_set_cb(myhttp, "/test", http_basic_cb, myhttp);
+	evhttp_set_cb(myhttp, "/test nonconformant", http_basic_cb, myhttp);
+	evhttp_set_cb(myhttp, "/timeout", http_timeout_cb, myhttp);
 	evhttp_set_cb(myhttp, "/large", http_large_cb, base);
 	evhttp_set_cb(myhttp, "/chunked", http_chunked_cb, base);
 	evhttp_set_cb(myhttp, "/streamed", http_chunked_cb, base);
@@ -159,6 +167,9 @@ http_setup(ev_uint16_t *pport, struct event_base *base, int mask)
 	evhttp_set_cb(myhttp, "/", http_dispatcher_cb, base);
 	return (myhttp);
 }
+static struct evhttp *
+http_setup(ev_uint16_t *pport, struct event_base *base, int mask)
+{ return http_setup_gencb(pport, base, mask, NULL, NULL); }
 
 #ifndef NI_MAXSERV
 #define NI_MAXSERV 1024
@@ -172,7 +183,7 @@ http_connect(const char *address, ev_uint16_t port)
 	char strport[NI_MAXSERV];
 
 	struct sockaddr *sa;
-	int slen;
+	size_t slen;
 	evutil_socket_t fd;
 
 	memset(&ai, 0, sizeof(ai));
@@ -221,6 +232,8 @@ evbuffer_datacmp(struct evbuffer *buf, const char *s)
 		return -1;
 
 	d = evbuffer_pullup(buf, s_sz);
+	if (!d)
+		d = (unsigned char *)"";
 	if ((r = memcmp(d, s, s_sz)))
 		return r;
 
@@ -306,12 +319,31 @@ http_basic_cb(struct evhttp_request *req, void *arg)
 	struct evbuffer *evb = evbuffer_new();
 	struct evhttp_connection *evcon;
 	int empty = evhttp_find_header(evhttp_request_get_input_headers(req), "Empty") != NULL;
-	event_debug(("%s: called\n", __func__));
+
+	TT_BLATHER(("%s: called\n", __func__));
 	evbuffer_add_printf(evb, BASIC_REQUEST_BODY);
 
 	evcon = evhttp_request_get_connection(req);
 	tt_assert(evhttp_connection_get_server(evcon) == arg);
 
+	{
+		const struct sockaddr *sa;
+		char addrbuf[128];
+
+		sa = evhttp_connection_get_addr(evcon);
+		tt_assert(sa);
+
+		if (sa->sa_family == AF_INET) {
+			evutil_format_sockaddr_port_((struct sockaddr *)sa, addrbuf, sizeof(addrbuf));
+			tt_assert(!strncmp(addrbuf, "127.0.0.1:", strlen("127.0.0.1:")));
+		} else if (sa->sa_family == AF_INET6) {
+			evutil_format_sockaddr_port_((struct sockaddr *)sa, addrbuf, sizeof(addrbuf));
+			tt_assert(!strncmp(addrbuf, "[::1]:", strlen("[::1]:")));
+		} else {
+			tt_fail_msg("Unsupported family");
+		}
+	}
+
 	/* For multi-line headers test */
 	{
 		const char *multi =
@@ -346,6 +378,20 @@ end:
 	evbuffer_free(evb);
 }
 
+static void http_timeout_reply_cb(evutil_socket_t fd, short events, void *arg)
+{
+	struct evhttp_request *req = arg;
+	evhttp_send_reply(req, HTTP_OK, "Everything is fine", NULL);
+	test_ok++;
+}
+static void
+http_timeout_cb(struct evhttp_request *req, void *arg)
+{
+	struct timeval when = { 0, 100 };
+	event_base_once(exit_base, -1, EV_TIMEOUT,
+	    http_timeout_reply_cb, req, &when);
+}
+
 static void
 http_large_cb(struct evhttp_request *req, void *arg)
 {
@@ -396,7 +442,7 @@ http_chunked_cb(struct evhttp_request *req, void *arg)
 {
 	struct timeval when = { 0, 0 };
 	struct chunk_req_state *state = malloc(sizeof(struct chunk_req_state));
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 
 	memset(state, 0, sizeof(struct chunk_req_state));
 	state->req = req;
@@ -414,20 +460,10 @@ http_chunked_cb(struct evhttp_request *req, void *arg)
 	event_base_once(arg, -1, EV_TIMEOUT, http_chunked_trickle_cb, state, &when);
 }
 
-static void
-http_complete_write(evutil_socket_t fd, short what, void *arg)
-{
-	struct bufferevent *bev = arg;
-	const char *http_request = "host\r\n"
-	    "Connection: close\r\n"
-	    "\r\n";
-	bufferevent_write(bev, http_request, strlen(http_request));
-}
-
 static struct bufferevent *
-create_bev(struct event_base *base, int fd, int ssl_mask)
+create_bev(struct event_base *base, evutil_socket_t fd, int ssl_mask, int flags_)
 {
-	int flags = BEV_OPT_DEFER_CALLBACKS;
+	int flags = BEV_OPT_DEFER_CALLBACKS | flags_;
 	struct bufferevent *bev = NULL;
 
 	if (!ssl_mask) {
@@ -452,19 +488,34 @@ create_bev(struct event_base *base, int fd, int ssl_mask)
 }
 
 static void
-http_basic_test_impl(void *arg, int ssl)
+http_half_writecb(struct bufferevent *bev, void *arg)
+{
+	if (evbuffer_get_length(bufferevent_get_output(bev)) == 0) {
+		if (!test_ok) {
+			const char http_request[] = "host\r\n"
+				"Connection: close\r\n"
+				"\r\n";
+			bufferevent_write(bev, http_request, strlen(http_request));
+		}
+		/* enable reading of the reply */
+		bufferevent_enable(bev, EV_READ);
+		test_ok++;
+	}
+}
+
+static void
+http_basic_test_impl(void *arg, int ssl, const char *request_line)
 {
 	struct basic_test_data *data = arg;
-	struct timeval tv;
 	struct bufferevent *bev = NULL;
 	evutil_socket_t fd;
 	const char *http_request;
 	ev_uint16_t port = 0, port2 = 0;
 	int server_flags = ssl ? HTTP_BIND_SSL : 0;
 	struct evhttp *http = http_setup(&port, data->base, server_flags);
+	struct evbuffer *out;
 
 	exit_base = data->base;
-	test_ok = 0;
 
 	/* bind to a second socket */
 	if (http_bind(http, &port2, server_flags) == -1) {
@@ -475,56 +526,48 @@ http_basic_test_impl(void *arg, int ssl)
 	fd = http_connect("127.0.0.1", port);
 
 	/* Stupid thing to send a request */
-	bev = create_bev(data->base, fd, ssl);
-	bufferevent_setcb(bev, http_readcb, http_writecb,
+	bev = create_bev(data->base, fd, ssl, BEV_OPT_CLOSE_ON_FREE);
+	bufferevent_setcb(bev, http_readcb, http_half_writecb,
 	    http_errorcb, data->base);
+	out = bufferevent_get_output(bev);
 
 	/* first half of the http request */
-	http_request =
-	    "GET /test HTTP/1.1\r\n"
-	    "Host: some";
-
-	bufferevent_write(bev, http_request, strlen(http_request));
-	evutil_timerclear(&tv);
-	tv.tv_usec = 100000;
-	event_base_once(data->base,
-	    -1, EV_TIMEOUT, http_complete_write, bev, &tv);
+	evbuffer_add_printf(out,
+	    "%s\r\n"
+	    "Host: some", request_line);
 
+	test_ok = 0;
 	event_base_dispatch(data->base);
-
-	tt_assert(test_ok == 3);
+	tt_int_op(test_ok, ==, 3);
 
 	/* connect to the second port */
 	bufferevent_free(bev);
-	evutil_closesocket(fd);
 
 	fd = http_connect("127.0.0.1", port2);
 
 	/* Stupid thing to send a request */
-	bev = create_bev(data->base, fd, ssl);
+	bev = create_bev(data->base, fd, ssl, BEV_OPT_CLOSE_ON_FREE);
 	bufferevent_setcb(bev, http_readcb, http_writecb,
 	    http_errorcb, data->base);
+	out = bufferevent_get_output(bev);
 
-	http_request =
-	    "GET /test HTTP/1.1\r\n"
+	evbuffer_add_printf(out,
+	    "%s\r\n"
 	    "Host: somehost\r\n"
 	    "Connection: close\r\n"
-	    "\r\n";
-
-	bufferevent_write(bev, http_request, strlen(http_request));
+	    "\r\n", request_line);
 
+	test_ok = 0;
 	event_base_dispatch(data->base);
-
-	tt_assert(test_ok == 5);
+	tt_int_op(test_ok, ==, 2);
 
 	/* Connect to the second port again. This time, send an absolute uri. */
 	bufferevent_free(bev);
-	evutil_closesocket(fd);
 
 	fd = http_connect("127.0.0.1", port2);
 
 	/* Stupid thing to send a request */
-	bev = create_bev(data->base, fd, ssl);
+	bev = create_bev(data->base, fd, ssl, BEV_OPT_CLOSE_ON_FREE);
 	bufferevent_setcb(bev, http_readcb, http_writecb,
 	    http_errorcb, data->base);
 
@@ -536,17 +579,19 @@ http_basic_test_impl(void *arg, int ssl)
 
 	bufferevent_write(bev, http_request, strlen(http_request));
 
+	test_ok = 0;
 	event_base_dispatch(data->base);
-
-	tt_assert(test_ok == 7);
+	tt_int_op(test_ok, ==, 2);
 
 	evhttp_free(http);
- end:
+end:
 	if (bev)
 		bufferevent_free(bev);
 }
-static void http_basic_test(void *arg)
-{ return http_basic_test_impl(arg, 0); }
+static void http_basic_test(void *arg)\
+{ http_basic_test_impl(arg, 0, "GET /test HTTP/1.1"); }
+static void http_basic_trailing_space_test(void *arg)
+{ http_basic_test_impl(arg, 0, "GET /test HTTP/1.1 "); }
 
 
 static void
@@ -585,7 +630,7 @@ http_badreq_cb(struct evhttp_request *req, void *arg)
 static void
 http_badreq_errorcb(struct bufferevent *bev, short what, void *arg)
 {
-	event_debug(("%s: called (what=%04x, arg=%p)", __func__, what, arg));
+	TT_BLATHER(("%s: called (what=%04x, arg=%p)", __func__, what, arg));
 	/* ignore */
 }
 
@@ -631,7 +676,7 @@ http_badreq_readcb(struct bufferevent *bev, void *arg)
 static void
 http_badreq_successcb(evutil_socket_t fd, short what, void *arg)
 {
-	event_debug(("%s: called (what=%04x, arg=%p)", __func__, what, arg));
+	TT_BLATHER(("%s: called (what=%04x, arg=%p)", __func__, what, arg));
 	event_base_loopexit(exit_base, NULL);
 }
 
@@ -641,7 +686,7 @@ http_bad_request_test(void *arg)
 	struct basic_test_data *data = arg;
 	struct timeval tv;
 	struct bufferevent *bev = NULL;
-	evutil_socket_t fd = -1;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 	const char *http_request;
 	ev_uint16_t port=0, port2=0;
 	struct evhttp *http = http_setup(&port, data->base, 0);
@@ -655,7 +700,7 @@ http_bad_request_test(void *arg)
 
 	/* NULL request test */
 	fd = http_connect("127.0.0.1", port);
-	tt_int_op(fd, >=, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -687,6 +732,7 @@ http_bad_request_test(void *arg)
 
 	/* connect to the second port */
 	fd = http_connect("127.0.0.1", port2);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -747,7 +793,7 @@ http_delete_cb(struct evhttp_request *req, void *arg)
 		exit(1);
 	}
 
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 	evbuffer_add_printf(evb, BASIC_REQUEST_BODY);
 
 	/* allow sending of an empty reply */
@@ -762,7 +808,7 @@ http_delete_test(void *arg)
 {
 	struct basic_test_data *data = arg;
 	struct bufferevent *bev;
-	evutil_socket_t fd = -1;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 	const char *http_request;
 	ev_uint16_t port = 0;
 	struct evhttp *http = http_setup(&port, data->base, 0);
@@ -772,7 +818,7 @@ http_delete_test(void *arg)
 
 	tt_assert(http);
 	fd = http_connect("127.0.0.1", port);
-	tt_int_op(fd, >=, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -791,7 +837,7 @@ http_delete_test(void *arg)
 
 	bufferevent_free(bev);
 	evutil_closesocket(fd);
-	fd = -1;
+	fd = EVUTIL_INVALID_SOCKET;
 
 	evhttp_free(http);
 
@@ -818,7 +864,7 @@ http_sent_cb(struct evhttp_request *req, void *arg)
 		exit(1);
 	}
 
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 
 	++test_ok;
 }
@@ -830,7 +876,7 @@ http_on_complete_cb(struct evhttp_request *req, void *arg)
 
 	evhttp_request_set_on_complete_cb(req, http_sent_cb, (void *)0xDEADBEEF);
 
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 	evbuffer_add_printf(evb, BASIC_REQUEST_BODY);
 
 	/* allow sending of an empty reply */
@@ -846,7 +892,7 @@ http_on_complete_test(void *arg)
 {
 	struct basic_test_data *data = arg;
 	struct bufferevent *bev;
-	evutil_socket_t fd = -1;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 	const char *http_request;
 	ev_uint16_t port = 0;
 	struct evhttp *http = http_setup(&port, data->base, 0);
@@ -855,7 +901,7 @@ http_on_complete_test(void *arg)
 	test_ok = 0;
 
 	fd = http_connect("127.0.0.1", port);
-	tt_int_op(fd, >=, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -916,7 +962,7 @@ http_allowed_methods_test(void *arg)
 	test_ok = 0;
 
 	fd1 = http_connect("127.0.0.1", port);
-	tt_int_op(fd1, >=, 0);
+	tt_assert(fd1 != EVUTIL_INVALID_SOCKET);
 
 	/* GET is out; PATCH is in. */
 	evhttp_set_allowed_methods(http, EVHTTP_REQ_PATCH);
@@ -938,7 +984,7 @@ http_allowed_methods_test(void *arg)
 	event_base_dispatch(data->base);
 
 	fd2 = http_connect("127.0.0.1", port);
-	tt_int_op(fd2, >=, 0);
+	tt_assert(fd2 != EVUTIL_INVALID_SOCKET);
 
 	bev2 = bufferevent_socket_new(data->base, fd2, 0);
 	bufferevent_enable(bev2, EV_READ|EV_WRITE);
@@ -956,7 +1002,7 @@ http_allowed_methods_test(void *arg)
 	event_base_dispatch(data->base);
 
 	fd3 = http_connect("127.0.0.1", port);
-	tt_int_op(fd3, >=, 0);
+	tt_assert(fd3 != EVUTIL_INVALID_SOCKET);
 
 	bev3 = bufferevent_socket_new(data->base, fd3, 0);
 	bufferevent_enable(bev3, EV_READ|EV_WRITE);
@@ -1239,6 +1285,7 @@ http_autofree_connection_test(void *arg)
 	struct evhttp_connection *evcon = NULL;
 	struct evhttp_request *req[2] = { NULL };
 	struct evhttp *http = http_setup(&port, data->base, 0);
+	size_t i;
 
 	test_ok = 0;
 
@@ -1253,19 +1300,14 @@ http_autofree_connection_test(void *arg)
 	req[1] = evhttp_request_new(http_request_empty_done, data->base);
 
 	/* Add the information that we care about */
-	evhttp_add_header(evhttp_request_get_output_headers(req[0]), "Host", "somehost");
-	evhttp_add_header(evhttp_request_get_output_headers(req[0]), "Connection", "close");
-	evhttp_add_header(evhttp_request_get_output_headers(req[0]), "Empty", "itis");
-	evhttp_add_header(evhttp_request_get_output_headers(req[1]), "Host", "somehost");
-	evhttp_add_header(evhttp_request_get_output_headers(req[1]), "Connection", "close");
-	evhttp_add_header(evhttp_request_get_output_headers(req[1]), "Empty", "itis");
+	for (i = 0; i < ARRAY_SIZE(req); ++i) {
+		evhttp_add_header(evhttp_request_get_output_headers(req[i]), "Host", "somehost");
+		evhttp_add_header(evhttp_request_get_output_headers(req[i]), "Connection", "close");
+		evhttp_add_header(evhttp_request_get_output_headers(req[i]), "Empty", "itis");
 
-	/* We give ownership of the request to the connection */
-	if (evhttp_make_request(evcon, req[0], EVHTTP_REQ_GET, "/test") == -1) {
-		tt_abort_msg("couldn't make request");
-	}
-	if (evhttp_make_request(evcon, req[1], EVHTTP_REQ_GET, "/test") == -1) {
-		tt_abort_msg("couldn't make request");
+		if (evhttp_make_request(evcon, req[i], EVHTTP_REQ_GET, "/test") == -1) {
+			tt_abort_msg("couldn't make request");
+		}
 	}
 
 	/*
@@ -1276,7 +1318,8 @@ http_autofree_connection_test(void *arg)
 	evhttp_connection_free_on_completion(evcon);
 	evcon = NULL;
 
-	event_base_dispatch(data->base);
+	for (i = 0; i < ARRAY_SIZE(req); ++i)
+		event_base_dispatch(data->base);
 
 	/* at this point, the http server should have no connection */
 	tt_assert(TAILQ_FIRST(&http->connections) == NULL);
@@ -1744,6 +1787,7 @@ http_virtual_host_test(void *arg)
 
 	/* Now make a raw request with an absolute URI. */
 	fd = http_connect("127.0.0.1", port);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -1825,7 +1869,7 @@ http_dispatcher_cb(struct evhttp_request *req, void *arg)
 {
 
 	struct evbuffer *evb = evbuffer_new();
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 	evbuffer_add_printf(evb, "DISPATCHER_TEST");
 
 	evhttp_send_reply(req, HTTP_OK, "Everything is fine", evb);
@@ -1983,7 +2027,7 @@ void
 http_post_cb(struct evhttp_request *req, void *arg)
 {
 	struct evbuffer *evb;
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 
 	/* Yes, we are expecting a post request */
 	if (evhttp_request_get_command(req) != EVHTTP_REQ_POST) {
@@ -2100,7 +2144,7 @@ void
 http_put_cb(struct evhttp_request *req, void *arg)
 {
 	struct evbuffer *evb;
-	event_debug(("%s: called\n", __func__));
+	TT_BLATHER(("%s: called\n", __func__));
 
 	/* Expecting a PUT request */
 	if (evhttp_request_get_command(req) != EVHTTP_REQ_PUT) {
@@ -2186,7 +2230,7 @@ http_failure_test(void *arg)
 {
 	struct basic_test_data *data = arg;
 	struct bufferevent *bev;
-	evutil_socket_t fd = -1;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 	const char *http_request;
 	ev_uint16_t port = 0;
 	struct evhttp *http = http_setup(&port, data->base, 0);
@@ -2194,7 +2238,7 @@ http_failure_test(void *arg)
 	test_ok = 0;
 
 	fd = http_connect("127.0.0.1", port);
-	tt_int_op(fd, >=, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -2450,6 +2494,27 @@ http_parse_query_test(void *ptr)
 	tt_want(validate_header(&headers, "q3", "") == 0);
 	evhttp_clear_headers(&headers);
 
+end:
+	evhttp_clear_headers(&headers);
+}
+static void
+http_parse_query_str_test(void *ptr)
+{
+	struct evkeyvalq headers;
+	int r;
+
+	TAILQ_INIT(&headers);
+
+	r = evhttp_parse_query_str("http://www.test.com/?q=test", &headers);
+	tt_assert(evhttp_find_header(&headers, "q") == NULL);
+	tt_int_op(r, ==, 0);
+	evhttp_clear_headers(&headers);
+
+	r = evhttp_parse_query_str("q=test", &headers);
+	tt_want(validate_header(&headers, "q", "test") == 0);
+	tt_int_op(r, ==, 0);
+	evhttp_clear_headers(&headers);
+
 end:
 	evhttp_clear_headers(&headers);
 }
@@ -2963,7 +3028,7 @@ http_base_test(void *ptr)
 	http = http_setup(&port, base, 0);
 
 	fd = http_connect("127.0.0.1", port);
-	tt_int_op(fd, >=, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(base, fd, 0);
@@ -3050,10 +3115,10 @@ http_incomplete_test_(struct basic_test_data *data, int use_timeout, int ssl)
 	evhttp_set_timeout(http, 1);
 
 	fd = http_connect("127.0.0.1", port);
-	tt_int_op(fd, >=, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
-	bev = create_bev(data->base, fd, ssl);
+	bev = create_bev(data->base, fd, ssl, 0);
 	bufferevent_setcb(bev,
 	    http_incomplete_readcb, http_incomplete_writecb,
 	    http_incomplete_errorcb, use_timeout ? NULL : &fd);
@@ -3074,7 +3139,7 @@ http_incomplete_test_(struct basic_test_data *data, int use_timeout, int ssl)
 	bufferevent_free(bev);
 	if (use_timeout) {
 		evutil_closesocket(fd);
-		fd = -1;
+		fd = EVUTIL_INVALID_SOCKET;
 	}
 
 	evhttp_free(http);
@@ -3253,7 +3318,7 @@ static void
 http_chunk_out_test_impl(void *arg, int ssl)
 {
 	struct basic_test_data *data = arg;
-	struct bufferevent *bev;
+	struct bufferevent *bev = NULL;
 	evutil_socket_t fd;
 	const char *http_request;
 	ev_uint16_t port = 0;
@@ -3267,9 +3332,10 @@ http_chunk_out_test_impl(void *arg, int ssl)
 	test_ok = 0;
 
 	fd = http_connect("127.0.0.1", port);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
-	bev = create_bev(data->base, fd, ssl);
+	bev = create_bev(data->base, fd, ssl, BEV_OPT_CLOSE_ON_FREE);
 	bufferevent_setcb(bev,
 	    http_chunked_readcb, http_chunked_writecb,
 	    http_chunked_errorcb, data->base);
@@ -3287,6 +3353,7 @@ http_chunk_out_test_impl(void *arg, int ssl)
 	event_base_dispatch(data->base);
 
 	bufferevent_free(bev);
+	bev = NULL;
 
 	evutil_gettimeofday(&tv_end, NULL);
 	evutil_timersub(&tv_end, &tv_start, &tv_end);
@@ -3296,7 +3363,7 @@ http_chunk_out_test_impl(void *arg, int ssl)
 	tt_int_op(test_ok, ==, 2);
 
 	/* now try again with the regular connection object */
-	bev = create_bev(data->base, -1, ssl);
+	bev = create_bev(data->base, -1, ssl, BEV_OPT_CLOSE_ON_FREE);
 	evcon = evhttp_connection_base_bufferevent_new(
 		data->base, NULL, bev, "127.0.0.1", port);
 	tt_assert(evcon);
@@ -3304,14 +3371,13 @@ http_chunk_out_test_impl(void *arg, int ssl)
 	/* make two requests to check the keepalive behavior */
 	for (i = 0; i < 2; i++) {
 		test_ok = 0;
-		req = evhttp_request_new(http_chunked_request_done,data->base);
+		req = evhttp_request_new(http_chunked_request_done, data->base);
 
 		/* Add the information that we care about */
 		evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
 
 		/* We give ownership of the request to the connection */
-		if (evhttp_make_request(evcon, req,
-			EVHTTP_REQ_GET, "/chunked") == -1) {
+		if (evhttp_make_request(evcon, req, EVHTTP_REQ_GET, "/chunked") == -1) {
 			tt_abort_msg("Couldn't make request");
 		}
 
@@ -3327,7 +3393,7 @@ http_chunk_out_test_impl(void *arg, int ssl)
 		evhttp_free(http);
 }
 static void http_chunk_out_test(void *arg)
-{ return http_chunk_out_test_impl(arg, 0); }
+{ http_chunk_out_test_impl(arg, 0); }
 
 static void
 http_stream_out_test_impl(void *arg, int ssl)
@@ -3342,7 +3408,7 @@ http_stream_out_test_impl(void *arg, int ssl)
 	test_ok = 0;
 	exit_base = data->base;
 
-	bev = create_bev(data->base, -1, ssl);
+	bev = create_bev(data->base, -1, ssl, 0);
 	evcon = evhttp_connection_base_bufferevent_new(
 		data->base, NULL, bev, "127.0.0.1", port);
 	tt_assert(evcon);
@@ -3373,7 +3439,7 @@ http_stream_out_test_impl(void *arg, int ssl)
 		evhttp_free(http);
 }
 static void http_stream_out_test(void *arg)
-{ return http_stream_out_test_impl(arg, 0); }
+{ http_stream_out_test_impl(arg, 0); }
 
 static void
 http_stream_in_chunk(struct evhttp_request *req, void *arg)
@@ -3542,7 +3608,7 @@ http_connection_fail_test_impl(void *arg, int ssl)
 	/* auto detect a port */
 	evhttp_free(http);
 
-	bev = create_bev(data->base, -1, ssl);
+	bev = create_bev(data->base, -1, ssl, 0);
 	/* Pick an unroutable address. This administratively scoped multicast
 	 * address should do when working with TCP. */
 	evcon = evhttp_connection_base_bufferevent_new(
@@ -3569,7 +3635,7 @@ http_connection_fail_test_impl(void *arg, int ssl)
 	;
 }
 static void http_connection_fail_test(void *arg)
-{ return http_connection_fail_test_impl(arg, 0); }
+{ http_connection_fail_test_impl(arg, 0); }
 
 static void
 http_connection_retry_done(struct evhttp_request *req, void *arg)
@@ -3602,19 +3668,19 @@ http_make_web_server(evutil_socket_t fd, short what, void *arg)
 }
 
 static void
-http_simple_test_impl(void *arg, int ssl, int dirty)
+http_simple_test_impl(void *arg, int ssl, int dirty, const char *uri)
 {
 	struct basic_test_data *data = arg;
 	struct evhttp_connection *evcon = NULL;
 	struct evhttp_request *req = NULL;
 	struct bufferevent *bev;
-	struct http_server hs = { .port = 0, .ssl = ssl, };
+	struct http_server hs = { 0, ssl, NULL, };
 	struct evhttp *http = http_setup(&hs.port, data->base, ssl ? HTTP_BIND_SSL : 0);
 
 	exit_base = data->base;
 	test_ok = 0;
 
-	bev = create_bev(data->base, -1, ssl);
+	bev = create_bev(data->base, -1, ssl, 0);
 #ifdef EVENT__HAVE_OPENSSL
 	bufferevent_openssl_set_allow_dirty_shutdown(bev, dirty);
 #endif
@@ -3627,9 +3693,8 @@ http_simple_test_impl(void *arg, int ssl, int dirty)
 	req = evhttp_request_new(http_request_done, (void*) BASIC_REQUEST_BODY);
 	tt_assert(req);
 
-	if (evhttp_make_request(evcon, req, EVHTTP_REQ_GET, "/test") == -1) {
+	if (evhttp_make_request(evcon, req, EVHTTP_REQ_GET, uri) == -1)
 		tt_abort_msg("Couldn't make request");
-	}
 
 	event_base_dispatch(data->base);
 	tt_int_op(test_ok, ==, 1);
@@ -3641,7 +3706,9 @@ http_simple_test_impl(void *arg, int ssl, int dirty)
 		evhttp_free(http);
 }
 static void http_simple_test(void *arg)
-{ return http_simple_test_impl(arg, 0, 0); }
+{ http_simple_test_impl(arg, 0, 0, "/test"); }
+static void http_simple_nonconformant_test(void *arg)
+{ http_simple_test_impl(arg, 0, 0, "/test nonconformant"); }
 
 static void
 http_connection_retry_test_basic(void *arg, const char *addr, struct evdns_base *dns_base, int ssl)
@@ -3651,7 +3718,7 @@ http_connection_retry_test_basic(void *arg, const char *addr, struct evdns_base
 	struct evhttp_request *req = NULL;
 	struct timeval tv, tv_start, tv_end;
 	struct bufferevent *bev;
-	struct http_server hs = { .port = 0, .ssl = ssl, };
+	struct http_server hs = { 0, ssl, NULL, };
 	struct evhttp *http = http_setup(&hs.port, data->base, ssl ? HTTP_BIND_SSL : 0);
 
 	exit_base = data->base;
@@ -3660,7 +3727,7 @@ http_connection_retry_test_basic(void *arg, const char *addr, struct evdns_base
 	/* auto detect a port */
 	evhttp_free(http);
 
-	bev = create_bev(data->base, -1, ssl);
+	bev = create_bev(data->base, -1, ssl, 0);
 	evcon = evhttp_connection_base_bufferevent_new(data->base, dns_base, bev, addr, hs.port);
 	tt_assert(evcon);
 	if (dns_base)
@@ -3798,16 +3865,16 @@ http_connection_retry_conn_address_test_impl(void *arg, int ssl)
 	/** dnsserver will be cleaned in http_connection_retry_test_basic() */
 }
 static void http_connection_retry_conn_address_test(void *arg)
-{ return http_connection_retry_conn_address_test_impl(arg, 0); }
+{ http_connection_retry_conn_address_test_impl(arg, 0); }
 
 static void
 http_connection_retry_test_impl(void *arg, int ssl)
 {
-	return http_connection_retry_test_basic(arg, "127.0.0.1", NULL, ssl);
+	http_connection_retry_test_basic(arg, "127.0.0.1", NULL, ssl);
 }
 static void
 http_connection_retry_test(void *arg)
-{ return http_connection_retry_test_impl(arg, 0); }
+{ http_connection_retry_test_impl(arg, 0); }
 
 static void
 http_primitives(void *ptr)
@@ -3844,7 +3911,7 @@ http_multi_line_header_test(void *arg)
 {
 	struct basic_test_data *data = arg;
 	struct bufferevent *bev= NULL;
-	evutil_socket_t fd = -1;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 	const char *http_start_request;
 	ev_uint16_t port = 0;
 	struct evhttp *http = http_setup(&port, data->base, 0);
@@ -3855,8 +3922,7 @@ http_multi_line_header_test(void *arg)
 	tt_ptr_op(http, !=, NULL);
 
 	fd = http_connect("127.0.0.1", port);
-
-	tt_int_op(fd, !=, -1);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -3960,7 +4026,6 @@ http_large_entity_test_done(struct evhttp_request *req, void *arg)
 end:
 	event_base_loopexit(arg, NULL);
 }
-#ifndef WIN32
 static void
 http_expectation_failed_done(struct evhttp_request *req, void *arg)
 {
@@ -3969,7 +4034,6 @@ http_expectation_failed_done(struct evhttp_request *req, void *arg)
 end:
 	event_base_loopexit(arg, NULL);
 }
-#endif
 
 static void
 http_data_length_constraints_test_impl(void *arg, int read_on_write_error)
@@ -3986,38 +4050,32 @@ http_data_length_constraints_test_impl(void *arg, int read_on_write_error)
 
 	test_ok = 0;
 	cb = http_failed_request_done;
-#ifndef WIN32
 	if (read_on_write_error)
 		cb = http_data_length_constraints_test_done;
-#endif
 
 	tt_assert(continue_size < size);
 
+	long_str = malloc(size);
+	memset(long_str, 'a', size);
+	long_str[size - 1] = '\0';
+
+	TT_BLATHER(("Creating connection to :%i", port));
 	evcon = evhttp_connection_base_new(data->base, NULL, "127.0.0.1", port);
 	tt_assert(evcon);
 
 	if (read_on_write_error)
 		tt_assert(!evhttp_connection_set_flags(evcon, EVHTTP_CON_READ_ON_WRITE_ERROR));
 
-	/* also bind to local host */
 	evhttp_connection_set_local_address(evcon, "127.0.0.1");
 
-	/*
-	 * At this point, we want to schedule an HTTP GET request
-	 * server using our make request method.
-	 */
+	evhttp_set_max_headers_size(http, size - 1);
+	TT_BLATHER(("Set max header size %zu", size - 1));
 
 	req = evhttp_request_new(http_data_length_constraints_test_done, data->base);
 	tt_assert(req);
-
-	long_str = malloc(size);
-	memset(long_str, 'a', size);
-	long_str[size - 1] = '\0';
-	/* Add the information that we care about */
-	evhttp_set_max_headers_size(http, size - 1);
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Longheader", long_str);
-
+	TT_BLATHER(("GET /?arg=val"));
 	if (evhttp_make_request(evcon, req, EVHTTP_REQ_GET, "/?arg=val") == -1) {
 		tt_abort_msg("Couldn't make request");
 	}
@@ -4026,21 +4084,22 @@ http_data_length_constraints_test_impl(void *arg, int read_on_write_error)
 	req = evhttp_request_new(http_data_length_constraints_test_done, data->base);
 	tt_assert(req);
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
-
 	/* GET /?arg=verylongvalue HTTP/1.1 */
+	TT_BLATHER(("GET %s", long_str));
 	if (evhttp_make_request(evcon, req, EVHTTP_REQ_GET, long_str) == -1) {
 		tt_abort_msg("Couldn't make request");
 	}
 	event_base_dispatch(data->base);
 
-#ifndef WIN32
+	evhttp_set_max_body_size(http, size - 2);
+	TT_BLATHER(("Set body header size %zu", size - 2));
+
 	if (read_on_write_error)
 		cb = http_large_entity_test_done;
-#endif
-	evhttp_set_max_body_size(http, size - 2);
 	req = evhttp_request_new(cb, data->base);
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
 	evbuffer_add_printf(evhttp_request_get_output_buffer(req), "%s", long_str);
+	TT_BLATHER(("POST /"));
 	if (evhttp_make_request(evcon, req, EVHTTP_REQ_POST, "/") == -1) {
 		tt_abort_msg("Couldn't make request");
 	}
@@ -4050,29 +4109,31 @@ http_data_length_constraints_test_impl(void *arg, int read_on_write_error)
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Expect", "100-continue");
 	evbuffer_add_printf(evhttp_request_get_output_buffer(req), "%s", long_str);
+	TT_BLATHER(("POST / (Expect: 100-continue, http_large_entity_test_done)"));
 	if (evhttp_make_request(evcon, req, EVHTTP_REQ_POST, "/") == -1) {
 		tt_abort_msg("Couldn't make request");
 	}
 	event_base_dispatch(data->base);
 
+	long_str[continue_size] = '\0';
+
 	req = evhttp_request_new(http_dispatcher_test_done, data->base);
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Expect", "100-continue");
-	long_str[continue_size] = '\0';
 	evbuffer_add_printf(evhttp_request_get_output_buffer(req), "%s", long_str);
+	TT_BLATHER(("POST / (Expect: 100-continue, http_dispatcher_test_done)"));
 	if (evhttp_make_request(evcon, req, EVHTTP_REQ_POST, "/") == -1) {
 		tt_abort_msg("Couldn't make request");
 	}
 	event_base_dispatch(data->base);
 
-#ifndef WIN32
 	if (read_on_write_error)
 		cb = http_expectation_failed_done;
-#endif
 	req = evhttp_request_new(cb, data->base);
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Host", "somehost");
 	evhttp_add_header(evhttp_request_get_output_headers(req), "Expect", "101-continue");
 	evbuffer_add_printf(evhttp_request_get_output_buffer(req), "%s", long_str);
+	TT_BLATHER(("POST / (Expect: 101-continue)"));
 	if (evhttp_make_request(evcon, req, EVHTTP_REQ_POST, "/") == -1) {
 		tt_abort_msg("Couldn't make request");
 	}
@@ -4253,7 +4314,7 @@ http_terminate_chunked_test_impl(void *arg, int oneshot)
 	struct timeval tv;
 	const char *http_request;
 	ev_uint16_t port = 0;
-	evutil_socket_t fd = -1;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
 	struct terminate_state terminate_state;
 	struct evhttp *http = http_setup(&port, data->base, 0);
 
@@ -4264,6 +4325,7 @@ http_terminate_chunked_test_impl(void *arg, int oneshot)
 		terminate_chunked_cb, &terminate_state) == 0);
 
 	fd = http_connect("127.0.0.1", port);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
 
 	/* Stupid thing to send a request */
 	bev = bufferevent_socket_new(data->base, fd, 0);
@@ -4444,7 +4506,7 @@ http_write_during_read_test_impl(void *arg, int ssl)
 	ev_uint16_t port = 0;
 	struct bufferevent *bev = NULL;
 	struct timeval tv;
-	int fd;
+	evutil_socket_t fd;
 	const char *http_request;
 	struct evhttp *http = http_setup(&port, data->base, ssl ? HTTP_BIND_SSL : 0);
 
@@ -4452,7 +4514,8 @@ http_write_during_read_test_impl(void *arg, int ssl)
 	exit_base = data->base;
 
 	fd = http_connect("127.0.0.1", port);
-	bev = create_bev(data->base, fd, 0);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
+	bev = create_bev(data->base, fd, 0, 0);
 	bufferevent_setcb(bev, NULL, NULL, NULL, data->base);
 	bufferevent_disable(bev, EV_READ);
 
@@ -4468,13 +4531,14 @@ http_write_during_read_test_impl(void *arg, int ssl)
 
 	event_base_dispatch(data->base);
 
+end:
 	if (bev)
 		bufferevent_free(bev);
 	if (http)
 		evhttp_free(http);
 }
 static void http_write_during_read_test(void *arg)
-{ return http_write_during_read_test_impl(arg, 0); }
+{ http_write_during_read_test_impl(arg, 0); }
 
 static void
 http_request_own_test(void *arg)
@@ -4511,6 +4575,81 @@ http_request_own_test(void *arg)
 	test_ok = 1;
 }
 
+static void http_run_bev_request(struct event_base *base, int port,
+	const char *fmt, ...)
+{
+	struct bufferevent *bev = NULL;
+	va_list ap;
+	evutil_socket_t fd;
+	struct evbuffer *out;
+
+	fd = http_connect("127.0.0.1", port);
+	tt_assert(fd != EVUTIL_INVALID_SOCKET);
+
+	/* Stupid thing to send a request */
+	bev = create_bev(base, fd, 0, 0);
+	bufferevent_setcb(bev, http_readcb, http_writecb,
+	    http_errorcb, base);
+	out = bufferevent_get_output(bev);
+
+	va_start(ap, fmt);
+	evbuffer_add_vprintf(out, fmt, ap);
+	va_end(ap);
+
+	event_base_dispatch(base);
+
+end:
+	if (bev)
+		bufferevent_free(bev);
+}
+static void
+http_request_extra_body_test(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct bufferevent *bev = NULL;
+	ev_uint16_t port = 0;
+	int i;
+	struct evhttp *http =
+		http_setup_gencb(&port, data->base, 0, http_timeout_cb, NULL);
+	struct evbuffer *body = NULL;
+
+	exit_base = data->base;
+	test_ok = 0;
+
+	body = evbuffer_new();
+	for (i = 0; i < 10000; ++i)
+		evbuffer_add_printf(body, "this is the body that HEAD should not have");
+
+	http_run_bev_request(data->base, port,
+		"HEAD /timeout HTTP/1.1\r\n"
+		"Host: somehost\r\n"
+		"Connection: close\r\n"
+		"Content-Length: %i\r\n"
+		"\r\n%s",
+		(int)evbuffer_get_length(body),
+		evbuffer_pullup(body, -1)
+	);
+	tt_assert(test_ok == -2);
+
+	http_run_bev_request(data->base, port,
+		"HEAD /__gencb__ HTTP/1.1\r\n"
+		"Host: somehost\r\n"
+		"Connection: close\r\n"
+		"Content-Length: %i\r\n"
+		"\r\n%s",
+		(int)evbuffer_get_length(body),
+		evbuffer_pullup(body, -1)
+	);
+	tt_assert(test_ok == -2);
+
+ end:
+	evhttp_free(http);
+	if (bev)
+		bufferevent_free(bev);
+	if (body)
+		evbuffer_free(body);
+}
+
 #define HTTP_LEGACY(name)						\
 	{ #name, run_legacy_test_fn, TT_ISOLATED|TT_LEGACY, &legacy_setup, \
 		    http_##name##_test }
@@ -4518,43 +4657,45 @@ http_request_own_test(void *arg)
 #define HTTP_CAST_ARG(a) ((void *)(a))
 #define HTTP_OFF_N(title, name, arg) \
 	{ #title, http_##name##_test, TT_ISOLATED|TT_OFF_BY_DEFAULT, &basic_setup, HTTP_CAST_ARG(arg) }
-#define HTTP_N(title, name, arg) \
-	{ #title, http_##name##_test, TT_ISOLATED, &basic_setup, HTTP_CAST_ARG(arg) }
-#define HTTP(name) HTTP_N(name, name, NULL)
+#define HTTP_RET_N(title, name, test_opts, arg) \
+	{ #title, http_##name##_test, TT_ISOLATED|TT_RETRIABLE|test_opts, &basic_setup, HTTP_CAST_ARG(arg) }
+#define HTTP_N(title, name, test_opts, arg) \
+	{ #title, http_##name##_test, TT_ISOLATED|test_opts, &basic_setup, HTTP_CAST_ARG(arg) }
+#define HTTP(name) HTTP_N(name, name, 0, NULL)
 #define HTTPS(name) \
 	{ "https_" #name, https_##name##_test, TT_ISOLATED, &basic_setup, NULL }
 
 #ifdef EVENT__HAVE_OPENSSL
 static void https_basic_test(void *arg)
-{ return http_basic_test_impl(arg, 1); }
+{ http_basic_test_impl(arg, 1, "GET /test HTTP/1.1"); }
 static void https_filter_basic_test(void *arg)
-{ return http_basic_test_impl(arg, 1 | HTTP_SSL_FILTER); }
+{ http_basic_test_impl(arg, 1 | HTTP_SSL_FILTER, "GET /test HTTP/1.1"); }
 static void https_incomplete_test(void *arg)
 { http_incomplete_test_(arg, 0, 1); }
 static void https_incomplete_timeout_test(void *arg)
 { http_incomplete_test_(arg, 1, 1); }
 static void https_simple_test(void *arg)
-{ return http_simple_test_impl(arg, 1, 0); }
+{ http_simple_test_impl(arg, 1, 0, "/test"); }
 static void https_simple_dirty_test(void *arg)
-{ return http_simple_test_impl(arg, 1, 1); }
+{ http_simple_test_impl(arg, 1, 1, "/test"); }
 static void https_connection_retry_conn_address_test(void *arg)
-{ return http_connection_retry_conn_address_test_impl(arg, 1); }
+{ http_connection_retry_conn_address_test_impl(arg, 1); }
 static void https_connection_retry_test(void *arg)
-{ return http_connection_retry_test_impl(arg, 1); }
+{ http_connection_retry_test_impl(arg, 1); }
 static void https_chunk_out_test(void *arg)
-{ return http_chunk_out_test_impl(arg, 1); }
+{ http_chunk_out_test_impl(arg, 1); }
 static void https_filter_chunk_out_test(void *arg)
-{ return http_chunk_out_test_impl(arg, 1 | HTTP_SSL_FILTER); }
+{ http_chunk_out_test_impl(arg, 1 | HTTP_SSL_FILTER); }
 static void https_stream_out_test(void *arg)
-{ return http_stream_out_test_impl(arg, 1); }
+{ http_stream_out_test_impl(arg, 1); }
 static void https_connection_fail_test(void *arg)
-{ return http_connection_fail_test_impl(arg, 1); }
+{ http_connection_fail_test_impl(arg, 1); }
 static void https_write_during_read_test(void *arg)
-{ return http_write_during_read_test_impl(arg, 1); }
+{ http_write_during_read_test_impl(arg, 1); }
 static void https_connection_test(void *arg)
-{ return http_connection_test_(arg, 0, "127.0.0.1", NULL, 0, AF_UNSPEC, 1); }
+{ http_connection_test_(arg, 0, "127.0.0.1", NULL, 0, AF_UNSPEC, 1); }
 static void https_persist_connection_test(void *arg)
-{ return http_connection_test_(arg, 1, "127.0.0.1", NULL, 0, AF_UNSPEC, 1); }
+{ http_connection_test_(arg, 1, "127.0.0.1", NULL, 0, AF_UNSPEC, 1); }
 #endif
 
 struct testcase_t http_testcases[] = {
@@ -4562,24 +4703,27 @@ struct testcase_t http_testcases[] = {
 	{ "base", http_base_test, TT_FORK, NULL, NULL },
 	{ "bad_headers", http_bad_header_test, 0, NULL, NULL },
 	{ "parse_query", http_parse_query_test, 0, NULL, NULL },
+	{ "parse_query_str", http_parse_query_str_test, 0, NULL, NULL },
 	{ "parse_uri", http_parse_uri_test, 0, NULL, NULL },
 	{ "parse_uri_nc", http_parse_uri_test, 0, &basic_setup, (void*)"nc" },
 	{ "uriencode", http_uriencode_test, 0, NULL, NULL },
 	HTTP(basic),
+	HTTP(basic_trailing_space),
 	HTTP(simple),
-
-	HTTP_N(cancel, cancel, BASIC),
-	HTTP_N(cancel_by_host, cancel, BY_HOST),
-	HTTP_N(cancel_by_host_no_ns, cancel, BY_HOST | NO_NS),
-	HTTP_N(cancel_by_host_inactive_server, cancel, BY_HOST | INACTIVE_SERVER),
-	HTTP_N(cancel_inactive_server, cancel, INACTIVE_SERVER),
-	HTTP_N(cancel_by_host_no_ns_inactive_server, cancel, BY_HOST | NO_NS | INACTIVE_SERVER),
+	HTTP(simple_nonconformant),
+
+	HTTP_N(cancel, cancel, 0, BASIC),
+	HTTP_RET_N(cancel_by_host, cancel, 0, BY_HOST),
+	HTTP_RET_N(cancel_by_host_inactive_server, cancel, TT_NO_LOGS, BY_HOST | INACTIVE_SERVER),
+	HTTP_RET_N(cancel_by_host_no_ns, cancel, TT_NO_LOGS, BY_HOST | NO_NS),
+	HTTP_N(cancel_inactive_server, cancel, 0, INACTIVE_SERVER),
+	HTTP_N(cancel_by_host_no_ns_inactive_server, cancel, TT_NO_LOGS, BY_HOST | NO_NS | INACTIVE_SERVER),
 	HTTP_OFF_N(cancel_by_host_server_timeout, cancel, BY_HOST | INACTIVE_SERVER | SERVER_TIMEOUT),
 	HTTP_OFF_N(cancel_server_timeout, cancel, INACTIVE_SERVER | SERVER_TIMEOUT),
 	HTTP_OFF_N(cancel_by_host_no_ns_server_timeout, cancel, BY_HOST | NO_NS | INACTIVE_SERVER | SERVER_TIMEOUT),
 	HTTP_OFF_N(cancel_by_host_ns_timeout_server_timeout, cancel, BY_HOST | NO_NS | NS_TIMEOUT | INACTIVE_SERVER | SERVER_TIMEOUT),
-	HTTP_N(cancel_by_host_ns_timeout, cancel, BY_HOST | NO_NS | NS_TIMEOUT),
-	HTTP_N(cancel_by_host_ns_timeout_inactive_server, cancel, BY_HOST | NO_NS | NS_TIMEOUT | INACTIVE_SERVER),
+	HTTP_RET_N(cancel_by_host_ns_timeout, cancel, TT_NO_LOGS, BY_HOST | NO_NS | NS_TIMEOUT),
+	HTTP_RET_N(cancel_by_host_ns_timeout_inactive_server, cancel, TT_NO_LOGS, BY_HOST | NO_NS | NS_TIMEOUT | INACTIVE_SERVER),
 
 	HTTP(virtual_host),
 	HTTP(post),
@@ -4630,6 +4774,8 @@ struct testcase_t http_testcases[] = {
 	HTTP(write_during_read),
 	HTTP(request_own),
 
+	HTTP(request_extra_body),
+
 #ifdef EVENT__HAVE_OPENSSL
 	HTTPS(basic),
 	HTTPS(filter_basic),
@@ -4652,3 +4798,10 @@ struct testcase_t http_testcases[] = {
 	END_OF_TESTCASES
 };
 
+struct testcase_t http_iocp_testcases[] = {
+	{ "simple", http_simple_test, TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup, NULL },
+#ifdef EVENT__HAVE_OPENSSL
+	{ "https_simple", https_simple_test, TT_FORK|TT_NEED_BASE|TT_ENABLE_IOCP, &basic_setup, NULL },
+#endif
+	END_OF_TESTCASES
+};
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_listener.c b/ipc/chromium/src/third_party/libevent/test/regress_listener.c
index 72f7237be6e4..871da4c62ce9 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_listener.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_listener.c
@@ -80,8 +80,9 @@ regress_pick_a_port(void *arg)
 	ev_socklen_t slen1 = sizeof(ss1), slen2 = sizeof(ss2);
 	unsigned int flags =
 	    LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE|LEV_OPT_CLOSE_ON_EXEC;
+	evutil_socket_t fd1, fd2, fd3;
 
-	evutil_socket_t fd1 = -1, fd2 = -1, fd3 = -1;
+	fd1 = fd2 = fd3 = EVUTIL_INVALID_SOCKET;
 
 	if (data->setup_data && strstr((char*)data->setup_data, "ts")) {
 		flags |= LEV_OPT_THREADSAFE;
@@ -99,8 +100,8 @@ regress_pick_a_port(void *arg)
 	    flags, -1, (struct sockaddr *)&sin, sizeof(sin));
 	tt_assert(listener2);
 
-	tt_int_op(evconnlistener_get_fd(listener1), >=, 0);
-	tt_int_op(evconnlistener_get_fd(listener2), >=, 0);
+	tt_assert(evconnlistener_get_fd(listener1) != EVUTIL_INVALID_SOCKET);
+	tt_assert(evconnlistener_get_fd(listener2) != EVUTIL_INVALID_SOCKET);
 	tt_assert(getsockname(evconnlistener_get_fd(listener1),
 		(struct sockaddr*)&ss1, &slen1) == 0);
 	tt_assert(getsockname(evconnlistener_get_fd(listener2),
@@ -117,7 +118,7 @@ regress_pick_a_port(void *arg)
 	tt_ptr_op(evconnlistener_get_base(listener1), ==, base);
 	tt_ptr_op(evconnlistener_get_base(listener2), ==, base);
 
-	fd1 = fd2 = fd3 = -1;
+	fd1 = fd2 = fd3 = EVUTIL_INVALID_SOCKET;
 	evutil_socket_connect_(&fd1, (struct sockaddr*)&ss1, slen1);
 	evutil_socket_connect_(&fd2, (struct sockaddr*)&ss1, slen1);
 	evutil_socket_connect_(&fd3, (struct sockaddr*)&ss2, slen2);
@@ -185,6 +186,89 @@ end:
 		evconnlistener_free(listener);
 }
 
+static void
+acceptcb_free(struct evconnlistener *listener, evutil_socket_t fd,
+    struct sockaddr *addr, int socklen, void *arg)
+{
+	int *ptr = arg;
+	--*ptr;
+	TT_BLATHER(("Got one for %p", ptr));
+	evutil_closesocket(fd);
+
+	if (! *ptr)
+		evconnlistener_free(listener);
+}
+static void
+regress_listener_close_accepted_fd(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+	struct evconnlistener *listener = NULL;
+	struct sockaddr_in sin;
+	struct sockaddr_storage ss;
+	ev_socklen_t slen = sizeof(ss);
+	int count = 1;
+	unsigned int flags = LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE;
+	evutil_socket_t fd = EVUTIL_INVALID_SOCKET;
+
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
+	sin.sin_port = 0; /* "You pick!" */
+
+	/* Start a listener with a bogus socket. */
+	listener = evconnlistener_new_bind(base, acceptcb_free, &count,
+	    flags, -1, (struct sockaddr *)&sin, sizeof(sin));
+	tt_assert(listener);
+
+	tt_assert(getsockname(evconnlistener_get_fd(listener),
+		(struct sockaddr*)&ss, &slen) == 0);
+	evutil_socket_connect_(&fd, (struct sockaddr*)&ss, slen);
+
+	event_base_dispatch(base);
+
+end:
+	;
+}
+
+static void
+regress_listener_immediate_close(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+	struct evconnlistener *listener = NULL;
+	struct sockaddr_in sin;
+	struct sockaddr_storage ss;
+	ev_socklen_t slen = sizeof(ss);
+	int count = 1;
+	unsigned int flags = LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE;
+	evutil_socket_t fd1 = EVUTIL_INVALID_SOCKET, fd2 = EVUTIL_INVALID_SOCKET;
+
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = htonl(0x7f000001); /* 127.0.0.1 */
+	sin.sin_port = 0; /* "You pick!" */
+
+	/* Start a listener with a bogus socket. */
+	listener = evconnlistener_new_bind(base, acceptcb, &count,
+	    flags, -1, (struct sockaddr *)&sin, sizeof(sin));
+	tt_assert(listener);
+
+	tt_assert(getsockname(evconnlistener_get_fd(listener),
+		(struct sockaddr*)&ss, &slen) == 0);
+
+	evutil_socket_connect_(&fd1, (struct sockaddr*)&ss, slen);
+	evutil_socket_connect_(&fd2, (struct sockaddr*)&ss, slen);
+
+	event_base_dispatch(base);
+
+	tt_int_op(count, ==, 0);
+
+end:
+	if (listener)
+		evconnlistener_free(listener);
+}
+
 #ifdef EVENT__HAVE_SETRLIMIT
 static void
 regress_listener_error_unlock(void *arg)
@@ -230,7 +314,7 @@ struct testcase_t listener_testcases[] = {
 
 #ifdef EVENT__HAVE_SETRLIMIT
 	{ "error_unlock", regress_listener_error_unlock,
-	  TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR,
+	  TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR|TT_NO_LOGS,
 	  &basic_setup, NULL},
 #endif
 
@@ -242,6 +326,12 @@ struct testcase_t listener_testcases[] = {
 	  TT_FORK|TT_NEED_BASE|TT_NEED_SOCKETPAIR,
 	  &basic_setup, (char*)"ts"},
 
+	{ "close_accepted_fd", regress_listener_close_accepted_fd,
+	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL, },
+
+	{ "immediate_close", regress_listener_immediate_close,
+	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL, },
+
 	END_OF_TESTCASES,
 };
 
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_main.c b/ipc/chromium/src/third_party/libevent/test/regress_main.c
index 44e291119a3d..266561214b8e 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_main.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_main.c
@@ -33,6 +33,14 @@
 #include <fcntl.h>
 #endif
 
+/* move_pthread_to_realtime_scheduling_class() */
+#ifdef EVENT__HAVE_MACH_MACH_H
+#include <mach/mach.h>
+#endif
+#ifdef EVENT__HAVE_MACH_MACH_TIME_H
+#include <mach/mach_time.h>
+#endif
+
 #if defined(__APPLE__) && defined(__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__)
 #if (__ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ >= 1060 && \
     __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ < 1070)
@@ -81,10 +89,12 @@
 
 #include "event2/event-config.h"
 #include "regress.h"
+#include "regress_thread.h"
 #include "tinytest.h"
 #include "tinytest_macros.h"
 #include "../iocp-internal.h"
 #include "../event-internal.h"
+#include "../evthread-internal.h"
 
 struct evutil_weakrand_state test_weakrand_state;
 
@@ -186,18 +196,65 @@ ignore_log_cb(int s, const char *msg)
 {
 }
 
-static void *
+/**
+ * Put into the real time scheduling class for better timers latency.
+ * https://developer.apple.com/library/archive/technotes/tn2169/_index.html#//apple_ref/doc/uid/DTS40013172-CH1-TNTAG6000
+ */
+#if defined(__APPLE__)
+static void move_pthread_to_realtime_scheduling_class(pthread_t pthread)
+{
+	mach_timebase_info_data_t info;
+	mach_timebase_info(&info);
+
+	const uint64_t NANOS_PER_MSEC = 1000000ULL;
+	double clock2abs =
+		((double)info.denom / (double)info.numer) * NANOS_PER_MSEC;
+
+	thread_time_constraint_policy_data_t policy;
+	policy.period      = 0;
+	policy.computation = (uint32_t)(5 * clock2abs); // 5 ms of work
+	policy.constraint  = (uint32_t)(10 * clock2abs);
+	policy.preemptible = FALSE;
+
+	int kr = thread_policy_set(pthread_mach_thread_np(pthread),
+		THREAD_TIME_CONSTRAINT_POLICY,
+		(thread_policy_t)&policy,
+		THREAD_TIME_CONSTRAINT_POLICY_COUNT);
+	if (kr != KERN_SUCCESS) {
+		mach_error("thread_policy_set:", kr);
+		exit(1);
+	}
+}
+
+void thread_setup(THREAD_T pthread)
+{
+	move_pthread_to_realtime_scheduling_class(pthread);
+}
+#else /** \__APPLE__ */
+void thread_setup(THREAD_T pthread) {}
+#endif /** \!__APPLE__ */
+
+
+void *
 basic_test_setup(const struct testcase_t *testcase)
 {
 	struct event_base *base = NULL;
 	evutil_socket_t spair[2] = { -1, -1 };
 	struct basic_test_data *data = NULL;
 
+	thread_setup(THREAD_SELF());
+
 #ifndef _WIN32
 	if (testcase->flags & TT_ENABLE_IOCP_FLAG)
 		return (void*)TT_SKIP;
 #endif
 
+	if (testcase->flags & TT_ENABLE_DEBUG_MODE &&
+		!libevent_tests_running_in_debug_mode) {
+		event_enable_debug_mode();
+		libevent_tests_running_in_debug_mode = 1;
+	}
+
 	if (testcase->flags & TT_NEED_THREADS) {
 		if (!(testcase->flags & TT_FORK))
 			return NULL;
@@ -262,7 +319,7 @@ basic_test_setup(const struct testcase_t *testcase)
 	return data;
 }
 
-static int
+int
 basic_test_cleanup(const struct testcase_t *testcase, void *ptr)
 {
 	struct basic_test_data *data = ptr;
@@ -384,6 +441,7 @@ struct testgroup_t testgroups[] = {
 	{ "iocp/", iocp_testcases },
 	{ "iocp/bufferevent/", bufferevent_iocp_testcases },
 	{ "iocp/listener/", listener_iocp_testcases },
+	{ "iocp/http/", http_iocp_testcases },
 #endif
 #ifdef EVENT__HAVE_OPENSSL
 	{ "ssl/", ssl_testcases },
@@ -435,6 +493,7 @@ main(int argc, const char **argv)
 #ifdef _WIN32
 	tinytest_skip(testgroups, "http/connection_retry");
 	tinytest_skip(testgroups, "http/https_connection_retry");
+	tinytest_skip(testgroups, "http/read_on_write_error");
 #endif
 
 #ifndef EVENT__DISABLE_THREAD_SUPPORT
@@ -454,6 +513,11 @@ main(int argc, const char **argv)
 
 	evutil_weakrand_seed_(&test_weakrand_state, 0);
 
+	if (getenv("EVENT_NO_FILE_BUFFERING")) {
+		setbuf(stdout, NULL);
+		setbuf(stderr, NULL);
+	}
+
 	if (tinytest_main(argc,argv,testgroups))
 		return 1;
 
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_rpc.c b/ipc/chromium/src/third_party/libevent/test/regress_rpc.c
index 01a058cbb2b8..87a7efa12fc3 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_rpc.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_rpc.c
@@ -61,7 +61,6 @@
 #include "event2/http_compat.h"
 #include "event2/http_struct.h"
 #include "event2/rpc.h"
-#include "event2/rpc.h"
 #include "event2/rpc_struct.h"
 #include "event2/tag.h"
 #include "log-internal.h"
@@ -880,6 +879,53 @@ end:
 		evbuffer_free(tmp);
 }
 
+static void
+rpc_invalid_type(void)
+{
+	ev_uint16_t port;
+	struct evhttp *http = NULL;
+	struct evrpc_base *base = NULL;
+	struct evhttp_connection *evcon = NULL;
+	struct evhttp_request *req = NULL;
+
+	rpc_setup(&http, &port, &base);
+
+	evcon = evhttp_connection_new("127.0.0.1", port);
+	tt_assert(evcon);
+
+	/*
+	 * At this point, we want to schedule an HTTP POST request
+	 * server using our make request method.
+	 */
+
+	req = evhttp_request_new(rpc_postrequest_failure, NULL);
+	tt_assert(req);
+
+	/* Add the information that we care about */
+	evhttp_add_header(req->output_headers, "Host", "somehost");
+	evbuffer_add_printf(req->output_buffer, "Some Nonsense");
+
+	if (evhttp_make_request(evcon, req,
+		EVHTTP_REQ_GET,
+		"/.rpc.Message") == -1) {
+		tt_abort();
+	}
+
+	test_ok = 0;
+
+	event_dispatch();
+
+	evhttp_connection_free(evcon);
+
+	rpc_teardown(base);
+
+	tt_assert(test_ok == 1);
+
+end:
+	evhttp_free(http);
+}
+
+
 #define RPC_LEGACY(name)						\
 	{ #name, run_legacy_test_fn, TT_FORK|TT_NEED_BASE|TT_LEGACY,	\
 		    &legacy_setup,					\
@@ -898,6 +944,7 @@ struct testcase_t rpc_testcases[] = {
 	RPC_LEGACY(basic_client),
 	RPC_LEGACY(basic_queued_client),
 	RPC_LEGACY(basic_client_with_pause),
+	RPC_LEGACY(invalid_type),
 	RPC_LEGACY(client_timeout),
 	RPC_LEGACY(test),
 
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_ssl.c b/ipc/chromium/src/third_party/libevent/test/regress_ssl.c
index 681705fcf969..37dc334dcafa 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_ssl.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_ssl.c
@@ -53,7 +53,6 @@
 #include "tinytest.h"
 #include "tinytest_macros.h"
 
-#include <openssl/bio.h>
 #include <openssl/err.h>
 #include <openssl/pem.h>
 #include "openssl-compat.h"
@@ -119,14 +118,13 @@ end:
 }
 
 X509 *
-ssl_getcert(void)
+ssl_getcert(EVP_PKEY *key)
 {
 	/* Dummy code to make a quick-and-dirty valid certificate with
 	   OpenSSL.  Don't copy this code into your own program! It does a
 	   number of things in a stupid and insecure way. */
 	X509 *x509 = NULL;
 	X509_NAME *name = NULL;
-	EVP_PKEY *key = ssl_getkey();
 	int nid;
 	time_t now = time(NULL);
 
@@ -148,16 +146,18 @@ ssl_getcert(void)
 
 	X509_set_subject_name(x509, name);
 	X509_set_issuer_name(x509, name);
+	X509_NAME_free(name);
 
-	X509_time_adj(X509_get_notBefore(x509), 0, &now);
+	X509_time_adj(X509_getm_notBefore(x509), 0, &now);
 	now += 3600;
-	X509_time_adj(X509_get_notAfter(x509), 0, &now);
+	X509_time_adj(X509_getm_notAfter(x509), 0, &now);
 	X509_set_pubkey(x509, key);
 	tt_assert(0 != X509_sign(x509, key, EVP_sha1()));
 
 	return x509;
 end:
 	X509_free(x509);
+	X509_NAME_free(name);
 	return NULL;
 }
 
@@ -183,35 +183,86 @@ get_ssl_ctx(void)
 	return the_ssl_ctx;
 }
 
+static int test_is_done;
+static int n_connected;
+static int got_close;
+static int got_error;
+static int got_timeout;
+static int renegotiate_at = -1;
+static int stop_when_connected;
+static int pending_connect_events;
+static struct event_base *exit_base;
+static X509 *the_cert;
+EVP_PKEY *the_key;
+
 void
 init_ssl(void)
 {
-#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L) || \
+	(defined(LIBRESSL_VERSION_NUMBER) && LIBRESSL_VERSION_NUMBER < 0x20700000L)
 	SSL_library_init();
 	ERR_load_crypto_strings();
 	SSL_load_error_strings();
 	OpenSSL_add_all_algorithms();
 	if (SSLeay() != OPENSSL_VERSION_NUMBER) {
-		TT_DECLARE("WARN", ("Version mismatch for openssl: compiled with %lx but running with %lx", (unsigned long)OPENSSL_VERSION_NUMBER, (unsigned long) SSLeay()));
+		TT_DECLARE("WARN",
+			("Version mismatch for openssl: compiled with %lx but running with %lx",
+			(unsigned long)OPENSSL_VERSION_NUMBER, (unsigned long)SSLeay()));
 	}
 #endif
 }
 
+static void *
+ssl_test_setup(const struct testcase_t *testcase)
+{
+	init_ssl();
+
+	the_key = ssl_getkey();
+	EVUTIL_ASSERT(the_key);
+
+	the_cert = ssl_getcert(the_key);
+	EVUTIL_ASSERT(the_cert);
+
+	disable_tls_11_and_12 = 0;
+
+	return basic_test_setup(testcase);
+}
+static int
+ssl_test_cleanup(const struct testcase_t *testcase, void *ptr)
+{
+	int ret = basic_test_cleanup(testcase, ptr);
+	if (!ret) {
+		return ret;
+	}
+
+	test_is_done = 0;
+	n_connected = 0;
+	got_close = 0;
+	got_error = 0;
+	got_timeout = 0;
+	renegotiate_at = -1;
+	stop_when_connected = 0;
+	pending_connect_events = 0;
+	exit_base = NULL;
+
+	X509_free(the_cert);
+	EVP_PKEY_free(the_key);
+
+	SSL_CTX_free(the_ssl_ctx);
+	the_ssl_ctx = NULL;
+
+	return 1;
+}
+const struct testcase_setup_t ssl_setup = {
+	ssl_test_setup, ssl_test_cleanup
+};
+
+
 /* ====================
    Here's a simple test: we read a number from the input, increment it, and
    reply, until we get to 1001.
 */
 
-static int test_is_done = 0;
-static int n_connected = 0;
-static int got_close = 0;
-static int got_error = 0;
-static int got_timeout = 0;
-static int renegotiate_at = -1;
-static int stop_when_connected = 0;
-static int pending_connect_events = 0;
-static struct event_base *exit_base = NULL;
-
 enum regress_openssl_type
 {
 	REGRESS_OPENSSL_SOCKETPAIR = 1,
@@ -229,17 +280,19 @@ enum regress_openssl_type
 	REGRESS_OPENSSL_SLEEP = 1024,
 
 	REGRESS_OPENSSL_CLIENT_WRITE = 2048,
+
+	REGRESS_DEFERRED_CALLBACKS = 4096,
 };
 
 static void
 bufferevent_openssl_check_fd(struct bufferevent *bev, int filter)
 {
-	tt_int_op(bufferevent_getfd(bev), !=, -1);
-	tt_int_op(bufferevent_setfd(bev, -1), ==, 0);
+	tt_fd_op(bufferevent_getfd(bev), !=, EVUTIL_INVALID_SOCKET);
+	tt_fd_op(bufferevent_setfd(bev, EVUTIL_INVALID_SOCKET), ==, 0);
 	if (filter) {
-		tt_int_op(bufferevent_getfd(bev), !=, -1);
+		tt_fd_op(bufferevent_getfd(bev), !=, EVUTIL_INVALID_SOCKET);
 	} else {
-		tt_int_op(bufferevent_getfd(bev), ==, -1);
+		tt_fd_op(bufferevent_getfd(bev), ==, EVUTIL_INVALID_SOCKET);
 	}
 
 end:
@@ -255,6 +308,13 @@ end:
 	;
 }
 
+static void
+free_on_cb(struct bufferevent *bev, void *ctx)
+{
+	TT_BLATHER(("free_on_cb: %p", bev));
+	bufferevent_free(bev);
+}
+
 static void
 respond_to_number(struct bufferevent *bev, void *ctx)
 {
@@ -303,13 +363,14 @@ done_writing_cb(struct bufferevent *bev, void *ctx)
 static void
 eventcb(struct bufferevent *bev, short what, void *ctx)
 {
+	X509 *peer_cert = NULL;
 	enum regress_openssl_type type;
+
 	type = (enum regress_openssl_type)ctx;
 
 	TT_BLATHER(("Got event %d", (int)what));
 	if (what & BEV_EVENT_CONNECTED) {
 		SSL *ssl;
-		X509 *peer_cert;
 		++n_connected;
 		ssl = bufferevent_openssl_get_ssl(bev);
 		tt_assert(ssl);
@@ -357,8 +418,10 @@ eventcb(struct bufferevent *bev, short what, void *ctx)
 		}
 		bufferevent_free(bev);
 	}
+
 end:
-	;
+	if (peer_cert)
+		X509_free(peer_cert);
 }
 
 static void
@@ -398,8 +461,6 @@ regress_bufferevent_openssl(void *arg)
 
 	struct bufferevent *bev1, *bev2;
 	SSL *ssl1, *ssl2;
-	X509 *cert = ssl_getcert();
-	EVP_PKEY *key = ssl_getkey();
 	int flags = BEV_OPT_DEFER_CALLBACKS;
 	struct bufferevent *bev_ll[2] = { NULL, NULL };
 	evutil_socket_t *fd_pair = NULL;
@@ -407,14 +468,9 @@ regress_bufferevent_openssl(void *arg)
 	enum regress_openssl_type type;
 	type = (enum regress_openssl_type)data->setup_data;
 
-	tt_assert(cert);
-	tt_assert(key);
-
-	init_ssl();
-
 	if (type & REGRESS_OPENSSL_RENEGOTIATE) {
-		if (SSLeay() >= 0x10001000 &&
-		    SSLeay() <  0x1000104f) {
+		if (OPENSSL_VERSION_NUMBER >= 0x10001000 &&
+		    OPENSSL_VERSION_NUMBER <  0x1000104f) {
 			/* 1.0.1 up to 1.0.1c has a bug where TLS1.1 and 1.2
 			 * can't renegotiate with themselves. Disable. */
 			disable_tls_11_and_12 = 1;
@@ -425,8 +481,8 @@ regress_bufferevent_openssl(void *arg)
 	ssl1 = SSL_new(get_ssl_ctx());
 	ssl2 = SSL_new(get_ssl_ctx());
 
-	SSL_use_certificate(ssl2, cert);
-	SSL_use_PrivateKey(ssl2, key);
+	SSL_use_certificate(ssl2, the_cert);
+	SSL_use_PrivateKey(ssl2, the_key);
 
 	if (!(type & REGRESS_OPENSSL_OPEN))
 		flags |= BEV_OPT_CLOSE_ON_FREE;
@@ -445,7 +501,7 @@ regress_bufferevent_openssl(void *arg)
 	    fd_pair, bev_ll, type);
 
 	if (!(type & REGRESS_OPENSSL_FILTER)) {
-		tt_int_op(bufferevent_getfd(bev1), ==, data->pair[0]);
+		tt_fd_op(bufferevent_getfd(bev1), ==, data->pair[0]);
 	} else {
 		tt_ptr_op(bufferevent_get_underlying(bev1), ==, bev_ll[0]);
 	}
@@ -504,7 +560,10 @@ regress_bufferevent_openssl(void *arg)
 		tt_int_op(got_close, ==, 0);
 		tt_int_op(got_error, ==, 0);
 		tt_int_op(got_timeout, ==, 1);
+
+		bufferevent_free(bev2);
 	}
+
 end:
 	return;
 }
@@ -526,15 +585,13 @@ acceptcb(struct evconnlistener *listener, evutil_socket_t fd,
 
 	type = (enum regress_openssl_type)data->setup_data;
 
-	SSL_use_certificate(ssl, ssl_getcert());
-	SSL_use_PrivateKey(ssl, ssl_getkey());
+	SSL_use_certificate(ssl, the_cert);
+	SSL_use_PrivateKey(ssl, the_key);
 
 	bev = bufferevent_openssl_socket_new(
-		data->base,
-		fd,
-		ssl,
-		BUFFEREVENT_SSL_ACCEPTING,
+		data->base, fd, ssl, BUFFEREVENT_SSL_ACCEPTING,
 		BEV_OPT_CLOSE_ON_FREE|BEV_OPT_DEFER_CALLBACKS);
+	tt_assert(bev);
 
 	bufferevent_setcb(bev, respond_to_number, NULL, eventcb,
 	    (void*)(REGRESS_OPENSSL_SERVER));
@@ -550,11 +607,14 @@ acceptcb(struct evconnlistener *listener, evutil_socket_t fd,
 
 	/* Only accept once, then disable ourself. */
 	evconnlistener_disable(listener);
+
+end:
+	;
 }
 
 struct rwcount
 {
-	int fd;
+	evutil_socket_t fd;
 	size_t read;
 	size_t write;
 };
@@ -568,6 +628,7 @@ bio_rwcount_new(BIO *b)
 static int
 bio_rwcount_free(BIO *b)
 {
+	TT_BLATHER(("bio_rwcount_free: %p", b));
 	if (!b)
 		return 0;
 	if (BIO_get_shutdown(b)) {
@@ -590,7 +651,6 @@ bio_rwcount_read(BIO *b, char *out, int outlen)
 static int
 bio_rwcount_write(BIO *b, const char *in, int inlen)
 {
-
 	struct rwcount *rw = BIO_get_data(b);
 	ev_ssize_t ret = send(rw->fd, in, inlen, 0);
 	++rw->write;
@@ -602,8 +662,12 @@ bio_rwcount_write(BIO *b, const char *in, int inlen)
 static long
 bio_rwcount_ctrl(BIO *b, int cmd, long num, void *ptr)
 {
+	struct rwcount *rw = BIO_get_data(b);
 	long ret = 0;
 	switch (cmd) {
+	case BIO_C_GET_FD:
+		ret = rw->fd;
+		break;
 	case BIO_CTRL_GET_CLOSE:
 		ret = BIO_get_shutdown(b);
 		break;
@@ -672,14 +736,11 @@ regress_bufferevent_openssl_connect(void *arg)
 	struct sockaddr_storage ss;
 	ev_socklen_t slen;
 	SSL *ssl;
-	BIO *bio;
 	struct rwcount rw = { -1, 0, 0 };
 	enum regress_openssl_type type;
 
 	type = (enum regress_openssl_type)data->setup_data;
 
-	init_ssl();
-
 	memset(&sin, 0, sizeof(sin));
 	sin.sin_family = AF_INET;
 	sin.sin_addr.s_addr = htonl(0x7f000001);
@@ -703,7 +764,7 @@ regress_bufferevent_openssl_connect(void *arg)
 		BEV_OPT_CLOSE_ON_FREE|BEV_OPT_DEFER_CALLBACKS);
 	tt_assert(bev);
 
-	bufferevent_setcb(bev, respond_to_number, NULL, eventcb,
+	bufferevent_setcb(bev, respond_to_number, free_on_cb, eventcb,
 	    (void*)(REGRESS_OPENSSL_CLIENT));
 
 	tt_assert(getsockname(evconnlistener_get_fd(listener),
@@ -716,6 +777,8 @@ regress_bufferevent_openssl_connect(void *arg)
 	/* Possible only when we have fd, since be_openssl can and will overwrite
 	 * bio otherwise before */
 	if (type & REGRESS_OPENSSL_SLEEP) {
+		BIO *bio;
+
 		rw.fd = bufferevent_getfd(bev);
 		bio = BIO_new_rwcount(0);
 		tt_assert(bio);
@@ -730,83 +793,284 @@ regress_bufferevent_openssl_connect(void *arg)
 	tt_int_op(rw.read, <=, 100);
 	tt_int_op(rw.write, <=, 100);
 end:
-	;
+	evconnlistener_free(listener);
+}
+
+struct wm_context
+{
+	int server;
+	int flags;
+	struct evbuffer *data;
+	size_t to_read;
+	size_t wm_high;
+	size_t limit;
+	size_t get;
+	struct bufferevent *bev;
+	struct wm_context *neighbour;
+};
+static void
+wm_transfer(struct bufferevent *bev, void *arg)
+{
+	struct wm_context *ctx = arg;
+	struct evbuffer *in  = bufferevent_get_input(bev);
+	struct evbuffer *out = bufferevent_get_output(bev);
+	size_t len = evbuffer_get_length(in);
+	size_t drain = len < ctx->to_read ? len : ctx->to_read;
+
+	if (ctx->get >= ctx->limit) {
+		TT_BLATHER(("wm_transfer-%s(%p): break",
+			ctx->server ? "server" : "client", bev));
+		bufferevent_setcb(bev, NULL, NULL, NULL, NULL);
+		bufferevent_disable(bev, EV_READ);
+		if (ctx->neighbour->get >= ctx->neighbour->limit) {
+			event_base_loopbreak(bufferevent_get_base(bev));
+		}
+	} else {
+		ctx->get += drain;
+		evbuffer_drain(in, drain);
+	}
+
+	TT_BLATHER(("wm_transfer-%s(%p): "
+		"in: " EV_SIZE_FMT ", "
+		"out: " EV_SIZE_FMT ", "
+		"got: " EV_SIZE_FMT "",
+		ctx->server ? "server" : "client", bev,
+		evbuffer_get_length(in),
+		evbuffer_get_length(out),
+		ctx->get));
+
+	evbuffer_add_buffer_reference(out, ctx->data);
+}
+static void
+wm_eventcb(struct bufferevent *bev, short what, void *arg)
+{
+	struct wm_context *ctx = arg;
+	TT_BLATHER(("wm_eventcb-%s(%p): %i",
+		ctx->server ? "server" : "client", bev, what));
+	if (what & BEV_EVENT_CONNECTED) {
+	} else {
+		ctx->get = 0;
+	}
+}
+static void
+wm_acceptcb(struct evconnlistener *listener, evutil_socket_t fd,
+    struct sockaddr *addr, int socklen, void *arg)
+{
+	struct wm_context *ctx = arg;
+	struct bufferevent *bev;
+	struct event_base *base = evconnlistener_get_base(listener);
+	SSL *ssl = SSL_new(get_ssl_ctx());
+
+	SSL_use_certificate(ssl, the_cert);
+	SSL_use_PrivateKey(ssl, the_key);
+
+	bev = bufferevent_openssl_socket_new(
+		base, fd, ssl, BUFFEREVENT_SSL_ACCEPTING, ctx->flags);
+
+	TT_BLATHER(("wm_transfer-%s(%p): accept",
+		ctx->server ? "server" : "client", bev));
+
+	bufferevent_setwatermark(bev, EV_READ, 0, ctx->wm_high);
+	bufferevent_setcb(bev, wm_transfer, NULL, wm_eventcb, ctx);
+	bufferevent_enable(bev, EV_READ|EV_WRITE);
+	ctx->bev = bev;
+
+	/* Only accept once, then disable ourself. */
+	evconnlistener_disable(listener);
+}
+static void
+regress_bufferevent_openssl_wm(void *arg)
+{
+	struct basic_test_data *data = arg;
+	struct event_base *base = data->base;
+
+	struct evconnlistener *listener;
+	struct bufferevent *bev;
+	struct sockaddr_in sin;
+	struct sockaddr_storage ss;
+	enum regress_openssl_type type =
+		(enum regress_openssl_type)data->setup_data;
+	int bev_flags = BEV_OPT_CLOSE_ON_FREE;
+	ev_socklen_t slen;
+	SSL *ssl;
+	struct wm_context client, server;
+	char *payload;
+	size_t payload_len = 1<<10;
+	size_t wm_high = 5<<10;
+
+	memset(&sin, 0, sizeof(sin));
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = htonl(0x7f000001);
+
+	memset(&ss, 0, sizeof(ss));
+	slen = sizeof(ss);
+
+	if (type & REGRESS_DEFERRED_CALLBACKS)
+		bev_flags |= BEV_OPT_DEFER_CALLBACKS;
+
+	memset(&client, 0, sizeof(client));
+	memset(&server, 0, sizeof(server));
+	client.server = 0;
+	server.server = 1;
+	client.flags = server.flags = bev_flags;
+	client.data = evbuffer_new();
+	server.data = evbuffer_new();
+	payload = calloc(1, payload_len);
+	memset(payload, 'A', payload_len);
+	evbuffer_add(server.data, payload, payload_len);
+	evbuffer_add(client.data, payload, payload_len);
+	client.wm_high = server.wm_high = wm_high;
+	client.limit = server.limit = wm_high<<3;
+	client.to_read = server.to_read = payload_len>>1;
+
+	TT_BLATHER(("openssl_wm: "
+		"payload_len = " EV_SIZE_FMT ", "
+		"wm_high = " EV_SIZE_FMT ", "
+		"limit = " EV_SIZE_FMT ", "
+		"to_read: " EV_SIZE_FMT "",
+		payload_len,
+		wm_high,
+		server.limit,
+		server.to_read));
+
+	listener = evconnlistener_new_bind(base, wm_acceptcb, &server,
+	    LEV_OPT_CLOSE_ON_FREE|LEV_OPT_REUSEABLE,
+	    -1, (struct sockaddr *)&sin, sizeof(sin));
+
+	tt_assert(listener);
+	tt_assert(evconnlistener_get_fd(listener) >= 0);
+
+	ssl = SSL_new(get_ssl_ctx());
+	tt_assert(ssl);
+
+	if (type & REGRESS_OPENSSL_FILTER) {
+		bev = bufferevent_socket_new(data->base, -1, client.flags);
+		tt_assert(bev);
+		bev = bufferevent_openssl_filter_new(
+			base, bev, ssl, BUFFEREVENT_SSL_CONNECTING, client.flags);
+	} else {
+		bev = bufferevent_openssl_socket_new(
+			data->base, -1, ssl,
+			BUFFEREVENT_SSL_CONNECTING,
+			client.flags);
+	}
+	tt_assert(bev);
+	client.bev = bev;
+
+	server.neighbour = &client;
+	client.neighbour = &server;
+
+	bufferevent_setwatermark(bev, EV_READ, 0, client.wm_high);
+	bufferevent_setcb(bev, wm_transfer, NULL, wm_eventcb, &client);
+
+	tt_assert(getsockname(evconnlistener_get_fd(listener),
+		(struct sockaddr*)&ss, &slen) == 0);
+
+	tt_assert(!bufferevent_socket_connect(bev, (struct sockaddr*)&ss, slen));
+	tt_assert(!evbuffer_add_buffer_reference(bufferevent_get_output(bev), client.data));
+	tt_assert(!bufferevent_enable(bev, EV_READ|EV_WRITE));
+
+	event_base_dispatch(base);
+
+	tt_int_op(client.get, ==, client.limit);
+	tt_int_op(server.get, ==, server.limit);
+
+end:
+	free(payload);
+	evbuffer_free(client.data);
+	evbuffer_free(server.data);
+	evconnlistener_free(listener);
+	bufferevent_free(client.bev);
+	bufferevent_free(server.bev);
+
+	/* XXX: by some reason otherise there is a leak */
+	if (!(type & REGRESS_OPENSSL_FILTER))
+		event_base_loop(base, EVLOOP_ONCE);
 }
 
 struct testcase_t ssl_testcases[] = {
 #define T(a) ((void *)(a))
 	{ "bufferevent_socketpair", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup, T(REGRESS_OPENSSL_SOCKETPAIR) },
+	  TT_ISOLATED, &ssl_setup, T(REGRESS_OPENSSL_SOCKETPAIR) },
 	{ "bufferevent_socketpair_write_after_connect", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR|REGRESS_OPENSSL_CLIENT_WRITE) },
 	{ "bufferevent_filter", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup, T(REGRESS_OPENSSL_FILTER) },
+	  TT_ISOLATED, &ssl_setup, T(REGRESS_OPENSSL_FILTER) },
 	{ "bufferevent_filter_write_after_connect", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER|REGRESS_OPENSSL_CLIENT_WRITE) },
 	{ "bufferevent_renegotiate_socketpair", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_RENEGOTIATE) },
 	{ "bufferevent_renegotiate_filter", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_RENEGOTIATE) },
 	{ "bufferevent_socketpair_startopen", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_OPEN) },
 	{ "bufferevent_filter_startopen", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_OPEN) },
 
 	{ "bufferevent_socketpair_dirty_shutdown", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_DIRTY_SHUTDOWN) },
 	{ "bufferevent_filter_dirty_shutdown", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_DIRTY_SHUTDOWN) },
 	{ "bufferevent_renegotiate_socketpair_dirty_shutdown",
 	  regress_bufferevent_openssl,
 	  TT_ISOLATED,
-	  &basic_setup,
+	  &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_RENEGOTIATE | REGRESS_OPENSSL_DIRTY_SHUTDOWN) },
 	{ "bufferevent_renegotiate_filter_dirty_shutdown",
 	  regress_bufferevent_openssl,
 	  TT_ISOLATED,
-	  &basic_setup,
+	  &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_RENEGOTIATE | REGRESS_OPENSSL_DIRTY_SHUTDOWN) },
 	{ "bufferevent_socketpair_startopen_dirty_shutdown",
 	  regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_OPEN | REGRESS_OPENSSL_DIRTY_SHUTDOWN) },
 	{ "bufferevent_filter_startopen_dirty_shutdown",
 	  regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_OPEN | REGRESS_OPENSSL_DIRTY_SHUTDOWN) },
 
 	{ "bufferevent_socketpair_fd", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_FD) },
 	{ "bufferevent_socketpair_freed", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_FREED) },
 	{ "bufferevent_socketpair_freed_fd", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_FREED | REGRESS_OPENSSL_FD) },
 	{ "bufferevent_filter_freed_fd", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_FILTER | REGRESS_OPENSSL_FREED | REGRESS_OPENSSL_FD) },
 
 	{ "bufferevent_socketpair_timeout", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_TIMEOUT) },
 	{ "bufferevent_socketpair_timeout_freed_fd", regress_bufferevent_openssl,
-	  TT_ISOLATED, &basic_setup,
+	  TT_ISOLATED, &ssl_setup,
 	  T(REGRESS_OPENSSL_SOCKETPAIR | REGRESS_OPENSSL_TIMEOUT | REGRESS_OPENSSL_FREED | REGRESS_OPENSSL_FD) },
 
 	{ "bufferevent_connect", regress_bufferevent_openssl_connect,
-	  TT_FORK|TT_NEED_BASE, &basic_setup, NULL },
+	  TT_FORK|TT_NEED_BASE, &ssl_setup, NULL },
 	{ "bufferevent_connect_sleep", regress_bufferevent_openssl_connect,
-	  TT_FORK|TT_NEED_BASE, &basic_setup, T(REGRESS_OPENSSL_SLEEP) },
+	  TT_FORK|TT_NEED_BASE, &ssl_setup, T(REGRESS_OPENSSL_SLEEP) },
+
+	{ "bufferevent_wm", regress_bufferevent_openssl_wm,
+	  TT_FORK|TT_NEED_BASE, &ssl_setup, NULL },
+	{ "bufferevent_wm_filter", regress_bufferevent_openssl_wm,
+	  TT_FORK|TT_NEED_BASE, &ssl_setup, T(REGRESS_OPENSSL_FILTER) },
+	{ "bufferevent_wm_defer", regress_bufferevent_openssl_wm,
+	  TT_FORK|TT_NEED_BASE, &ssl_setup, T(REGRESS_DEFERRED_CALLBACKS) },
+	{ "bufferevent_wm_filter_defer", regress_bufferevent_openssl_wm,
+	  TT_FORK|TT_NEED_BASE, &ssl_setup, T(REGRESS_OPENSSL_FILTER|REGRESS_DEFERRED_CALLBACKS) },
 
 #undef T
 
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_testutils.c b/ipc/chromium/src/third_party/libevent/test/regress_testutils.c
index 959347ea7160..b0ce7dbba2a6 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_testutils.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_testutils.c
@@ -110,7 +110,7 @@ regress_get_dnsserver(struct event_base *base,
 	memset(&my_addr, 0, sizeof(my_addr));
 	my_addr.sin_family = AF_INET;
 	my_addr.sin_port = htons(*portnum);
-	my_addr.sin_addr.s_addr = htonl(0x7f000001UL);
+	my_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
 	if (bind(sock, (struct sockaddr*)&my_addr, sizeof(my_addr)) < 0) {
 		evutil_closesocket(sock);
 		tt_abort_perror("bind");
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_thread.c b/ipc/chromium/src/third_party/libevent/test/regress_thread.c
index 689c23d1fb80..1e0ce41ff95e 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_thread.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_thread.c
@@ -564,8 +564,8 @@ end:
 	;
 }
 
-#define TEST(name)							\
-	{ #name, thread_##name, TT_FORK|TT_NEED_THREADS|TT_NEED_BASE,	\
+#define TEST(name, f)							\
+	{ #name, thread_##name, TT_FORK|TT_NEED_THREADS|TT_NEED_BASE|(f),	\
 	  &basic_setup, NULL }
 
 struct testcase_t thread_testcases[] = {
@@ -575,7 +575,7 @@ struct testcase_t thread_testcases[] = {
 	{ "forking", thread_basic, TT_FORK|TT_NEED_THREADS|TT_NEED_BASE,
 	  &basic_setup, (char*)"forking" },
 #endif
-	TEST(conditions_simple),
+	TEST(conditions_simple, TT_RETRIABLE),
 	{ "deferred_cb_skew", thread_deferred_cb_skew,
 	  TT_FORK|TT_NEED_THREADS|TT_OFF_BY_DEFAULT,
 	  &basic_setup, NULL },
@@ -583,7 +583,7 @@ struct testcase_t thread_testcases[] = {
 	/****** XXX TODO FIXME windows seems to be having some timing trouble,
 	 * looking into it now. / ellzey
 	 ******/
-	TEST(no_events),
+	TEST(no_events, TT_RETRIABLE),
 #endif
 	END_OF_TESTCASES
 };
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_thread.h b/ipc/chromium/src/third_party/libevent/test/regress_thread.h
index 831b51e50739..a954fefa5611 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_thread.h
+++ b/ipc/chromium/src/third_party/libevent/test/regress_thread.h
@@ -27,22 +27,30 @@
 #ifndef REGRESS_THREAD_H_INCLUDED_
 #define REGRESS_THREAD_H_INCLUDED_
 
-#ifdef EVENT__HAVE_PTHREADS
+#if defined(_WIN32) /** _WIN32 */
+#define THREAD_T void * /* HANDLE */
+#define THREAD_FN unsigned __stdcall
+#define THREAD_RETURN() return (0)
+#define THREAD_SELF() GetCurrentThreadId()
+#define THREAD_START(threadvar, fn, arg) do {                         \
+	uintptr_t threadhandle = _beginthreadex(NULL,0,fn,(arg),0,NULL);  \
+	(threadvar) = (THREAD_T)threadhandle;                             \
+	thread_setup(threadvar);                                          \
+} while (0)
+#define THREAD_JOIN(th) WaitForSingleObject(th, INFINITE)
+#else /* !_WIN32 */
+#include <pthread.h>
 #define THREAD_T pthread_t
 #define THREAD_FN void *
 #define THREAD_RETURN() return (NULL)
-#define THREAD_START(threadvar, fn, arg) \
-	pthread_create(&(threadvar), NULL, fn, arg)
+#define THREAD_SELF() pthread_self()
+#define THREAD_START(threadvar, fn, arg) do {          \
+	if (!pthread_create(&(threadvar), NULL, fn, arg))  \
+		thread_setup(threadvar);                       \
+} while (0)
 #define THREAD_JOIN(th) pthread_join(th, NULL)
-#else
-#define THREAD_T HANDLE
-#define THREAD_FN unsigned __stdcall
-#define THREAD_RETURN() return (0)
-#define THREAD_START(threadvar, fn, arg) do {		\
-	uintptr_t threadhandle = _beginthreadex(NULL,0,fn,(arg),0,NULL); \
-	(threadvar) = (HANDLE) threadhandle; \
-	} while (0)
-#define THREAD_JOIN(th) WaitForSingleObject(th, INFINITE)
-#endif
+#endif /* \!_WIN32 */
+
+void thread_setup(THREAD_T pthread);
 
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/test/regress_util.c b/ipc/chromium/src/third_party/libevent/test/regress_util.c
index ef6a1487aae2..45caa2700a40 100644
--- a/ipc/chromium/src/third_party/libevent/test/regress_util.c
+++ b/ipc/chromium/src/third_party/libevent/test/regress_util.c
@@ -23,6 +23,10 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+
+/** For event_debug() usage/coverage */
+#define EVENT_VISIBILITY_WANT_DLLIMPORT
+
 #include "../util-internal.h"
 
 #ifdef _WIN32
@@ -207,6 +211,65 @@ regress_ipv6_parse(void *ptr)
 #endif
 }
 
+static struct ipv6_entry_scope {
+	const char *addr;
+	ev_uint32_t res[4];
+	unsigned scope;
+	enum entry_status status;
+} ipv6_entries_scope[] = {
+	{ "2001:DB8::", { 0x20010db8, 0, 0 }, 0, NORMAL },
+	{ "2001:DB8::%0", { 0x20010db8, 0, 0, 0 }, 0, NORMAL },
+	{ "2001:DB8::%1", { 0x20010db8, 0, 0, 0 }, 1, NORMAL },
+	{ "foobar.", { 0, 0, 0, 0 }, 0, BAD },
+	{ "2001:DB8::%does-not-exist", { 0, 0, 0, 0 }, 0, BAD },
+	{ NULL, { 0, 0, 0, 0,  }, 0, BAD },
+};
+static void
+regress_ipv6_parse_scope(void *ptr)
+{
+#ifdef AF_INET6
+	int i, j;
+	unsigned if_scope;
+
+	for (i = 0; ipv6_entries_scope[i].addr; ++i) {
+		struct ipv6_entry_scope *ent = &ipv6_entries_scope[i];
+		struct in6_addr in6;
+		int r;
+		r = evutil_inet_pton_scope(AF_INET6, ent->addr, &in6,
+			&if_scope);
+		if (r == 0) {
+			if (ent->status != BAD)
+				TT_FAIL(("%s did not parse, but it's a good address!",
+					ent->addr));
+			continue;
+		}
+		if (ent->status == BAD) {
+			TT_FAIL(("%s parsed, but we expected an error", ent->addr));
+			continue;
+		}
+		for (j = 0; j < 4; ++j) {
+			/* Can't use s6_addr32 here; some don't have it. */
+			ev_uint32_t u =
+			    ((ev_uint32_t)in6.s6_addr[j*4  ] << 24) |
+			    ((ev_uint32_t)in6.s6_addr[j*4+1] << 16) |
+			    ((ev_uint32_t)in6.s6_addr[j*4+2] << 8) |
+			    ((ev_uint32_t)in6.s6_addr[j*4+3]);
+			if (u != ent->res[j]) {
+				TT_FAIL(("%s did not parse as expected.", ent->addr));
+				continue;
+			}
+		}
+		if (if_scope != ent->scope) {
+			TT_FAIL(("%s did not parse as expected.", ent->addr));
+			continue;
+		}
+	}
+#else
+	TT_BLATHER(("Skipping IPv6 address parsing."));
+#endif
+}
+
+
 static struct sa_port_ent {
 	const char *parse;
 	int safamily;
@@ -921,6 +984,16 @@ end:
 	;
 }
 
+static void
+test_EVUTIL_IS_(void *arg)
+{
+	tt_int_op(EVUTIL_ISDIGIT_('0'), ==, 1);
+	tt_int_op(EVUTIL_ISDIGIT_('a'), ==, 0);
+	tt_int_op(EVUTIL_ISDIGIT_('\xff'), ==, 0);
+end:
+	;
+}
+
 static void
 test_evutil_getaddrinfo(void *arg)
 {
@@ -1117,6 +1190,41 @@ end:
 		evutil_freeaddrinfo(ai);
 }
 
+static void
+test_evutil_getaddrinfo_AI_ADDRCONFIG(void *arg)
+{
+	struct evutil_addrinfo *ai = NULL;
+	struct evutil_addrinfo hints;
+	int r;
+
+	memset(&hints, 0, sizeof(hints));
+	hints.ai_family = AF_UNSPEC;
+	hints.ai_socktype = SOCK_STREAM;
+	hints.ai_flags = EVUTIL_AI_PASSIVE|EVUTIL_AI_ADDRCONFIG;
+
+	/* IPv4 */
+	r = evutil_getaddrinfo("127.0.0.1", "80", &hints, &ai);
+	tt_int_op(r, ==, 0);
+	tt_assert(ai);
+	tt_ptr_op(ai->ai_next, ==, NULL);
+	test_ai_eq(ai, "127.0.0.1:80", SOCK_STREAM, IPPROTO_TCP);
+	evutil_freeaddrinfo(ai);
+	ai = NULL;
+
+	/* IPv6 */
+	r = evutil_getaddrinfo("::1", "80", &hints, &ai);
+	tt_int_op(r, ==, 0);
+	tt_assert(ai);
+	tt_ptr_op(ai->ai_next, ==, NULL);
+	test_ai_eq(ai, "[::1]:80", SOCK_STREAM, IPPROTO_TCP);
+	evutil_freeaddrinfo(ai);
+	ai = NULL;
+
+end:
+	if (ai)
+		evutil_freeaddrinfo(ai);
+}
+
 #ifdef _WIN32
 static void
 test_evutil_loadsyslib(void *arg)
@@ -1412,10 +1520,12 @@ static struct date_rfc1123_case {
 	{  1289433600, "Thu, 11 Nov 2010 00:00:00 GMT"},
 	{  1323648000, "Mon, 12 Dec 2011 00:00:00 GMT"},
 #ifndef _WIN32
+#if EVENT__SIZEOF_TIME_T > 4
 	/** In win32 case we have max   "23:59:59 January 18, 2038, UTC" for time32 */
 	{  4294967296, "Sun, 07 Feb 2106 06:28:16 GMT"} /* 2^32 */,
 	/** In win32 case we have max "23:59:59, December 31, 3000, UTC" for time64 */
 	{253402300799, "Fri, 31 Dec 9999 23:59:59 GMT"} /* long long future no one can imagine */,
+#endif /* time_t != 32bit */
 	{  1456704000, "Mon, 29 Feb 2016 00:00:00 GMT"} /* leap year */,
 #endif
 	{  1435708800, "Wed, 01 Jul 2015 00:00:00 GMT"} /* leap second */,
@@ -1453,9 +1563,87 @@ end:
 	;
 }
 
+static void
+test_evutil_v4addr_is_local(void *arg)
+{
+	struct sockaddr_in sin;
+	sin.sin_family = AF_INET;
+
+	/* we use evutil_inet_pton() here to fill in network-byte order */
+#define LOCAL(str, yes) do {                                              \
+	tt_int_op(evutil_inet_pton(AF_INET, str, &sin.sin_addr), ==, 1);  \
+	tt_int_op(evutil_v4addr_is_local_(&sin.sin_addr), ==, yes);       \
+} while (0)
+
+	/** any */
+	sin.sin_addr.s_addr = INADDR_ANY;
+	tt_int_op(evutil_v4addr_is_local_(&sin.sin_addr), ==, 1);
+
+	/** loopback */
+	sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
+	tt_int_op(evutil_v4addr_is_local_(&sin.sin_addr), ==, 1);
+	LOCAL("127.0.0.1", 1);
+	LOCAL("127.255.255.255", 1);
+	LOCAL("121.0.0.1", 0);
+
+	/** link-local */
+	LOCAL("169.254.0.1", 1);
+	LOCAL("169.254.255.255", 1);
+	LOCAL("170.0.0.0", 0);
+
+	/** Multicast */
+	LOCAL("224.0.0.0", 1);
+	LOCAL("239.255.255.255", 1);
+	LOCAL("240.0.0.0", 0);
+end:
+	;
+}
+
+static void
+test_evutil_v6addr_is_local(void *arg)
+{
+	struct sockaddr_in6 sin6;
+	struct in6_addr anyaddr = IN6ADDR_ANY_INIT;
+	struct in6_addr loopback = IN6ADDR_LOOPBACK_INIT;
+
+	sin6.sin6_family = AF_INET6;
+#define LOCAL6(str, yes) do {                                              \
+	tt_int_op(evutil_inet_pton(AF_INET6, str, &sin6.sin6_addr), ==, 1);\
+	tt_int_op(evutil_v6addr_is_local_(&sin6.sin6_addr), ==, yes);      \
+} while (0)
+
+	/** any */
+	tt_int_op(evutil_v6addr_is_local_(&anyaddr), ==, 1);
+	LOCAL6("::0", 1);
+
+	/** loopback */
+	tt_int_op(evutil_v6addr_is_local_(&loopback), ==, 1);
+	LOCAL6("::1", 1);
+
+	/** IPV4 mapped */
+	LOCAL6("::ffff:0:0", 1);
+	/** IPv4 translated */
+	LOCAL6("::ffff:0:0:0", 1);
+	/** IPv4/IPv6 translation */
+	LOCAL6("64:ff9b::", 0);
+	/** Link-local */
+	LOCAL6("fe80::", 1);
+	/** Multicast */
+	LOCAL6("ff00::", 1);
+	/** Unspecified */
+	LOCAL6("::", 1);
+
+	/** Global Internet */
+	LOCAL6("2001::", 0);
+	LOCAL6("2001:4860:4802:32::1b", 0);
+end:
+	;
+}
+
 struct testcase_t util_testcases[] = {
 	{ "ipv4_parse", regress_ipv4_parse, 0, NULL, NULL },
 	{ "ipv6_parse", regress_ipv6_parse, 0, NULL, NULL },
+	{ "ipv6_parse_scope", regress_ipv6_parse_scope, 0, NULL, NULL },
 	{ "sockaddr_port_parse", regress_sockaddr_port_parse, 0, NULL, NULL },
 	{ "sockaddr_port_format", regress_sockaddr_port_format, 0, NULL, NULL },
 	{ "sockaddr_predicates", test_evutil_sockaddr_predicates, 0,NULL,NULL },
@@ -1468,22 +1656,26 @@ struct testcase_t util_testcases[] = {
 	{ "upcast", test_evutil_upcast, 0, NULL, NULL },
 	{ "integers", test_evutil_integers, 0, NULL, NULL },
 	{ "rand", test_evutil_rand, TT_FORK, NULL, NULL },
+	{ "EVUTIL_IS_", test_EVUTIL_IS_, 0, NULL, NULL },
 	{ "getaddrinfo", test_evutil_getaddrinfo, TT_FORK, NULL, NULL },
 	{ "getaddrinfo_live", test_evutil_getaddrinfo_live, TT_FORK|TT_OFF_BY_DEFAULT, NULL, NULL },
+	{ "getaddrinfo_AI_ADDRCONFIG", test_evutil_getaddrinfo_AI_ADDRCONFIG, TT_FORK|TT_OFF_BY_DEFAULT, NULL, NULL },
 #ifdef _WIN32
 	{ "loadsyslib", test_evutil_loadsyslib, TT_FORK, NULL, NULL },
 #endif
 	{ "mm_malloc", test_event_malloc, 0, NULL, NULL },
 	{ "mm_calloc", test_event_calloc, 0, NULL, NULL },
 	{ "mm_strdup", test_event_strdup, 0, NULL, NULL },
-	{ "usleep", test_evutil_usleep, 0, NULL, NULL },
+	{ "usleep", test_evutil_usleep, TT_RETRIABLE, NULL, NULL },
 	{ "monotonic_res", test_evutil_monotonic_res, 0, &basic_setup, (void*)"" },
 	{ "monotonic_res_precise", test_evutil_monotonic_res, TT_OFF_BY_DEFAULT, &basic_setup, (void*)"precise" },
 	{ "monotonic_res_fallback", test_evutil_monotonic_res, TT_OFF_BY_DEFAULT, &basic_setup, (void*)"fallback" },
 	{ "monotonic_prc", test_evutil_monotonic_prc, 0, &basic_setup, (void*)"" },
-	{ "monotonic_prc_precise", test_evutil_monotonic_prc, 0, &basic_setup, (void*)"precise" },
+	{ "monotonic_prc_precise", test_evutil_monotonic_prc, TT_RETRIABLE, &basic_setup, (void*)"precise" },
 	{ "monotonic_prc_fallback", test_evutil_monotonic_prc, 0, &basic_setup, (void*)"fallback" },
 	{ "date_rfc1123", test_evutil_date_rfc1123, 0, NULL, NULL },
+	{ "evutil_v4addr_is_local", test_evutil_v4addr_is_local, 0, NULL, NULL },
+	{ "evutil_v6addr_is_local", test_evutil_v6addr_is_local, 0, NULL, NULL },
 	END_OF_TESTCASES,
 };
 
diff --git a/ipc/chromium/src/third_party/libevent/test/rpcgen_wrapper.sh b/ipc/chromium/src/third_party/libevent/test/rpcgen_wrapper.sh
index aaa03031a1f6..fe582d57bd33 100755
--- a/ipc/chromium/src/third_party/libevent/test/rpcgen_wrapper.sh
+++ b/ipc/chromium/src/third_party/libevent/test/rpcgen_wrapper.sh
@@ -25,19 +25,10 @@ exit_failed() {
     echo "Could not generate regress.gen.\[ch\] using event_rpcgen.sh" >&2
     exit 1
 }
-
-if [ -x /usr/bin/python2 ] ; then
-  PYTHON2=/usr/bin/python2
-elif [ "x`which python2`" != x ] ; then
-  PYTHON2=python2
-else
-  PYTHON2=python
-fi
-
 srcdir=$1
 srcdir=${srcdir:-.}
 
-${PYTHON2} ${srcdir}/../event_rpcgen.py --quiet ${srcdir}/regress.rpc \
+${srcdir}/../event_rpcgen.py --quiet ${srcdir}/regress.rpc \
                test/regress.gen.h test/regress.gen.c
 
 case "$?" in
diff --git a/ipc/chromium/src/third_party/libevent/test/test-changelist.c b/ipc/chromium/src/third_party/libevent/test/test-changelist.c
index 6e2466d5a55c..fd1a17f5bd59 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-changelist.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-changelist.c
@@ -182,11 +182,11 @@ main(int argc, char **argv)
 	if (evutil_socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)
 		return (1);
 
-	/* Initalize the event library */
+	/* Initialize the event library */
 	if (!(base = event_base_new()))
 		return (1);
 
-	/* Initalize a timeout to terminate the test */
+	/* Initialize a timeout to terminate the test */
 	timeout = evtimer_new(base,timeout_cb,&timeout);
 	/* and watch for writability on one end of the pipe */
 	ev = event_new(base,pair[1],EV_WRITE | EV_PERSIST, write_cb, &ev);
diff --git a/ipc/chromium/src/third_party/libevent/test/test-closed.c b/ipc/chromium/src/third_party/libevent/test/test-closed.c
index 1dd988592d2a..9e6050408d64 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-closed.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-closed.c
@@ -104,6 +104,7 @@ main(int argc, char **argv)
 	event_base_dispatch(base);
 
 	/* Finalize library */
+	event_free(ev);
 	event_base_free(base);
 	return 0;
 }
diff --git a/ipc/chromium/src/third_party/libevent/test/test-eof.c b/ipc/chromium/src/third_party/libevent/test/test-eof.c
index 284ead78ae34..de2fd88b991e 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-eof.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-eof.c
@@ -102,10 +102,10 @@ main(int argc, char **argv)
 		return (1);
 	shutdown(pair[0], EVUTIL_SHUT_WR);
 
-	/* Initalize the event library */
+	/* Initialize the event library */
 	event_init();
 
-	/* Initalize one event */
+	/* Initialize one event */
 	event_set(&ev, pair[1], EV_READ | EV_TIMEOUT, read_cb, &ev);
 
 	event_add(&ev, &timeout);
diff --git a/ipc/chromium/src/third_party/libevent/test/test-fdleak.c b/ipc/chromium/src/third_party/libevent/test/test-fdleak.c
index 4c4eba25e70e..a1fb4ed13bd2 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-fdleak.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-fdleak.c
@@ -95,8 +95,11 @@ server_event_cb(struct bufferevent *bev, short events, void *ctx)
 	if (events & BEV_EVENT_ERROR) {
 		my_perror("Error from bufferevent");
 		exit(1);
-	} else if (events & (BEV_EVENT_EOF | BEV_EVENT_ERROR)) {
+	} else if (events & BEV_EVENT_EOF) {
 		bufferevent_free(bev);
+		if (num_requests == MAX_REQUESTS) {
+			event_base_loopbreak(bufferevent_get_base(bev));
+		}
 	}
 }
 
@@ -107,8 +110,7 @@ listener_accept_cb(struct evconnlistener *listener, evutil_socket_t sock,
 {
 	struct event_base *base = evconnlistener_get_base(listener);
 	struct bufferevent *bev = bufferevent_socket_new(base, sock,
-                                                         BEV_OPT_CLOSE_ON_FREE);
-
+		BEV_OPT_CLOSE_ON_FREE);
 	bufferevent_setcb(bev, server_read_cb, NULL, server_event_cb, NULL);
 	bufferevent_enable(bev, EV_READ|EV_WRITE);
 }
@@ -154,6 +156,9 @@ start_loop(void)
 	start_client(base);
 
 	event_base_dispatch(base);
+
+	evconnlistener_free(listener);
+	event_base_free(base);
 }
 
 /*
@@ -178,9 +183,7 @@ client_read_cb(struct bufferevent *bev, void *ctx)
 	bufferevent_free(bev);
 
 	num_requests++;
-	if (num_requests == MAX_REQUESTS) {
-		event_base_loopbreak(base);
-	} else {
+	if (++num_requests < MAX_REQUESTS) {
 		start_client(base);
 	}
 }
diff --git a/ipc/chromium/src/third_party/libevent/test/test-init.c b/ipc/chromium/src/third_party/libevent/test/test-init.c
index 92fbc6b14659..aea49ee94288 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-init.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-init.c
@@ -57,7 +57,7 @@ main(int argc, char **argv)
 	(void) WSAStartup(wVersionRequested, &wsaData);
 #endif
 
-	/* Initalize the event library */
+	/* Initialize the event library */
 	event_init();
 
 	return (0);
diff --git a/ipc/chromium/src/third_party/libevent/test/test-ratelim.c b/ipc/chromium/src/third_party/libevent/test/test-ratelim.c
index 9ee989bd820e..34112e39e14d 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-ratelim.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-ratelim.c
@@ -50,6 +50,10 @@
 #include "event2/listener.h"
 #include "event2/thread.h"
 
+#ifndef MIN
+#define MIN(a,b) (((a)<(b))?(a):(b))
+#endif
+
 static struct evutil_weakrand_state weakrand_state;
 
 static int cfg_verbose = 0;
@@ -85,6 +89,18 @@ struct client_state {
 };
 static const struct timeval *ms100_common=NULL;
 
+/* Timers bias for slow CPUs, affects:
+ * - cfg_connlimit_tolerance  (--check-connlimit)
+ * - cfg_grouplimit_tolerance (--check-grouplimit)
+ * - cfg_stddev_tolerance     (--check-stddev)
+ */
+static int timer_bias_events;
+static struct timeval timer_bias_start;
+double timer_bias_spend;
+/* Real cost is less (approximately ~5 usec),
+ * this macros adjusted to make the bias less */
+#define TIMER_MAX_COST_USEC 10
+
 /* info from check_bucket_levels_cb */
 static int total_n_bev_checks = 0;
 static ev_int64_t total_rbucket_level=0;
@@ -244,6 +260,64 @@ group_drain_cb(evutil_socket_t fd, short events, void *arg)
 	bufferevent_rate_limit_group_decrement_write(ratelim_group, cfg_group_drain);
 }
 
+static void
+timer_bias_cb(evutil_socket_t fd, short events, void *arg)
+{
+	struct event *event = arg;
+	struct timeval end;
+	struct timeval diff;
+
+	/** XXX: use rdtsc? (portability issues?) */
+	evutil_gettimeofday(&end, NULL);
+	evutil_timersub(&end, &timer_bias_start, &diff);
+	timer_bias_spend += diff.tv_sec + diff.tv_usec * 1e6;
+	timer_bias_start = end;
+
+	if (++timer_bias_events == 100)
+		event_del(event);
+}
+static double
+timer_bias_calculate(void)
+{
+	struct event_config *cfg = NULL;
+	struct event_base *base = NULL;
+	struct event *timer = NULL;
+	struct timeval tv = { 0, 1 };
+	int done = 0;
+
+	cfg = event_config_new();
+	if (!cfg)
+		goto err;
+	if (event_config_set_flag(cfg, EVENT_BASE_FLAG_PRECISE_TIMER))
+		goto err;
+	base = event_base_new_with_config(cfg);
+	if (!base)
+		goto err;
+
+	timer = event_new(base, -1, EV_PERSIST, timer_bias_cb, event_self_cbarg());
+	if (!timer || event_add(timer, &tv)) {
+		goto err;
+	}
+
+	evutil_gettimeofday(&timer_bias_start, NULL);
+	event_base_dispatch(base);
+	done = 1;
+
+err:
+	if (cfg)
+		event_config_free(cfg);
+	if (timer)
+		event_free(timer);
+	if (base)
+		event_base_free(base);
+
+	if (done)
+		return MIN(timer_bias_spend / 1e6 / timer_bias_events / TIMER_MAX_COST_USEC, 5);
+
+	fprintf(stderr, "Couldn't create event for CPU cycle counter bias\n");
+	return -1;
+}
+
 static int
 test_ratelimiting(void)
 {
@@ -266,6 +340,7 @@ test_ratelimiting(void)
 	struct event_config *base_cfg;
 	struct event *periodic_level_check;
 	struct event *group_drain_event=NULL;
+	double timer_bias;
 
 	memset(&sin, 0, sizeof(sin));
 	sin.sin_family = AF_INET;
@@ -275,6 +350,16 @@ test_ratelimiting(void)
 	if (0)
 		event_enable_debug_mode();
 
+	timer_bias = timer_bias_calculate();
+	if (timer_bias > 1) {
+		fprintf(stderr, "CPU is slow, timers bias is %f\n", timer_bias);
+		cfg_connlimit_tolerance  *= timer_bias;
+		cfg_grouplimit_tolerance *= timer_bias;
+		cfg_stddev_tolerance     *= timer_bias;
+	} else {
+		printf("CPU is fast enough, timers bias is %f\n", timer_bias);
+	}
+
 	base_cfg = event_config_new();
 
 #ifdef _WIN32
@@ -376,7 +461,7 @@ test_ratelimiting(void)
 	ratelim_group = NULL; /* So no more responders get added */
 	event_free(periodic_level_check);
 	if (group_drain_event)
-		event_del(group_drain_event);
+		event_free(group_drain_event);
 
 	for (i = 0; i < cfg_n_connections; ++i) {
 		bufferevent_free(bevs[i]);
diff --git a/ipc/chromium/src/third_party/libevent/test/test-time.c b/ipc/chromium/src/third_party/libevent/test/test-time.c
index c4d031e72d62..a8b384626385 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-time.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-time.c
@@ -81,8 +81,10 @@ time_cb(evutil_socket_t fd, short event, void *arg)
 int
 main(int argc, char **argv)
 {
+	struct event_base *base;
 	struct timeval tv;
 	int i;
+
 #ifdef _WIN32
 	WORD wVersionRequested;
 	WSADATA wsaData;
@@ -94,23 +96,28 @@ main(int argc, char **argv)
 
 	evutil_weakrand_seed_(&weakrand_state, 0);
 
-	/* Initalize the event library */
-	event_init();
+	if (getenv("EVENT_DEBUG_LOGGING_ALL")) {
+		event_enable_debug_logging(EVENT_DBG_ALL);
+	}
 
-	for (i = 0; i < NEVENT; i++) {
-		ev[i] = malloc(sizeof(struct event));
+	base = event_base_new();
 
-		/* Initalize one event */
-		evtimer_set(ev[i], time_cb, ev[i]);
+	for (i = 0; i < NEVENT; i++) {
+		ev[i] = evtimer_new(base, time_cb, event_self_cbarg());
 		tv.tv_sec = 0;
 		tv.tv_usec = rand_int(50000);
 		evtimer_add(ev[i], &tv);
 	}
 
-	event_dispatch();
+	i = event_base_dispatch(base);
 
+	printf("event_base_dispatch=%d, called=%d, EVENT=%d\n",
+		i, called, NEVENT);
 
-	printf("%d, %d\n", called, NEVENT);
-	return (called < NEVENT);
+	if (i == 1 && called >= NEVENT) {
+		return EXIT_SUCCESS;
+	} else {
+		return EXIT_FAILURE;
+	}
 }
 
diff --git a/ipc/chromium/src/third_party/libevent/test/test-weof.c b/ipc/chromium/src/third_party/libevent/test/test-weof.c
index 52c7afbd65b9..68e7cd45792d 100644
--- a/ipc/chromium/src/third_party/libevent/test/test-weof.c
+++ b/ipc/chromium/src/third_party/libevent/test/test-weof.c
@@ -99,10 +99,10 @@ main(int argc, char **argv)
 	if (evutil_socketpair(AF_UNIX, SOCK_STREAM, 0, pair) == -1)
 		return (1);
 
-	/* Initalize the event library */
+	/* Initialize the event library */
 	event_init();
 
-	/* Initalize one event */
+	/* Initialize one event */
 	event_set(&ev, pair[1], EV_WRITE, write_cb, &ev);
 
 	event_add(&ev, NULL);
diff --git a/ipc/chromium/src/third_party/libevent/test/test.sh b/ipc/chromium/src/third_party/libevent/test/test.sh
index dd3d98673cf2..f91a8b044598 100755
--- a/ipc/chromium/src/third_party/libevent/test/test.sh
+++ b/ipc/chromium/src/third_party/libevent/test/test.sh
@@ -82,8 +82,8 @@ run_tests () {
 		fi
 	done
 	announce_n " test-dumpevents: "
-	if python2 -c 'import sys; assert(sys.version_info >= (2, 4))' 2>/dev/null && test -f $TEST_SRC_DIR/check-dumpevents.py; then
-	    if $TEST_DIR/test-dumpevents | python2 $TEST_SRC_DIR/check-dumpevents.py >> "$TEST_OUTPUT_FILE" ;
+	if python -c 'import sys; assert(sys.version_info >= (2, 4))' 2>/dev/null && test -f $TEST_SRC_DIR/check-dumpevents.py; then
+	    if $TEST_DIR/test-dumpevents | $TEST_SRC_DIR/check-dumpevents.py >> "$TEST_OUTPUT_FILE" ;
 	    then
 	        announce OKAY ;
 	    else
diff --git a/ipc/chromium/src/third_party/libevent/test/tinytest.c b/ipc/chromium/src/third_party/libevent/test/tinytest.c
index 3a8e33105501..85dfe74a720e 100644
--- a/ipc/chromium/src/third_party/libevent/test/tinytest.c
+++ b/ipc/chromium/src/third_party/libevent/test/tinytest.c
@@ -60,6 +60,8 @@
 #include "tinytest_macros.h"
 
 #define LONGEST_TEST_NAME 16384
+#define DEFAULT_TESTCASE_TIMEOUT 30U
+#define MAGIC_EXITCODE 42
 
 static int in_tinytest_main = 0; /**< true if we're in tinytest_main().*/
 static int n_ok = 0; /**< Number of tests that have passed */
@@ -69,6 +71,7 @@ static int n_skipped = 0; /**< Number of tests that have been skipped. */
 static int opt_forked = 0; /**< True iff we're called from inside a win32 fork*/
 static int opt_nofork = 0; /**< Suppress calls to fork() for debugging. */
 static int opt_verbosity = 1; /**< -==quiet,0==terse,1==normal,2==verbose */
+static unsigned int opt_timeout = DEFAULT_TESTCASE_TIMEOUT; /**< Timeout for every test (using alarm()) */
 const char *verbosity_flag = "";
 
 const struct testlist_alias_t *cfg_aliases=NULL;
@@ -79,14 +82,73 @@ const char *cur_test_prefix = NULL; /**< prefix of the current test group */
 /** Name of the current test, if we haven't logged is yet. Used for --quiet */
 const char *cur_test_name = NULL;
 
+static void usage(struct testgroup_t *groups, int list_groups)
+	__attribute__((noreturn));
+static int process_test_option(struct testgroup_t *groups, const char *test);
+
 #ifdef _WIN32
 /* Copy of argv[0] for win32. */
 static char commandname[MAX_PATH+1];
-#endif
 
-static void usage(struct testgroup_t *groups, int list_groups)
-  __attribute__((noreturn));
-static int process_test_option(struct testgroup_t *groups, const char *test);
+struct timeout_thread_args {
+	const testcase_fn *fn;
+	void *env;
+};
+
+static DWORD WINAPI
+timeout_thread_proc_(LPVOID arg)
+{
+	struct timeout_thread_args *args = arg;
+	(*(args->fn))(args->env);
+	ExitThread(cur_test_outcome == FAIL ? 1 : 0);
+}
+
+static enum outcome
+testcase_run_in_thread_(const struct testcase_t *testcase, void *env)
+{
+	/* We will never run testcase in a new thread when the
+	timeout is set to zero */
+	assert(opt_timeout);
+	DWORD ret, tid;
+	HANDLE handle;
+	struct timeout_thread_args args = {
+		&(testcase->fn),
+		env
+	};
+
+	handle =CreateThread(NULL, 0, timeout_thread_proc_,
+		(LPVOID)&args, 0, &tid);
+	ret = WaitForSingleObject(handle, opt_timeout * 1000U);
+	if (ret == WAIT_OBJECT_0) {
+		ret = 0;
+		if (!GetExitCodeThread(handle, &ret)) {
+			printf("GetExitCodeThread failed\n");
+			ret = 1;
+		}
+	} else if (ret == WAIT_TIMEOUT)	{
+		printf("timeout\n");
+	} else {
+		printf("Wait failed\n");
+	}
+	CloseHandle(handle);
+	if (ret == 0)
+		return OK;
+	else if (ret == MAGIC_EXITCODE)
+		return SKIP;
+	else
+		return FAIL;
+}
+#else
+static unsigned int testcase_set_timeout_(void)
+{
+	return alarm(opt_timeout);
+}
+
+static unsigned int testcase_reset_timeout_(void)
+{
+	return alarm(0);
+}
+#endif
 
 static enum outcome
 testcase_run_bare_(const struct testcase_t *testcase)
@@ -102,7 +164,19 @@ testcase_run_bare_(const struct testcase_t *testcase)
 	}
 
 	cur_test_outcome = OK;
-	testcase->fn(env);
+	{
+		if (opt_timeout) {
+#ifdef _WIN32
+			cur_test_outcome = testcase_run_in_thread_(testcase, env);
+#else
+			testcase_set_timeout_();
+			testcase->fn(env);
+			testcase_reset_timeout_();
+#endif
+		} else {
+			testcase->fn(env);
+		}
+	}
 	outcome = cur_test_outcome;
 
 	if (testcase->setup) {
@@ -113,7 +187,6 @@ testcase_run_bare_(const struct testcase_t *testcase)
 	return outcome;
 }
 
-#define MAGIC_EXITCODE 42
 
 #ifndef NO_FORKING
 
@@ -134,7 +207,7 @@ testcase_run_forked_(const struct testgroup_t *group,
 	char buffer[LONGEST_TEST_NAME+256];
 	STARTUPINFOA si;
 	PROCESS_INFORMATION info;
-	DWORD exitcode;
+	DWORD ret;
 
 	if (!in_tinytest_main) {
 		printf("\nERROR.  On Windows, testcase_run_forked_ must be"
@@ -144,7 +217,7 @@ testcase_run_forked_(const struct testgroup_t *group,
 	if (opt_verbosity>0)
 		printf("[forking] ");
 
-	snprintf(buffer, sizeof(buffer), "%s --RUNNING-FORKED %s %s%s",
+	snprintf(buffer, sizeof(buffer), "%s --RUNNING-FORKED %s --timeout 0 %s%s",
 		 commandname, verbosity_flag, group->prefix, testcase->name);
 
 	memset(&si, 0, sizeof(si));
@@ -155,15 +228,23 @@ testcase_run_forked_(const struct testgroup_t *group,
 			   0, NULL, NULL, &si, &info);
 	if (!ok) {
 		printf("CreateProcess failed!\n");
-		return 0;
+		return FAIL;
+	}
+	ret = WaitForSingleObject(info.hProcess,
+		(opt_timeout ? opt_timeout * 1000U : INFINITE));
+
+	if (ret == WAIT_OBJECT_0) {
+		GetExitCodeProcess(info.hProcess, &ret);
+	} else if (ret == WAIT_TIMEOUT) {
+		printf("timeout\n");
+	} else {
+		printf("Wait failed\n");
 	}
-	WaitForSingleObject(info.hProcess, INFINITE);
-	GetExitCodeProcess(info.hProcess, &exitcode);
 	CloseHandle(info.hProcess);
 	CloseHandle(info.hThread);
-	if (exitcode == 0)
+	if (ret == 0)
 		return OK;
-	else if (exitcode == MAGIC_EXITCODE)
+	else if (ret == MAGIC_EXITCODE)
 		return SKIP;
 	else
 		return FAIL;
@@ -198,7 +279,7 @@ testcase_run_forked_(const struct testgroup_t *group,
 		return FAIL; /* unreachable */
 	} else {
 		/* parent */
-		int status, r;
+		int status, r, exitcode;
 		char b[1];
 		/* Close this now, so that if the other side closes it,
 		 * our read fails. */
@@ -206,12 +287,20 @@ testcase_run_forked_(const struct testgroup_t *group,
 		r = (int)read(outcome_pipe[0], b, 1);
 		if (r == 0) {
 			printf("[Lost connection!] ");
-			return 0;
+			return FAIL;
 		} else if (r != 1) {
 			perror("read outcome from pipe");
 		}
 		waitpid(pid, &status, 0);
+		exitcode = WEXITSTATUS(status);
 		close(outcome_pipe[0]);
+		if (opt_verbosity>1)
+			printf("%s%s: exited with %i (%i)\n", group->prefix, testcase->name, exitcode, status);
+		if (exitcode != 0)
+		{
+			printf("[atexit failure!] ");
+			return FAIL;
+		}
 		return b[0]=='Y' ? OK : (b[0]=='S' ? SKIP : FAIL);
 	}
 #endif
@@ -253,15 +342,12 @@ testcase_run_one(const struct testgroup_t *group,
 	}
 
 	if (outcome == OK) {
-		++n_ok;
 		if (opt_verbosity>0 && !opt_forked)
 			puts(opt_verbosity==1?"OK":"");
 	} else if (outcome == SKIP) {
-		++n_skipped;
 		if (opt_verbosity>0 && !opt_forked)
 			puts("SKIPPED");
 	} else {
-		++n_bad;
 		if (!opt_forked)
 			printf("\n  [%s FAILED]\n", testcase->name);
 	}
@@ -312,7 +398,7 @@ tinytest_set_flag_(struct testgroup_t *groups, const char *arg, int set, unsigne
 static void
 usage(struct testgroup_t *groups, int list_groups)
 {
-	puts("Options are: [--verbose|--quiet|--terse] [--no-fork]");
+	puts("Options are: [--verbose|--quiet|--terse] [--no-fork] [--timeout <sec>]");
 	puts("  Specify tests by name, or using a prefix ending with '..'");
 	puts("  To skip a test, prefix its name with a colon.");
 	puts("  To enable a disabled test, prefix its name with a plus.");
@@ -409,8 +495,15 @@ tinytest_main(int c, const char **v, struct testgroup_t *groups)
 				usage(groups, 0);
 			} else if (!strcmp(v[i], "--list-tests")) {
 				usage(groups, 1);
+			} else if (!strcmp(v[i], "--timeout")) {
+				++i;
+				if (i >= c) {
+					fprintf(stderr, "--timeout requires argument\n");
+					return -1;
+				}
+				opt_timeout = (unsigned)atoi(v[i]);
 			} else {
-				printf("Unknown option %s.  Try --help\n",v[i]);
+				fprintf(stderr, "Unknown option %s. Try --help\n", v[i]);
 				return -1;
 			}
 		} else {
@@ -428,11 +521,35 @@ tinytest_main(int c, const char **v, struct testgroup_t *groups)
 #endif
 
 	++in_tinytest_main;
-	for (i=0; groups[i].prefix; ++i)
-		for (j=0; groups[i].cases[j].name; ++j)
-			if (groups[i].cases[j].flags & TT_ENABLED_)
-				testcase_run_one(&groups[i],
-						 &groups[i].cases[j]);
+	for (i = 0; groups[i].prefix; ++i) {
+		struct testgroup_t *group = &groups[i];
+		for (j = 0; group->cases[j].name; ++j) {
+			struct testcase_t *testcase = &group->cases[j];
+			int test_attempts = 3;
+			int test_ret_err;
+
+			if (!(testcase->flags & TT_ENABLED_))
+				continue;
+
+			for (;;) {
+				test_ret_err = testcase_run_one(group, testcase);
+
+				if (test_ret_err == OK)
+					break;
+				if (!(testcase->flags & TT_RETRIABLE))
+					break;
+				printf("\n  [RETRYING %s (%i)]\n", testcase->name, test_attempts);
+				if (!test_attempts--)
+					break;
+			}
+
+			switch (test_ret_err) {
+				case OK:   ++n_ok;      break;
+				case SKIP: ++n_skipped; break;
+				default:   ++n_bad;     break;
+			}
+		}
+	}
 
 	--in_tinytest_main;
 
@@ -462,7 +579,7 @@ tinytest_set_test_failed_(void)
 		printf("%s%s: ", cur_test_prefix, cur_test_name);
 		cur_test_name = NULL;
 	}
-	cur_test_outcome = 0;
+	cur_test_outcome = FAIL;
 }
 
 void
diff --git a/ipc/chromium/src/third_party/libevent/test/tinytest.h b/ipc/chromium/src/third_party/libevent/test/tinytest.h
index ed07b26bc006..d321dd467542 100644
--- a/ipc/chromium/src/third_party/libevent/test/tinytest.h
+++ b/ipc/chromium/src/third_party/libevent/test/tinytest.h
@@ -34,8 +34,11 @@
 #define TT_ENABLED_  (1<<2)
 /** Flag for a test that's off by default. */
 #define TT_OFF_BY_DEFAULT  (1<<3)
+/** Flag for a test that should be runned again in case of failure (but not
+ * more then 3 times). */
+#define TT_RETRIABLE	(1<<4)
 /** If you add your own flags, make them start at this point. */
-#define TT_FIRST_USER_FLAG (1<<4)
+#define TT_FIRST_USER_FLAG (1<<5)
 
 typedef void (*testcase_fn)(void *);
 
diff --git a/ipc/chromium/src/third_party/libevent/test/tinytest_demo.c b/ipc/chromium/src/third_party/libevent/test/tinytest_demo.c
index f6bfd66a1a1f..123855fff7fe 100644
--- a/ipc/chromium/src/third_party/libevent/test/tinytest_demo.c
+++ b/ipc/chromium/src/third_party/libevent/test/tinytest_demo.c
@@ -192,6 +192,32 @@ test_timeout(void *ptr)
 	;
 }
 
+void
+test_timeout_retry(void *ptr)
+{
+	static int i = 0;
+
+	++i;
+	tt_int_op(i, !=, 1);
+
+	time_t t1, t2;
+	(void)ptr;
+	t1 = time(NULL);
+#ifdef _WIN32
+	Sleep(5000);
+#else
+	sleep(5);
+#endif
+	t2 = time(NULL);
+
+	tt_int_op(t2-t1, >=, 4);
+
+	tt_int_op(t2-t1, <=, 6);
+
+ end:
+	;
+}
+
 /* ============================================================ */
 
 /* Now we need to make sure that our tests get invoked.	  First, you take
@@ -212,6 +238,10 @@ struct testcase_t demo_tests[] = {
 	 * can enable it manually by passing +demo/timeout at the command line.*/
 	{ "timeout", test_timeout, TT_OFF_BY_DEFAULT },
 
+	/* This test will be retried. (and it will not pass from the first
+	 * time) */
+	{ "timeout_retry", test_timeout_retry, TT_RETRIABLE },
+
 	/* The array has to end with END_OF_TESTCASES. */
 	END_OF_TESTCASES
 };
diff --git a/ipc/chromium/src/third_party/libevent/test/tinytest_macros.h b/ipc/chromium/src/third_party/libevent/test/tinytest_macros.h
index 2c02a741b164..e01f5d56cb33 100644
--- a/ipc/chromium/src/third_party/libevent/test/tinytest_macros.h
+++ b/ipc/chromium/src/third_party/libevent/test/tinytest_macros.h
@@ -113,8 +113,8 @@
 #define tt_assert_test_fmt_type(a,b,str_test,type,test,printf_type,printf_fmt, \
     setup_block,cleanup_block,die_on_fail)				\
 	TT_STMT_BEGIN							\
-	type val1_ = (a);						\
-	type val2_ = (b);						\
+	type val1_ = (type)(a);						\
+	type val2_ = (type)(b);						\
 	int tt_status_ = (test);					\
 	if (!tt_status_ || tinytest_get_verbosity_()>1)	{		\
 		printf_type print_;					\
@@ -158,6 +158,14 @@
 	tt_assert_test_type(a,b,#a" "#op" "#b,long,(val1_ op val2_), \
 	    "%ld",TT_EXIT_TEST_FUNCTION)
 
+/** To compare SOCKET(windows)/fd */
+#define tt_fd_op(a,op,b) do {                                          \
+	int _a = (int)(a);                                             \
+	int _b = (int)(b);                                             \
+	tt_assert_test_type(_a,_b,#a" "#op" "#b,long,(val1_ op val2_), \
+	    "%ld",TT_EXIT_TEST_FUNCTION);                              \
+} while (0)
+
 #define tt_uint_op(a,op,b)						\
 	tt_assert_test_type(a,b,#a" "#op" "#b,unsigned long,		\
 	    (val1_ op val2_),"%lu",TT_EXIT_TEST_FUNCTION)
diff --git a/ipc/chromium/src/third_party/libevent/time-internal.h b/ipc/chromium/src/third_party/libevent/time-internal.h
index 2c584fa75263..e79e6a528dee 100644
--- a/ipc/chromium/src/third_party/libevent/time-internal.h
+++ b/ipc/chromium/src/third_party/libevent/time-internal.h
@@ -54,6 +54,7 @@ extern "C" {
 #endif
 
 long evutil_tv_to_msec_(const struct timeval *tv);
+EVENT2_EXPORT_SYMBOL
 void evutil_usleep_(const struct timeval *tv);
 
 #ifdef _WIN32
@@ -86,8 +87,10 @@ struct evutil_monotonic_timer {
 	struct timeval last_time;
 };
 
+EVENT2_EXPORT_SYMBOL
 int evutil_configure_monotonic_time_(struct evutil_monotonic_timer *mt,
     int flags);
+EVENT2_EXPORT_SYMBOL
 int evutil_gettime_monotonic_(struct evutil_monotonic_timer *mt, struct timeval *tv);
 
 
diff --git a/ipc/chromium/src/third_party/libevent/util-internal.h b/ipc/chromium/src/third_party/libevent/util-internal.h
index 38d0f595fb75..39576c71ca22 100644
--- a/ipc/chromium/src/third_party/libevent/util-internal.h
+++ b/ipc/chromium/src/third_party/libevent/util-internal.h
@@ -50,12 +50,40 @@
 extern "C" {
 #endif
 
+/* __has_attribute() wrapper */
+#ifdef __has_attribute
+# define EVUTIL_HAS_ATTRIBUTE __has_attribute
+#endif
+/** clang 3 __has_attribute misbehaves in some versions */
+#if defined(__clang__) && __clang__ == 1
+# if defined(__apple_build_version__)
+#  if __clang_major__ <= 6
+#   undef EVUTIL_HAS_ATTRIBUTE
+#  endif
+# else /* !__apple_build_version__ */
+#  if __clang_major__ == 3 && __clang_minor__ >= 2 && __clang_minor__ <= 5
+#   undef EVUTIL_HAS_ATTRIBUTE
+#  endif
+# endif /* __apple_build_version__ */
+#endif /*\ defined(__clang__) && __clang__ == 1 */
+#ifndef EVUTIL_HAS_ATTRIBUTE
+# define EVUTIL_HAS_ATTRIBUTE(x) 0
+#endif
+
 /* If we need magic to say "inline", get it for free internally. */
 #ifdef EVENT__inline
 #define inline EVENT__inline
 #endif
-#if defined(EVENT____func__) && !defined(__func__)
-#define __func__ EVENT____func__
+
+/* Define to appropriate substitute if compiler doesnt have __func__ */
+#if defined(EVENT__HAVE___func__)
+# ifndef __func__
+#  define __func__ __func__
+# endif
+#elif defined(EVENT__HAVE___FUNCTION__)
+# define __func__ __FUNCTION__
+#else
+# define __func__ __FILE__
 #endif
 
 /* A good no-op to use in macro definitions. */
@@ -219,19 +247,26 @@ extern "C" {
  * when you care about ASCII's notion of character types, because you are about
  * to send those types onto the wire.
  */
+EVENT2_EXPORT_SYMBOL
 int EVUTIL_ISALPHA_(char c);
+EVENT2_EXPORT_SYMBOL
 int EVUTIL_ISALNUM_(char c);
 int EVUTIL_ISSPACE_(char c);
+EVENT2_EXPORT_SYMBOL
 int EVUTIL_ISDIGIT_(char c);
+EVENT2_EXPORT_SYMBOL
 int EVUTIL_ISXDIGIT_(char c);
 int EVUTIL_ISPRINT_(char c);
 int EVUTIL_ISLOWER_(char c);
 int EVUTIL_ISUPPER_(char c);
+EVENT2_EXPORT_SYMBOL
 char EVUTIL_TOUPPER_(char c);
+EVENT2_EXPORT_SYMBOL
 char EVUTIL_TOLOWER_(char c);
 
 /** Remove all trailing horizontal whitespace (space or tab) from the end of a
  * string */
+EVENT2_EXPORT_SYMBOL
 void evutil_rtrim_lws_(char *);
 
 
@@ -258,13 +293,16 @@ void evutil_rtrim_lws_(char *);
  */
 int evutil_open_closeonexec_(const char *pathname, int flags, unsigned mode);
 
+EVENT2_EXPORT_SYMBOL
 int evutil_read_file_(const char *filename, char **content_out, size_t *len_out,
     int is_binary);
 
+EVENT2_EXPORT_SYMBOL
 int evutil_socket_connect_(evutil_socket_t *fd_ptr, const struct sockaddr *sa, int socklen);
 
 int evutil_socket_finished_connecting_(evutil_socket_t fd);
 
+EVENT2_EXPORT_SYMBOL
 int evutil_ersatz_socketpair_(int, int , int, evutil_socket_t[]);
 
 int evutil_resolve_(int family, const char *hostname, struct sockaddr *sa,
@@ -289,15 +327,18 @@ struct evutil_weakrand_state {
  * attacker can't predict, or which passes strong statistical tests, use the
  * evutil_secure_rng* functions instead.
  */
+EVENT2_EXPORT_SYMBOL
 ev_uint32_t evutil_weakrand_seed_(struct evutil_weakrand_state *state, ev_uint32_t seed);
 /* Return a pseudorandom value between 0 and EVUTIL_WEAKRAND_MAX inclusive.
  * Updates the state in 'seed' as needed -- this value must be protected by a
  * lock.
  */
+EVENT2_EXPORT_SYMBOL
 ev_int32_t evutil_weakrand_(struct evutil_weakrand_state *seed);
 /* Return a pseudorandom value x such that 0 <= x < top. top must be no more
  * than EVUTIL_WEAKRAND_MAX. Updates the state in 'seed' as needed -- this
  * value must be proteced by a lock */
+EVENT2_EXPORT_SYMBOL
 ev_int32_t evutil_weakrand_range_(struct evutil_weakrand_state *seed, ev_int32_t top);
 
 /* Evaluates to the same boolean value as 'p', and hints to the compiler that
@@ -308,6 +349,12 @@ ev_int32_t evutil_weakrand_range_(struct evutil_weakrand_state *seed, ev_int32_t
 #define EVUTIL_UNLIKELY(p) (p)
 #endif
 
+#if EVUTIL_HAS_ATTRIBUTE(fallthrough)
+#define EVUTIL_FALLTHROUGH __attribute__((fallthrough))
+#else
+#define EVUTIL_FALLTHROUGH /* fallthrough */
+#endif
+
 /* Replacement for assert() that calls event_errx on failure. */
 #ifdef NDEBUG
 #define EVUTIL_ASSERT(cond) EVUTIL_NIL_CONDITION_(cond)
@@ -357,16 +404,22 @@ typedef struct evdns_getaddrinfo_request* (*evdns_getaddrinfo_fn)(
     const char *nodename, const char *servname,
     const struct evutil_addrinfo *hints_in,
     void (*cb)(int, struct evutil_addrinfo *, void *), void *arg);
+EVENT2_EXPORT_SYMBOL
 void evutil_set_evdns_getaddrinfo_fn_(evdns_getaddrinfo_fn fn);
 typedef void (*evdns_getaddrinfo_cancel_fn)(
     struct evdns_getaddrinfo_request *req);
+EVENT2_EXPORT_SYMBOL
 void evutil_set_evdns_getaddrinfo_cancel_fn_(evdns_getaddrinfo_cancel_fn fn);
 
+EVENT2_EXPORT_SYMBOL
 struct evutil_addrinfo *evutil_new_addrinfo_(struct sockaddr *sa,
     ev_socklen_t socklen, const struct evutil_addrinfo *hints);
+EVENT2_EXPORT_SYMBOL
 struct evutil_addrinfo *evutil_addrinfo_append_(struct evutil_addrinfo *first,
     struct evutil_addrinfo *append);
+EVENT2_EXPORT_SYMBOL
 void evutil_adjust_hints_for_addrconfig_(struct evutil_addrinfo *hints);
+EVENT2_EXPORT_SYMBOL
 int evutil_getaddrinfo_common_(const char *nodename, const char *servname,
     struct evutil_addrinfo *hints, struct evutil_addrinfo **res, int *portnum);
 
@@ -379,6 +432,7 @@ void evutil_getaddrinfo_cancel_async_(struct evdns_getaddrinfo_request *data);
 
 /** Return true iff sa is a looback address. (That is, it is 127.0.0.1/8, or
  * ::1). */
+EVENT2_EXPORT_SYMBOL
 int evutil_sockaddr_is_loopback_(const struct sockaddr *sa);
 
 
@@ -387,6 +441,7 @@ int evutil_sockaddr_is_loopback_(const struct sockaddr *sa);
     Returns a pointer to out.  Always writes something into out, so it's safe
     to use the output of this function without checking it for NULL.
  */
+EVENT2_EXPORT_SYMBOL
 const char *evutil_format_sockaddr_port_(const struct sockaddr *sa, char *out, size_t outlen);
 
 int evutil_hex_char_to_int_(char c);
@@ -396,6 +451,7 @@ void evutil_free_secure_rng_globals_(void);
 void evutil_free_globals_(void);
 
 #ifdef _WIN32
+EVENT2_EXPORT_SYMBOL
 HMODULE evutil_load_windows_system_library_(const TCHAR *library_name);
 #endif
 
@@ -444,6 +500,7 @@ HMODULE evutil_load_windows_system_library_(const TCHAR *library_name);
 #endif
 #endif
 
+EVENT2_EXPORT_SYMBOL
 evutil_socket_t evutil_socket_(int domain, int type, int protocol);
 evutil_socket_t evutil_accept4_(evutil_socket_t sockfd, struct sockaddr *addr,
     ev_socklen_t *addrlen, int flags);
@@ -476,6 +533,17 @@ evutil_socket_t evutil_eventfd_(unsigned initval, int flags);
 
 void evutil_memclear_(void *mem, size_t len);
 
+struct in_addr;
+struct in6_addr;
+
+/* This is a any, loopback, link-local, multicast */
+EVENT2_EXPORT_SYMBOL
+int evutil_v4addr_is_local_(const struct in_addr *in);
+/* This is a reserved, ipv4compat, ipv4map, loopback,
+ * link-local, multicast, or unspecified address. */
+EVENT2_EXPORT_SYMBOL
+int evutil_v6addr_is_local_(const struct in6_addr *in);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/ipc/chromium/src/third_party/libevent/win32select.c b/ipc/chromium/src/third_party/libevent/win32select.c
index 1766858c2ca2..d005b587d451 100644
--- a/ipc/chromium/src/third_party/libevent/win32select.c
+++ b/ipc/chromium/src/third_party/libevent/win32select.c
@@ -326,6 +326,8 @@ win32_dispatch(struct event_base *base, struct timeval *tv)
 	event_debug(("%s: select returned %d", __func__, res));
 
 	if (res <= 0) {
+		event_debug(("%s: %s", __func__,
+		    evutil_socket_error_to_string(EVUTIL_SOCKET_ERROR())));
 		return res;
 	}
 
@@ -350,7 +352,6 @@ win32_dispatch(struct event_base *base, struct timeval *tv)
 		}
 	}
 	if (win32op->writeset_out->fd_count) {
-		SOCKET s;
 		i = evutil_weakrand_range_(&base->weakrand_seed,
 		    win32op->writeset_out->fd_count);
 		for (j=0; j<win32op->writeset_out->fd_count; ++j) {
diff --git a/ipc/chromium/src/third_party/moz.build b/ipc/chromium/src/third_party/moz.build
index 98ab61524b5c..4cf8f923d865 100644
--- a/ipc/chromium/src/third_party/moz.build
+++ b/ipc/chromium/src/third_party/moz.build
@@ -16,13 +16,13 @@ if CONFIG['MOZ_SYSTEM_LIBEVENT']:
 UNIFIED_SOURCES += [
     'libevent/buffer.c',
     'libevent/bufferevent.c',
+    'libevent/bufferevent_filter.c',
     'libevent/bufferevent_ratelim.c',
     'libevent/bufferevent_sock.c',
     'libevent/evdns.c',
     'libevent/event.c',
     'libevent/event_tagging.c',
     'libevent/evmap.c',
-    'libevent/evrpc.c',
     'libevent/evthread.c',
     'libevent/evthread_pthread.c',
     'libevent/evutil.c',
@@ -37,6 +37,11 @@ UNIFIED_SOURCES += [
     'libevent/strlcpy.c',
 ]
 
+SOURCES += [
+    'libevent/bufferevent_pair.c', # conflicting types errors
+    'libevent/evrpc.c',            # conflicting TAILQ_ENTRY definition
+]
+
 if os_macosx or os_bsd:
     UNIFIED_SOURCES += [
         'libevent/kqueue.c',
