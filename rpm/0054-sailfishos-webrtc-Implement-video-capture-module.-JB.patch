From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Denis Grigorev <d.grigorev@omprussia.ru>
Date: Thu, 4 Feb 2021 21:14:28 +0300
Subject: [PATCH] [sailfishos][webrtc] Implement video capture module. JB#53982

Applies the ESR 78 patch "Implement video capture module. JB#53982" but
without the resulting changes to moz.build and configure.in, which are
autogenerated and are therefore now contained in a later patch.
---
 dom/media/systemservices/VideoFrameUtils.cpp  |  76 ++++--
 .../webrtc/api/video/video_frame_buffer.h     |   2 +-
 .../webrtc/modules/video_capture/BUILD.gn     |  25 +-
 .../video_capture/sfos/device_info_sfos.cc    | 142 ++++++++++
 .../video_capture/sfos/device_info_sfos.h     |  49 ++++
 .../video_capture/sfos/video_capture_sfos.cc  | 247 ++++++++++++++++++
 .../video_capture/sfos/video_capture_sfos.h   |  55 ++++
 .../video_capture/video_capture_impl.cc       |  12 +
 .../video_capture/video_capture_impl.h        |   2 +
 9 files changed, 578 insertions(+), 32 deletions(-)
 create mode 100644 third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.cc
 create mode 100644 third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.h
 create mode 100644 third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.cc
 create mode 100644 third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.h

diff --git a/dom/media/systemservices/VideoFrameUtils.cpp b/dom/media/systemservices/VideoFrameUtils.cpp
index 7593e2b5471c..d7b7776b9a7e 100644
--- a/dom/media/systemservices/VideoFrameUtils.cpp
+++ b/dom/media/systemservices/VideoFrameUtils.cpp
@@ -7,6 +7,7 @@
 #include "VideoFrameUtils.h"
 #include "webrtc/api/video/video_frame.h"
 #include "mozilla/ShmemPool.h"
+#include "libyuv/rotate.h"
 
 namespace mozilla {
 
@@ -32,22 +33,32 @@ void VideoFrameUtils::InitFrameBufferProperties(
   aDestProps.ntpTimeMs() = aVideoFrame.ntp_time_ms();
   aDestProps.renderTimeMs() = aVideoFrame.render_time_ms();
 
+  // Rotation will be applied during CopyVideoFrameBuffers().
   aDestProps.rotation() = aVideoFrame.rotation();
 
   auto i420 = aVideoFrame.video_frame_buffer()->ToI420();
   auto height = i420->height();
-  aDestProps.yAllocatedSize() = height * i420->StrideY();
-  aDestProps.uAllocatedSize() = ((height + 1) / 2) * i420->StrideU();
-  aDestProps.vAllocatedSize() = ((height + 1) / 2) * i420->StrideV();
+  auto width = i420->width();
+
+  if (aVideoFrame.rotation() == webrtc::kVideoRotation_90 ||
+      aVideoFrame.rotation() == webrtc::kVideoRotation_270) {
+    std::swap(width, height);
+  }
 
-  aDestProps.width() = i420->width();
   aDestProps.height() = height;
+  aDestProps.width() = width;
 
-  aDestProps.yStride() = i420->StrideY();
-  aDestProps.uStride() = i420->StrideU();
-  aDestProps.vStride() = i420->StrideV();
+  aDestProps.yStride() = width;
+  aDestProps.uStride() = (width + 1) / 2;
+  aDestProps.vStride() = (width + 1) / 2;
+
+  aDestProps.yAllocatedSize() = height * aDestProps.yStride();
+  aDestProps.uAllocatedSize() = ((height + 1) / 2) * aDestProps.uStride();
+  aDestProps.vAllocatedSize() = ((height + 1) / 2) * aDestProps.vStride();
 }
 
+// Performs copying to a shared memory or a temporary buffer.
+// Apply rotation here to avoid extra copying.
 void VideoFrameUtils::CopyVideoFrameBuffers(uint8_t* aDestBuffer,
                                             const size_t aDestBufferSize,
                                             const webrtc::VideoFrame& aFrame) {
@@ -62,23 +73,48 @@ void VideoFrameUtils::CopyVideoFrameBuffers(uint8_t* aDestBuffer,
       (i420->DataY() < i420->DataU()) && (i420->DataU() < i420->DataV()) &&
       //  Check that the last plane ends at firstPlane[totalsize]
       (&i420->DataY()[aggregateSize] ==
-       &i420->DataV()[((i420->height() + 1) / 2) * i420->StrideV()])) {
+       &i420->DataV()[((i420->height() + 1) / 2) * i420->StrideV()]) &&
+      aFrame.rotation() == webrtc::kVideoRotation_0) {
     memcpy(aDestBuffer, i420->DataY(), aggregateSize);
     return;
   }
 
-  // Copy each plane
-  size_t offset = 0;
-  size_t size;
-  auto height = i420->height();
-  size = height * i420->StrideY();
-  memcpy(&aDestBuffer[offset], i420->DataY(), size);
-  offset += size;
-  size = ((height + 1) / 2) * i420->StrideU();
-  memcpy(&aDestBuffer[offset], i420->DataU(), size);
-  offset += size;
-  size = ((height + 1) / 2) * i420->StrideV();
-  memcpy(&aDestBuffer[offset], i420->DataV(), size);
+  libyuv::RotationMode rotationMode;
+  int width = i420->width();
+  int height = i420->height();
+
+  switch (aFrame.rotation()) {
+    case webrtc::kVideoRotation_90:
+      rotationMode = libyuv::kRotate90;
+      std::swap(width, height);
+      break;
+    case webrtc::kVideoRotation_270:
+      rotationMode = libyuv::kRotate270;
+      std::swap(width, height);
+      break;
+    case webrtc::kVideoRotation_180:
+      rotationMode = libyuv::kRotate180;
+      break;
+    case webrtc::kVideoRotation_0:
+    default:
+      rotationMode = libyuv::kRotate0;
+      break;
+  }
+
+  int strideY = width;
+  int strideUV = (width + 1) / 2;
+  off_t offsetY = 0;
+  off_t offsetU = height * strideY;
+  off_t offsetV = offsetU + ((height + 1) / 2) * strideUV;
+
+  libyuv::I420Rotate(i420->DataY(), i420->StrideY(),
+                     i420->DataU(), i420->StrideU(),
+                     i420->DataV(), i420->StrideV(),
+                     &aDestBuffer[offsetY], strideY,
+                     &aDestBuffer[offsetU], strideUV,
+                     &aDestBuffer[offsetV], strideUV,
+                     i420->width(), i420->height(),
+                     rotationMode);
 }
 
 void VideoFrameUtils::CopyVideoFrameBuffers(
diff --git a/third_party/libwebrtc/webrtc/api/video/video_frame_buffer.h b/third_party/libwebrtc/webrtc/api/video/video_frame_buffer.h
index 2be7e0bb9f61..e586f0578191 100644
--- a/third_party/libwebrtc/webrtc/api/video/video_frame_buffer.h
+++ b/third_party/libwebrtc/webrtc/api/video/video_frame_buffer.h
@@ -106,7 +106,7 @@ class I420BufferInterface : public PlanarYuvBuffer {
   int ChromaWidth() const final;
   int ChromaHeight() const final;
 
-  rtc::scoped_refptr<I420BufferInterface> ToI420() final;
+  rtc::scoped_refptr<I420BufferInterface> ToI420();
 
  protected:
   ~I420BufferInterface() override {}
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/BUILD.gn b/third_party/libwebrtc/webrtc/modules/video_capture/BUILD.gn
index 6eef18a4b5d2..bf30693e4346 100644
--- a/third_party/libwebrtc/webrtc/modules/video_capture/BUILD.gn
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/BUILD.gn
@@ -98,16 +98,26 @@ if (!build_with_chromium) {
 
     if (is_linux || is_bsd) {
       sources = [
-        "linux/device_info_linux.cc",
-        "linux/device_info_linux.h",
-        "linux/video_capture_linux.cc",
-        "linux/video_capture_linux.h",
+        "sfos/device_info_sfos.cc",
+        "sfos/device_info_sfos.h",
+        "sfos/video_capture_sfos.cc",
+        "sfos/video_capture_sfos.h",
       ]
       deps += [
         "../..:webrtc_common",
         "../../media:rtc_media_base",
       ]
+
+      if (rtc_build_libyuv) {
+        deps += [ "$rtc_libyuv_dir" ]
+        public_deps = [
+          "$rtc_libyuv_dir",
+          ]
+      } else {
+        include_dirs += [ "$rtc_libyuv_dir/include" ]
+      }
     }
+
     if (is_win) {
       sources = [
         "windows/device_info_ds.cc",
@@ -151,13 +161,6 @@ if (!build_with_chromium) {
           "-lm",
         ]
       }
-      if (is_linux) {
-        ldflags += [
-          "-lrt",
-          "-lXext",
-          "-lX11",
-        ]
-      }
 
       deps = [
         ":video_capture_internal_impl",
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.cc b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.cc
new file mode 100644
index 000000000000..6d23fe3bfc4f
--- /dev/null
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.cc
@@ -0,0 +1,142 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include "mozilla/Preferences.h"
+#include "rtc_base/logging.h"
+#include "modules/video_capture/sfos/device_info_sfos.h"
+
+#define EXPECTED_CAPTURE_DELAY_PREF "media.getusermedia.camera.expected_capture_delay"
+#define MAX_WIDTH_PREF "media.getusermedia.camera.max_width"
+#define MAX_HEIGHT_PREF "media.getusermedia.camera.max_height"
+
+namespace webrtc
+{
+namespace videocapturemodule
+{
+VideoCaptureModule::DeviceInfo*
+VideoCaptureImpl::CreateDeviceInfo()
+{
+    // The caller doesn't check for return value, so I can't Init() here
+    return new videocapturemodule::DeviceInfoSFOS();
+}
+
+DeviceInfoSFOS::DeviceInfoSFOS()
+    : DeviceInfoImpl()
+{
+    Init();
+}
+
+int32_t DeviceInfoSFOS::Init()
+{
+    cameraManager = gecko_camera_manager();
+    // Initialize parent class member
+    _lastUsedDeviceName = (char *)malloc(1);
+    _lastUsedDeviceName[0] = 0;
+    return 0;
+}
+
+DeviceInfoSFOS::~DeviceInfoSFOS()
+{
+}
+
+uint32_t DeviceInfoSFOS::NumberOfDevices()
+{
+    RTC_LOG(LS_VERBOSE);
+
+    if (cameraManager) {
+        cameraList.clear();
+        for (int i = 0; i < cameraManager->getNumberOfCameras(); i++) {
+            gecko::camera::CameraInfo info;
+            if (cameraManager->getCameraInfo(i, info)) {
+                cameraList.push_back(info);
+            }
+        }
+        // Put front cameras at the top of the list, they are most often used during video chat.
+        std::sort(cameraList.begin(), cameraList.end(),
+                [](const gecko::camera::CameraInfo& c1, const gecko::camera::CameraInfo& c2) {
+                    bool c1front = c1.facing == gecko::camera::GECKO_CAMERA_FACING_FRONT;
+                    bool c2front = c2.facing == gecko::camera::GECKO_CAMERA_FACING_FRONT;
+                    return c1front > c2front;
+            });
+        return cameraList.size();
+    }
+    return 0;
+}
+
+int32_t DeviceInfoSFOS::GetDeviceName(
+        uint32_t deviceNumber,
+        char* deviceNameUTF8,
+        uint32_t deviceNameLength,
+        char* deviceUniqueIdUTF8,
+        uint32_t deviceUniqueIdUTF8Length,
+        char* productUniqueIdUTF8,
+        uint32_t productUniqueIdUTF8Length,
+        pid_t* /*pid*/)
+{
+    if (deviceNumber < cameraList.size()) {
+        gecko::camera::CameraInfo info = cameraList.at(deviceNumber);
+        strncpy(deviceNameUTF8, info.name.c_str(), deviceNameLength);
+        strncpy(deviceUniqueIdUTF8, info.id.c_str(), deviceUniqueIdUTF8Length);
+        strncpy(productUniqueIdUTF8, info.provider.c_str(), productUniqueIdUTF8Length);
+        return 0;
+    }
+
+    return -1;
+}
+
+int32_t DeviceInfoSFOS::CreateCapabilityMap(const char* deviceUniqueIdUTF8)
+{
+    const int32_t deviceUniqueIdUTF8Length =
+                            (int32_t) strlen((char*) deviceUniqueIdUTF8);
+    if (deviceUniqueIdUTF8Length > kVideoCaptureUniqueNameSize) {
+        RTC_LOG(LS_ERROR) << "Device name too long";
+        return -1;
+    }
+
+    FillCapabilities(deviceUniqueIdUTF8);
+
+    // Store the new used device name. The parent class needs this for some reason
+    _lastUsedDeviceNameLength = deviceUniqueIdUTF8Length;
+    _lastUsedDeviceName = (char*) realloc(_lastUsedDeviceName,
+                                                   _lastUsedDeviceNameLength + 1);
+    memcpy(_lastUsedDeviceName, deviceUniqueIdUTF8, _lastUsedDeviceNameLength + 1);
+
+    RTC_LOG(LS_INFO) << "Capability map for device " << deviceUniqueIdUTF8
+                   << " size " << _captureCapabilities.size();
+
+    return _captureCapabilities.size();
+}
+
+void DeviceInfoSFOS::FillCapabilities(const char *devName)
+{
+    std::vector<gecko::camera::CameraCapability> caps;
+    unsigned int captureDelay = mozilla::Preferences::GetUint(EXPECTED_CAPTURE_DELAY_PREF, 500);
+    unsigned int maxWidth = mozilla::Preferences::GetUint(MAX_WIDTH_PREF, 640);
+    unsigned int maxHeight = mozilla::Preferences::GetUint(MAX_HEIGHT_PREF, 480);
+
+    _captureCapabilities.clear();
+    if (cameraManager && cameraManager->queryCapabilities(devName, caps)) {
+        for (auto cap : caps) {
+            if (cap.width <= maxWidth && cap.height <= maxHeight) {
+                VideoCaptureCapability vcaps;
+                vcaps.width = cap.width;
+                vcaps.height = cap.height;
+                vcaps.maxFPS = cap.fps;
+                vcaps.videoType = VideoType::kI420;
+                _captureCapabilities.push_back(vcaps);
+            }
+        }
+    }
+}
+
+}  // namespace videocapturemodule
+}  // namespace webrtc
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.h b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.h
new file mode 100644
index 000000000000..33aadc17f9c1
--- /dev/null
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/device_info_sfos.h
@@ -0,0 +1,49 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef WEBRTC_MODULES_VIDEO_CAPTURE_MAIN_SOURCE_SFOS_DEVICE_INFO_SFOS_H_
+#define WEBRTC_MODULES_VIDEO_CAPTURE_MAIN_SOURCE_SFOS_DEVICE_INFO_SFOS_H_
+
+#include "modules/video_capture/device_info_impl.h"
+#include "modules/video_capture/video_capture_impl.h"
+#include "base/platform_thread.h"
+
+#include "geckocamera.h"
+
+namespace webrtc
+{
+namespace videocapturemodule
+{
+class DeviceInfoSFOS: public DeviceInfoImpl
+{
+public:
+    DeviceInfoSFOS();
+    virtual ~DeviceInfoSFOS();
+    virtual uint32_t NumberOfDevices();
+    virtual int32_t GetDeviceName(
+        uint32_t deviceNumber,
+        char* deviceNameUTF8,
+        uint32_t deviceNameLength,
+        char* deviceUniqueIdUTF8,
+        uint32_t deviceUniqueIdUTF8Length,
+        char* productUniqueIdUTF8=0,
+        uint32_t productUniqueIdUTF8Length=0,
+        pid_t* pid=0);
+    virtual int32_t CreateCapabilityMap (const char* deviceUniqueIdUTF8);
+    virtual int32_t DisplayCaptureSettingsDialogBox(
+        const char* /*deviceUniqueIdUTF8*/,
+        const char* /*dialogTitleUTF8*/,
+        void* /*parentWindow*/,
+        uint32_t /*positionX*/,
+        uint32_t /*positionY*/) { return -1; }
+    void FillCapabilities(const char* devName);
+    int32_t Init();
+
+private:
+    gecko::camera::CameraManager *cameraManager;
+    std::vector<gecko::camera::CameraInfo> cameraList;
+};
+}  // namespace videocapturemodule
+}  // namespace webrtc
+#endif // WEBRTC_MODULES_VIDEO_CAPTURE_MAIN_SOURCE_SFOS_DEVICE_INFO_SFOS_H_
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.cc b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.cc
new file mode 100644
index 000000000000..c0f892985a08
--- /dev/null
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.cc
@@ -0,0 +1,247 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include <errno.h>
+#include <fcntl.h>
+#include <stdio.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+#include <new>
+
+#include "rtc_base/logging.h"
+#include "system_wrappers/include/clock.h"
+#include "api/video/i420_buffer.h"
+#include "rtc_base/refcount.h"
+#include "rtc_base/refcountedobject.h"
+#include "rtc_base/scoped_ref_ptr.h"
+
+#include "libyuv/convert.h"
+
+#include "modules/video_capture/sfos/video_capture_sfos.h"
+
+namespace webrtc {
+namespace videocapturemodule {
+
+class GeckoVideoBuffer : public I420BufferInterface {
+public:
+    static rtc::scoped_refptr<GeckoVideoBuffer> Create(std::shared_ptr<const gecko::camera::YCbCrFrame> frame) {
+        return new rtc::RefCountedObject<GeckoVideoBuffer>(frame);
+    }
+
+    GeckoVideoBuffer(std::shared_ptr<const gecko::camera::YCbCrFrame> frame)
+        : ycbcr(frame) {}
+
+    int width () const { return ycbcr->width; };
+    int height() const { return ycbcr->height; };
+
+    const uint8_t* DataY() const { return (const uint8_t*)ycbcr->y; };
+    const uint8_t* DataU() const { return (const uint8_t*)ycbcr->cb; };
+    const uint8_t* DataV() const { return (const uint8_t*)ycbcr->cr; };
+
+    int StrideY() const { return ycbcr->yStride; };
+    int StrideU() const { return ycbcr->cStride; };
+    int StrideV() const { return ycbcr->cStride; };
+
+    void *native_handle() const { return (void *)&ycbcr; };
+
+    Type type() const override { return ycbcr->chromaStep == 1 ? Type::kI420 : Type::kNative; }
+
+    rtc::scoped_refptr<I420BufferInterface> ToI420() {
+        if (ycbcr->chromaStep == 1) {
+            return this;
+        } else if (ycbcr->chromaStep == 2) {
+            rtc::scoped_refptr<I420Buffer> buffer = I420Buffer::Create(
+                    ycbcr->width, ycbcr->height);
+
+            libyuv::NV12ToI420(
+                    (const uint8_t*)ycbcr->y, ycbcr->yStride,
+                    (const uint8_t*)ycbcr->cb, ycbcr->cStride,
+                    buffer->MutableDataY(), buffer->StrideY(),
+                    buffer->MutableDataU(), buffer->StrideU(),
+                    buffer->MutableDataV(), buffer->StrideV(),
+                    ycbcr->width, ycbcr->height);
+            return buffer;
+        } else {
+            // Unsupported format
+            rtc::scoped_refptr<I420Buffer> buffer = I420Buffer::Create(
+                    ycbcr->width, ycbcr->height);
+            I420Buffer::SetBlack(buffer.get());
+            return buffer;
+        }
+    }
+
+private:
+    std::shared_ptr<const gecko::camera::YCbCrFrame> ycbcr;
+};
+
+rtc::scoped_refptr<VideoCaptureModule> VideoCaptureImpl::Create(
+    const char* deviceUniqueId) {
+    rtc::scoped_refptr<VideoCaptureModuleSFOS> implementation(
+        new rtc::RefCountedObject<VideoCaptureModuleSFOS>());
+
+    if (implementation->Init(deviceUniqueId) != 0)
+        return nullptr;
+
+    return implementation;
+}
+
+VideoCaptureModuleSFOS::VideoCaptureModuleSFOS()
+    : VideoCaptureImpl()
+{
+    mozilla::hal::ScreenConfiguration screenConfig;
+
+    mozilla::hal::RegisterScreenConfigurationObserver (this);
+    mozilla::hal::GetCurrentScreenConfiguration (&screenConfig);
+    _screenRotationAngle = ScreenOrientationToAngle (screenConfig.orientation());
+}
+
+int32_t VideoCaptureModuleSFOS::Init(const char* deviceUniqueIdUTF8)
+{
+    /* Fill current device name for the parent class */
+    int len = strlen(deviceUniqueIdUTF8);
+    _deviceUniqueId = new (std::nothrow) char[len + 1];
+    if (_deviceUniqueId) {
+        memcpy(_deviceUniqueId, deviceUniqueIdUTF8, len + 1);
+    } else {
+        return -1;
+    }
+
+    if (gecko_camera_manager()->openCamera(deviceUniqueIdUTF8, _camera)) {
+        gecko::camera::CameraInfo info;
+        if (_camera->getInfo(info)) {
+            _rearFacingCamera = info.facing == gecko::camera::GECKO_CAMERA_FACING_REAR;
+            _sensorMountAngle = info.mountAngle;
+            _camera->setListener(this);
+            return 0;
+        }
+        _camera.reset();
+    }
+    return -1;
+}
+
+VideoCaptureModuleSFOS::~VideoCaptureModuleSFOS()
+{
+    mozilla::hal::UnregisterScreenConfigurationObserver(this);
+}
+
+int32_t VideoCaptureModuleSFOS::StartCapture(
+    const VideoCaptureCapability& capability)
+{
+    if (_camera->captureStarted()) {
+        if (capability.width == _requestedCapability.width
+                && capability.height == _requestedCapability.height
+                && capability.maxFPS == _requestedCapability.maxFPS) {
+            return 0;
+        } else {
+            _camera->stopCapture();
+        }
+    }
+
+    _startNtpTimeMs = webrtc::Clock::GetRealTimeClock()->CurrentNtpInMilliseconds();
+    UpdateCaptureRotation();
+
+    _requestedCapability = capability;
+    _requestedCapability.videoType = VideoType::kI420;
+
+    gecko::camera::CameraCapability cap;
+    cap.width = capability.width;
+    cap.height = capability.height;
+    cap.fps = capability.maxFPS;
+    return _camera->startCapture(cap) ? 0 : -1;
+}
+
+int32_t VideoCaptureModuleSFOS::StopCapture()
+{
+    return _camera->stopCapture() ? 0 : -1;
+}
+
+bool VideoCaptureModuleSFOS::CaptureStarted()
+{
+    return _camera->captureStarted();
+}
+
+void VideoCaptureModuleSFOS::Notify(const mozilla::hal::ScreenConfiguration& aConfiguration)
+{
+    RTC_LOG(LS_INFO) << "VideoCaptureModuleSFOS::Notify ScreenConfiguration.orientation: " << aConfiguration.orientation();
+    _screenRotationAngle = ScreenOrientationToAngle(aConfiguration.orientation());
+    UpdateCaptureRotation();
+}
+
+int VideoCaptureModuleSFOS::ScreenOrientationToAngle(mozilla::hal::ScreenOrientation orientation)
+{
+    switch (orientation) {
+    // The default orientation is portrait for Sailfish OS.
+    case mozilla::hal::eScreenOrientation_Default:
+    case mozilla::hal::eScreenOrientation_PortraitPrimary:
+        return 0;
+    case mozilla::hal::eScreenOrientation_LandscapePrimary:
+        return 90;
+    case mozilla::hal::eScreenOrientation_PortraitSecondary:
+        return 180;
+    case mozilla::hal::eScreenOrientation_LandscapeSecondary:
+        return 270;
+    default:
+        return 0;
+    }
+}
+
+void VideoCaptureModuleSFOS::onCameraFrame(std::shared_ptr<gecko::camera::GraphicBuffer> grb)
+{
+    int64_t captureTime = grb->timestampUs / 1000 + _startNtpTimeMs;
+    RTC_LOG(LS_VERBOSE) << "frame ts=" << captureTime;
+
+    if (grb->imageFormat == gecko::camera::ImageFormat::YCbCr) {
+        std::shared_ptr<const gecko::camera::YCbCrFrame> frame = grb->mapYCbCr();
+        if (frame) {
+            auto buffer = GeckoVideoBuffer::Create(frame);
+            IncomingVideoBuffer(std::move(buffer->ToI420()), captureTime);
+            return;
+        }
+    }
+
+    RTC_LOG(LS_ERROR) << "Invalid image format";
+}
+
+void VideoCaptureModuleSFOS::onCameraError(std::string errorDescription)
+{
+    RTC_LOG(LS_ERROR) << "Camera error " << errorDescription << "\n";
+}
+
+void VideoCaptureModuleSFOS::UpdateCaptureRotation()
+{
+    VideoRotation rotation;
+    int rotateAngle = 360 + _sensorMountAngle + (_rearFacingCamera ? -_screenRotationAngle : _screenRotationAngle);
+
+    switch (rotateAngle % 360) {
+    case 90:
+        rotation = kVideoRotation_90;
+        break;
+    case 180:
+        rotation = kVideoRotation_180;
+        break;
+    case 270:
+        rotation = kVideoRotation_270;
+        break;
+    default:
+        rotation = kVideoRotation_0;
+        break;
+    }
+
+    RTC_LOG(LS_INFO) << "Sensor mount angle=" << _sensorMountAngle
+                   << " Screen rotation=" << _screenRotationAngle
+                   << " Capture rotation=" << rotateAngle;
+    VideoCaptureImpl::SetCaptureRotation (rotation);
+}
+
+int32_t VideoCaptureModuleSFOS::CaptureSettings(VideoCaptureCapability& settings)
+{
+    settings = _requestedCapability;
+    return 0;
+}
+}  // namespace videocapturemodule
+}  // namespace webrtc
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.h b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.h
new file mode 100644
index 000000000000..2e46449fdc3a
--- /dev/null
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/sfos/video_capture_sfos.h
@@ -0,0 +1,55 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef WEBRTC_MODULES_VIDEO_CAPTURE_MAIN_SOURCE_SFOS_VIDEO_CAPTURE_SFOS_H_
+#define WEBRTC_MODULES_VIDEO_CAPTURE_MAIN_SOURCE_SFOS_VIDEO_CAPTURE_SFOS_H_
+
+#include <memory>
+
+#include "mozilla/Hal.h"
+#include "mozilla/dom/ScreenOrientation.h"
+
+#include "common_types.h"
+#include "modules/video_capture/video_capture_impl.h"
+
+#include "geckocamera.h"
+
+namespace webrtc
+{
+class CriticalSectionWrapper;
+namespace videocapturemodule
+{
+class VideoCaptureModuleSFOS
+    : public VideoCaptureImpl,
+      public gecko::camera::CameraListener,
+      public mozilla::hal::ScreenConfigurationObserver
+{
+public:
+    VideoCaptureModuleSFOS();
+    virtual ~VideoCaptureModuleSFOS();
+    virtual int32_t Init(const char* deviceUniqueId);
+    virtual int32_t StartCapture(const VideoCaptureCapability& capability);
+    virtual int32_t StopCapture();
+    virtual bool CaptureStarted();
+    virtual int32_t CaptureSettings(VideoCaptureCapability& settings);
+
+    void onCameraFrame(std::shared_ptr<gecko::camera::GraphicBuffer> buffer) override;
+    void onCameraError(std::string errorDescription) override;
+
+    virtual void Notify(const mozilla::hal::ScreenConfiguration& aConfiguration) override;
+
+private:
+    int ScreenOrientationToAngle(mozilla::hal::ScreenOrientation orientation);
+    void UpdateCaptureRotation();
+
+    int _screenRotationAngle = 0;
+    int _sensorMountAngle = 0;
+    bool _rearFacingCamera = false;
+    uint64_t _startNtpTimeMs = 0;
+    std::shared_ptr<gecko::camera::Camera> _camera;
+};
+}  // namespace videocapturemodule
+}  // namespace webrtc
+
+#endif // WEBRTC_MODULES_VIDEO_CAPTURE_MAIN_SOURCE_SFOS_VIDEO_CAPTURE_SFOS_H_
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.cc b/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.cc
index ffbcfac85c98..fd4dfc6c01e7 100644
--- a/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.cc
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.cc
@@ -281,5 +281,17 @@ uint32_t VideoCaptureImpl::CalculateFrameRate(int64_t now_ns) {
 
   return nrOfFrames;
 }
+
+int32_t VideoCaptureImpl::IncomingVideoBuffer(const rtc::scoped_refptr<VideoFrameBuffer>& buffer, uint64_t captureTime)
+{
+    rtc::CritScope cs(&_apiCs);
+    VideoFrame captureFrame(
+          buffer, 0, rtc::TimeMillis(),
+          !apply_rotation_ ? _rotateFrame : kVideoRotation_0);
+    captureFrame.set_ntp_time_ms(captureTime);
+    captureFrame.set_rotation(_rotateFrame);
+    DeliverCapturedFrame(captureFrame);
+    return 0;
+}
 }  // namespace videocapturemodule
 }  // namespace webrtc
diff --git a/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.h b/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.h
index 32eca599f09f..bf36bb5f7a6f 100644
--- a/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.h
+++ b/third_party/libwebrtc/webrtc/modules/video_capture/video_capture_impl.h
@@ -78,6 +78,8 @@ public:
                           const VideoCaptureCapability& frameInfo,
                           int64_t captureTime = 0) override;
 
+    int32_t IncomingVideoBuffer(const rtc::scoped_refptr<VideoFrameBuffer>& buffer, uint64_t captureTime);
+
     // Platform dependent
     int32_t StartCapture(const VideoCaptureCapability& capability) override
     {
